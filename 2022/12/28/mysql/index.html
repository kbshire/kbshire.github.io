



<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#FFF">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">


<link rel="alternate" type="application/rss+xml" title="Hexo" href="http://example.com/rss.xml" />
<link rel="alternate" type="application/atom+xml" title="Hexo" href="http://example.com/atom.xml" />
<link rel="alternate" type="application/json" title="Hexo" href="http://example.com/feed.json" />

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="/css/app.css?v=0.2.5">

  

<link rel="canonical" href="http://example.com/2022/12/28/mysql/">



  <title>
Mysql |
Yume Shoka = Hexo</title>
<meta name="generator" content="Hexo 5.4.2"></head>
<body itemscope itemtype="http://schema.org/WebPage">
  <div id="loading">
    <div class="cat">
      <div class="body"></div>
      <div class="head">
        <div class="face"></div>
      </div>
      <div class="foot">
        <div class="tummy-end"></div>
        <div class="bottom"></div>
        <div class="legs left"></div>
        <div class="legs right"></div>
      </div>
      <div class="paw">
        <div class="hands left"></div>
        <div class="hands right"></div>
      </div>
    </div>
  </div>
  <div id="container">
    <header id="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="inner">
        <div id="brand">
          <div class="pjax">
          
  <h1 itemprop="name headline">Mysql
  </h1>
  
<div class="meta">
  <span class="item" title="Created: 2022-12-28 13:38:45">
    <span class="icon">
      <i class="ic i-calendar"></i>
    </span>
    <span class="text">Posted on</span>
    <time itemprop="dateCreated datePublished" datetime="2022-12-28T13:38:45+08:00">2022-12-28</time>
  </span>
</div>


          </div>
        </div>
        <nav id="nav">
  <div class="inner">
    <div class="toggle">
      <div class="lines" aria-label="Toggle navigation bar">
        <span class="line"></span>
        <span class="line"></span>
        <span class="line"></span>
      </div>
    </div>
    <ul class="menu">
      <li class="item title"><a href="/" rel="start">Yume Shoka</a></li>
    </ul>
    <ul class="right">
      <li class="item theme">
        <i class="ic i-sun"></i>
      </li>
      <li class="item search">
        <i class="ic i-search"></i>
      </li>
    </ul>
  </div>
</nav>

      </div>
      <div id="imgs" class="pjax">
        <ul>
          <li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/9d41e0144387641f894a827002ea5c33.jpg"></li>
          <li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/9d916994e193f2640e3660e986b3226d.jpg"></li>
          <li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/f534e931ecbd67c0161d82dabb45ca42.jpg"></li>
          <li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/b7dd27ac7273dd91b0085c941520d6f5.jpg"></li>
          <li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/68fb5832b107119e9f351a83be51ed2f.jpg"></li>
          <li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/e9387f53393624bd88390036d7943fad.jpg"></li>
        </ul>
      </div>
    </header>
    <div id="waves">
      <svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
        <defs>
          <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z" />
        </defs>
        <g class="parallax">
          <use xlink:href="#gentle-wave" x="48" y="0" />
          <use xlink:href="#gentle-wave" x="48" y="3" />
          <use xlink:href="#gentle-wave" x="48" y="5" />
          <use xlink:href="#gentle-wave" x="48" y="7" />
        </g>
      </svg>
    </div>
    <main>
      <div class="inner">
        <div id="main" class="pjax">
          
  <div class="article wrap">
    
<div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList">
<i class="ic i-home"></i>
<span><a href="/">Home</a></span>
</div>

    <article itemscope itemtype="http://schema.org/Article" class="post block" lang="en">
  <link itemprop="mainEntityOfPage" href="http://example.com/2022/12/28/mysql/">

  <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="image" content="/images/avatar.jpg">
    <meta itemprop="name" content="John Doe">
    <meta itemprop="description" content=", ">
  </span>

  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Hexo">
  </span>

  <div class="body md" itemprop="articleBody">
    

    <h1 id="mysql"><a class="markdownIt-Anchor" href="#mysql">#</a> MySQL</h1>
<p>公钥加密，私钥解密→加密</p>
<p>私钥加密，公钥解密→签名</p>
<p>mysql 常见错误</p>
<blockquote>
<p>1044：当前用户没有访问数据库的权限</p>
<p>1045 密码错误</p>
<p>1065 无效的 SQL 语句，SQL 语句为空</p>
<p>1180 提交事务失败</p>
<p>1181 回滚事务失败</p>
<p>2002 数据库没有启动或者是端口被防火墙禁止</p>
<p>2003 错误不开放外链</p>
</blockquote>
<p>innodb 行锁 &gt;5.5</p>
<p>MyISAM 表锁</p>
<p>utf8mb4 四子节</p>
<p>utf8 三子节 可能导致截断产生 xss</p>
<p>模糊匹配变量名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show variables like “%character%”</span><br></pre></td></tr></table></figure>
<p>本地变量只在当前窗口生效</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set session var = bbb;</span><br></pre></td></tr></table></figure>
<p>全局变量在所有窗口生效</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global var = aaa;</span><br></pre></td></tr></table></figure>
<p>查看密码 5.5 以后 password 字段变为 authentication_string</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">select host,password,user from mysql.user;</span><br><span class="line">mysql&gt; select host,password,user from mysql.user;</span><br><span class="line">+-----------+-------------------------------------------+---------+</span><br><span class="line">| host      | password                                  | user    |</span><br><span class="line">+-----------+-------------------------------------------+---------+</span><br><span class="line">| localhost | *FAAFFE644E901CFAFAEC7562415E5FAEC243B8B2 | root    |</span><br><span class="line">| 127.0.0.1 | *FAAFFE644E901CFAFAEC7562415E5FAEC243B8B2 | root    |</span><br><span class="line">| ::1       | *FAAFFE644E901CFAFAEC7562415E5FAEC243B8B2 | root    |</span><br><span class="line">| localhost |                                           |         |</span><br><span class="line">| localhost | *FAAFFE644E901CFAFAEC7562415E5FAEC243B8B2 | root123 |</span><br><span class="line">| 127.0.0.1 | *FAAFFE644E901CFAFAEC7562415E5FAEC243B8B2 | root123 |</span><br><span class="line">+-----------+-------------------------------------------+---------+</span><br></pre></td></tr></table></figure>
<p>创建用户</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create user &#x27;llisi&#x27;@&#x27;localhost&#x27;identified by &#x27;123456&#x27;;</span><br><span class="line">grant all on sec.* to &#x27;root&#x27;@&#x27;%&#x27; identified by &#x27;123456&#x27;;</span><br></pre></td></tr></table></figure>
<p>给用户加远程登录权限时必须在配置文件中修改 bindip</p>
<p>mysql.user 在新版中是一个视图，不能直接 insert 来新建用户。如果设置严格模式也可能导致 insert 插入用户失败</p>
<p>修改密码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Alert user ‘root’@‘localhost’ identified by ‘passed’</span><br></pre></td></tr></table></figure>
<p>删除用户</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop user aaa@localhost</span><br></pre></td></tr></table></figure>
<p>创建数据库</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create database if not exist test;</span><br><span class="line">drop database if exist test</span><br></pre></td></tr></table></figure>
<p>查看建库语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show create database dbs;</span><br></pre></td></tr></table></figure>
<p>创建表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create table if not exists yanchuang (</span><br><span class="line">id int(5) unsigned not null primary key auto_increment，</span><br><span class="line">name varchar(4)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>varchar 后的数字代表显示字符长度，如果开启严格模式会报错 1406，关闭后插入的字符会缺失</p>
<p>int 后的数字必须配合 zerofill 使用，使用后代表最小的位数，如果不够用 0 填充的 int 后面的数字位数</p>
<p>插入数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">insert into test (name,age) values (haha,123);</span><br><span class="line">insert into test set name=&quot;aaa&quot;,age=100;</span><br></pre></td></tr></table></figure>
<h2 id="索引"><a class="markdownIt-Anchor" href="#索引">#</a> 索引</h2>
<p><strong>索引的出现其实就是为了提高数据查询的效率，就像书的目录一样</strong>。</p>
<h3 id="索引常见模型"><a class="markdownIt-Anchor" href="#索引常见模型">#</a> 索引常见模型</h3>
<p>三种常见、也比较简单的数据结构，<strong>它们分别是哈希表、有序数组和搜索树</strong>。</p>
<h4 id="哈希表"><a class="markdownIt-Anchor" href="#哈希表">#</a> 哈希表</h4>
<p><strong>哈希表是一种以键 - 值（key-value）存储数据的结构，我们只要输入待查找的键即 key，就可以找到其对应的值即 Value</strong>。哈希的思路很简单，把值放在数组里，用一个哈希函数把 key 换算成一个确定的位置，然后把 value 放在数组的这个位置。</p>
<p>你现在维护着一个身份证信息和姓名的表，需要根据身份证号查找对应的名字，这时对应的哈希索引的示意图</p>
<p><img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/0c62b601afda86fe5d0fe57346ace957.png" alt="img"></p>
<p>将 ID_card_n2 通过哈希函数算出 N；然后，按顺序遍历，找到 User2。</p>
<p>四个 ID_card_n 的值并不是递增的，这样做的好处是增加新的 User 时速度会很快，只需要往后追加。但缺点是，因为不是有序的，所以哈希索引做区间查询的速度是很慢的。</p>
<p>所以，<strong>哈希表这种结构适用于只有等值查询的场景</strong>，比如 Memcached 及其他一些 NoSQL 引擎。key-value</p>
<p>比如 select * from users where name=“aaa”;</p>
<h4 id="有序数组"><a class="markdownIt-Anchor" href="#有序数组">#</a> 有序数组</h4>
<p><strong>有序数组在等值查询和范围查询场景中的性能就都非常优秀</strong>。</p>
<p>这里我们假设身份证号没有重复，这个数组就是按照身份证号递增的顺序保存的。这时候如果你要查 ID_card_n2 对应的名字，用二分法就可以快速得到，这个时间复杂度是 O (log (N))。</p>
<p>同时很显然，这个索引结构支持范围查询。你要查身份证号在 [ID_card_X, ID_card_Y] 区间的 User，可以先用二分法找到 ID_card_X（如果不存在 ID_card_X，就找到大于 ID_card_X 的第一个 User），然后向右遍历，直到查到第一个大于 ID_card_Y 的身份证号，退出循环。</p>
<p>但是，在需要更新数据的时候就麻烦了，你往中间插入一个记录就必须得挪动后面所有的记录，成本太高。</p>
<p>所以，<strong>有序数组索引只适用于静态存储引擎</strong>，比如你要保存的是 2017 年某个城市的所有人口信息，这类不会再修改的数据。</p>
<p><img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/bfc907a92f99cadf5493cf0afac9ca49.png" alt="img"></p>
<h4 id="二叉搜索树"><a class="markdownIt-Anchor" href="#二叉搜索树">#</a> 二叉搜索树</h4>
<p><img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/04fb9d24065635a6a637c25ba9ddde68.png" alt="img"></p>
<p>父节点左子树所有结点的值小于父节点的值，右子树所有结点的值大于父节点的值。这样如果你要查 ID_card_n2 的话，<strong>按照图中的搜索顺序就是按照 UserA -&gt; UserC -&gt; UserF -&gt; User2 这个路径得到。这个时间复杂度是 O (log (N))。</strong></p>
<p>树可以有二叉，也可以有多叉。多叉树就是每个节点有多个儿子，儿子之间的大小保证从左到右递增。二叉树是搜索效率最高的，但是实际上大多数的数据库存储却并不使用二叉树。其原因是，索引不止存在内存中，还要写到磁盘上。</p>
<p>一棵 100 万节点的平衡二叉树，树高 20。一次查询可能需要访问 20 个数据块。在机械硬盘时代，从磁盘随机读一个数据块需要 10 ms 左右的寻址时间。也就是说，对于一个 100 万行的表，如果使用二叉树来存储，单独访问一个行可能需要 20 个 10 ms 的时间，这个查询可真够慢的。</p>
<p>（2 ** 20）= 1048576</p>
<p><strong>为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该使用二叉树，而是要使用 “N 叉” 树。这里，“N 叉” 树中的 “N” 取决于数据块的大小。</strong></p>
<p>以 InnoDB 的一个整数字段索引为例，这个 N 差不多是 1200 (<strong>MySql 默认一个存储页面的大小为 16K，一个整数（bigint）字段索引的长度为 8B, 另外每个索引还跟着 6B 的指向其子树的指针；所以 16K/14B ≈ 1170</strong>)。这棵树高是 3 的时候，就可以存 1200 的 2 次方个值，这已经 8 亿了。考虑到树根的数据块总是在内存中的，一个 8 亿行的表上一个整数字段的索引，查找一个值最多只需要访问 3 次磁盘。其实，树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了。</p>
<h4 id="b-tree"><a class="markdownIt-Anchor" href="#b-tree">#</a> B-tree</h4>
<p><img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/1383365-20190131112848755-208066245.png" alt="img"></p>
<p>由于每个节点还是存储数据，还是需要访问磁盘</p>
<h4 id="btree"><a class="markdownIt-Anchor" href="#btree">#</a> B+tree</h4>
<p>InnoDB 存储引擎就是用 B+Tree 实现其索引结构。</p>
<blockquote>
<p>B+Tree 相对于 B-Tree 有几点不同：</p>
<ol>
<li>B + 节点关键字搜索采用闭合区间</li>
<li>B+<strong> 非叶节点不保存数据相关信息</strong>，只保存关键字和子节点的引用</li>
<li>B + 关键字对应的数据保存在叶子节点中</li>
<li>B + 叶子节点是顺序排列的，并且相邻节点具有顺序引用的关系</li>
</ol>
</blockquote>
<p>B+Tree 是在 B-Tree 基础上的一种优化，使其更适合实现外存储索引结构，InnoDB 存储引擎就是用 B+Tree 实现其索引结构。只有叶子节点才存放数据</p>
<p><img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/1383365-20190131125319027-1361502032.png" alt="img"></p>
<p>B + 以页为单位，1 页 = 16kb，可以修改 innodb_page_size，只能在初始化时修改，即需要删除 ibdata1 和 ib_logfile0</p>
<p>添加索引 index，key</p>
<p>key 定义主键索引，一个表中只能有一个主键，一个主键可以包含多个字段</p>
<p>index 定义索引</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">primary key(id),</span><br></pre></td></tr></table></figure>
<p><code>index idx_name (name)</code>  其作用和 <code>key ind_name(name)</code>  相同</p>
<p>删除主键索引需要先删除 auto_increment，再删除主键索引</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alter table chenke change id id int unsigned not null</span><br><span class="line">alter table chenke drop primary key</span><br><span class="line">desc chenke </span><br></pre></td></tr></table></figure>
<p>约束信息可以在 information_schema 表中查看</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from information_schema.key_column_usage where table_name=&#x27;test1&#x27;;</span><br></pre></td></tr></table></figure>
<p>创建索引</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">create index ind on test (id,name)    //</span><br><span class="line">create index ind on test (id,name(5)) //以前五个字符当做索引，称为最左前缀索引</span><br><span class="line"></span><br><span class="line">index index_name (`name`,`gender`,`age`) //name在最左</span><br></pre></td></tr></table></figure>
<p>explain 查看是否命中索引，用于分析语句效率</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">explain seelct * from stu where gender=1</span><br></pre></td></tr></table></figure>
<p><img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221116110850137.png" alt="image-20221116110850137"></p>
<p><img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221116110935205.png" alt="image-20221116110935205"></p>
<h3 id="innodb索引模型"><a class="markdownIt-Anchor" href="#innodb索引模型">#</a> InnoDB 索引模型</h3>
<p>在 InnoDB 中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。又因为前面我们提到的，InnoDB 使用了 B+ 树索引模型，所以数据都是存储在 B+ 树中的。</p>
<blockquote>
<p>mysql&gt; create table T(</p>
<p>id int primary key,</p>
<p>k int not null,</p>
<p>name varchar(16),</p>
<p>index (k))engine=InnoDB;</p>
</blockquote>
<p>根据叶子节点的内容，索引类型分为主键索引和非主键索引。</p>
<p><strong>主键索引的叶子节点存的是整行数据。在 InnoDB 里，主键索引也被称为聚簇索引（clustered index）。</strong></p>
<p><strong>非主键索引的叶子节点内容是主键的值。在 InnoDB 里，非主键索引也被称为二级索引（secondary index）。</strong></p>
<p><img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/dcda101051f28502bd5c4402b292e38d.png" alt="img"></p>
<p><strong>如果语句是 select * from T where ID=500，即主键查询方式，则只需要搜索 ID 这棵 B+ 树；</strong></p>
<p><strong>如果语句是 select * from T where k=5，即普通索引查询方式，则需要先搜索 k 索引树，得到 ID 的值为 500，再到 ID 索引树搜索一次。这个过程称为回表。</strong></p>
<p>也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。</p>
<h3 id="最左前缀索引"><a class="markdownIt-Anchor" href="#最左前缀索引">#</a> 最左前缀索引</h3>
<p>为了直观地说明这个概念，我们用（name，age）这个联合索引来分析</p>
<p><img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/89f74c631110cfbc83298ef27dcd6370.jpg" alt="img"></p>
<p>可以看到，索引项是按照索引定义里面出现的字段顺序排序的。</p>
<p>如果你要查的是所有名字第一个字是 “张” 的人，你的 SQL 语句的条件是 &quot;where name like ‘张 %’&quot;。这时，你也能够用上这个索引，查找到第一个符合条件的记录是 ID3，然后向后遍历，直到不满足条件为止。</p>
<p>可以看到，不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。</p>
<p>必须要有最左前缀在查询中，即使用索引，因为 mysql 查询时会优化，将最左前缀放到最前面</p>
<p>假设，你现在维护一个支持邮箱登录的系统，用户表是这么定义的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table SUser(</span><br><span class="line">ID bigint unsigned primary key,</span><br><span class="line">email varchar(64), </span><br><span class="line">username varchar(100)</span><br><span class="line">)engine=innodb; </span><br></pre></td></tr></table></figure>
<p>由于要使用邮箱登录，所以业务代码中一定会出现类似于这样的语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select f1, f2 from SUser where email=&#x27;xxx&#x27;;</span><br></pre></td></tr></table></figure>
<p>如果 email 这个字段上没有索引，那么这个语句就只能做全表扫描。</p>
<p>比如，这两个在 email 字段上创建索引的语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; alter table SUser add index index2(email);</span><br><span class="line">mysql&gt; alter table SUser add index index2(email(6));</span><br><span class="line">由于 email(6) 这个索引结构中每个邮箱字段都只取前 6 个字节（即：zhangs），所以占用的空间会更小，这就是使用前缀索引的优势。</span><br></pre></td></tr></table></figure>
<p>如果拿整个邮箱做索引</p>
<p><img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/d31da662bee595991862c439a5567eb7.jpg" alt="img"></p>
<p>email (6) 索引结构</p>
<p><img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/134583875561de914991fc2e192cf842.jpg" alt="img"></p>
<p>从图中你可以看到，由于 email (6) 这个索引结构中每个邮箱字段都只取前 6 个字节（即：zhangs），所以占用的空间会更小，这就是使用前缀索引的优势。</p>
<p><strong>如果使用的是 index1</strong>（即 email 整个字符串的索引结构），执行顺序是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">从 index1 索引树找到满足索引值是’zhangssxyz@xxx.com’的这条记录，取得 ID2 的值；</span><br><span class="line">到主键上查到主键值是 ID2 的行，判断 email 的值是正确的，将这行记录加入结果集；</span><br><span class="line">取 index1 索引树上刚刚查到的位置的下一条记录，发现已经不满足 email=&#x27;zhangssxyz@xxx.com’的条件了，循环结束。</span><br><span class="line">这个过程中，只需要回主键索引取一次数据，所以系统认为只扫描了一行。</span><br></pre></td></tr></table></figure>
<p><strong>如果使用的是 index2</strong>（即 email (6) 索引结构），执行顺序是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">从 index2 索引树找到满足索引值是’zhangs’的记录，找到的第一个是 ID1；</span><br><span class="line">到主键上查到主键值是 ID1 的行，判断出 email 的值不是’zhangssxyz@xxx.com’，这行记录丢弃；</span><br><span class="line">取 index2 上刚刚查到的位置的下一条记录，发现仍然是’zhangs’，取出 ID2，再到 ID 索引上取整行然后判断，这次值对了，将这行记录加入结果集；</span><br><span class="line">重复上一步，直到在 idxe2 上取到的值不是’zhangs’时，循环结束。</span><br><span class="line">在这个过程中，要回主键索引取 4 次数据，也就是扫描了 4 行。</span><br><span class="line">通过这个对比，你很容易就可以发现，使用前缀索引后，可能会导致查询语句读数据的次数变多。</span><br><span class="line">但是，对于这个查询语句来说，如果你定义的 index2 不是 email(6) 而是 email(7），也就是说取 email 字段的前 7 个字节来构建索引的话，即满足前缀’zhangss’的记录只有一个，也能够直接查到 ID2，只扫描一行就结束了。</span><br></pre></td></tr></table></figure>
<p>也就是说<strong>使用前缀索引，定义好长度，就可以做到既节省空间，又不用额外增加太多的查询成本。</strong></p>
<p>实际上，我们在建立索引时关注的是区分度，区分度越高越好。因为区分度越高，意味着重复的键值越少。因此，我们可以通过统计索引上有多少个不同的值来判断要使用多长的前缀。</p>
<p>首先，你可以使用下面这个语句，算出这个列上有多少个不同的值：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select count(distinct email) as L from SUser;</span><br></pre></td></tr></table></figure>
<p>然后，依次选取不同长度的前缀来看这个值，比如我们要看一下 4~7 个字节的前缀索引，可以用这个语句：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select </span><br><span class="line">  count(distinct left(email,4)）as L4,</span><br><span class="line">  count(distinct left(email,5)）as L5,</span><br><span class="line">  count(distinct left(email,6)）as L6,</span><br><span class="line">  count(distinct left(email,7)）as L7,</span><br><span class="line">from SUser;</span><br></pre></td></tr></table></figure>
<p>当然，使用前缀索引很可能会损失区分度，所以你需要预先设定一个可以接受的损失比例，比如 5%。然后，在返回的 L4~L7 中，找出不小于 L * 95% 的值，假设这里 L6、L7 都满足，你就可以选择前缀长度为 6。</p>
<p><strong>使用前缀索引就用不上覆盖索引对查询性能的优化了，这也是你在选择是否使用前缀索引时需要考虑的一个因素</strong>。</p>
<h3 id="索引下推"><a class="markdownIt-Anchor" href="#索引下推">#</a> 索引下推</h3>
<p>我们还是以市民表的联合索引（name, age）为例。</p>
<p>如果现在有一个需求：检索出表中 “名字第一个字是张，而且年龄是 10 岁的所有男孩”。那么，SQL 语句是这么写的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from tuser where name like &#x27;张%&#x27; and age=10 and ismale=1;</span><br></pre></td></tr></table></figure>
<p>这个语句在搜索索引树的时候，只能用 “张”，找到第一个满足条件的记录 ID3。然后判断其他条件是否满足。</p>
<p>在 MySQL 5.6 之前，只能从 ID3 开始一个个回表。到主键索引上找出数据行，再对比字段值。</p>
<p>MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</p>
<p><img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/b32aa8b1f75611e0759e52f5915539ac.jpg" alt="img"></p>
<p>区别是，InnoDB 在 (name,age) 索引内部就判断了 age 是否等于 10，对于不等于 10 的记录，直接判断并跳过。在我们的这个例子中，只需要对 ID4、ID5 这两条记录回表取数据判断，就只需要回表 2 次。</p>
<p><img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/76e385f3df5a694cc4238c7b65acfe1b.jpg" alt="img"></p>
<p>当创建 (a,b,c) 复合索引时，想要索引生效的话，只能使用 a 和 ab、ac 和 abc 三种组合</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;SELECT `a`,`b`,`c` FROM A WHERE `a`=&#x27;a1&#x27; ; //索引生效</span><br><span class="line">mysql&gt;SELECT `a`,`b`,`c` FROM A WHERE `b`=&#x27;b2&#x27; AND `c`=&#x27;c2&#x27;; //索引失效</span><br><span class="line">mysql&gt;SELECT `a`,`b`,`c` FROM A WHERE `a`=&#x27;a3&#x27; AND `c`=&#x27;c3&#x27;; //索引生效，实际上值使用了索引a</span><br></pre></td></tr></table></figure>
<p>三个字段联合索引测试</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create table `user` (</span><br><span class="line">`id` int(11) not null,</span><br><span class="line">`name` varchar(45) default null,</span><br><span class="line">`sex` varchar(45) default null,</span><br><span class="line">`age` varchar(45) default null,</span><br><span class="line">key `index_test` (`sex`,`age`,`name`) using btree</span><br><span class="line">)ENGINE=InndDB DEFAULT charset=utf8mb4;</span><br></pre></td></tr></table></figure>
<p>联合索引的顺序为：sex，age，name</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM user where age=&quot;4&quot;; #未使用索引</span><br><span class="line">SELECT * FROM user where name=&quot;2&quot;; #未使用索引</span><br><span class="line">SELECT * FROM user where sex=&quot;2&quot; and age=&quot;3&quot;; #使用索引</span><br><span class="line">SELECT * FROM user where sex=&quot;2&quot; and age=&quot;3&quot; and name=&quot;4&quot;; #使用索引</span><br><span class="line">SELECT * FROM user where age=&quot;3&quot; and name=&quot;4&quot;;  #未使用索引</span><br><span class="line">SELECT * FROM user where sex=&quot;2&quot; and name=&quot;4&quot;;  #使用索引</span><br></pre></td></tr></table></figure>
<p>两个字段测试</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create table `user` (</span><br><span class="line">`id` int(11) not null,</span><br><span class="line">`name` varchar(45) default null,</span><br><span class="line">`sex` varchar(45) default null,</span><br><span class="line">`age` varchar(45) default null,</span><br><span class="line">key `index_test` (`sex`,`age`) using btree</span><br><span class="line">)ENGINE=InndDB DEFAULT charset=utf8mb4;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">explain SELECT * FROM index_demo.user where age=&quot;4&quot;; #未使用索引</span><br><span class="line">explain SELECT * FROM index_demo.user where sex=&quot;2&quot; and age=&quot;3&quot;; #使用索引</span><br><span class="line">explain SELECT * FROM index_demo.user where age=&quot;3&quot; and sex=&quot;4&quot;;  #使用索引</span><br></pre></td></tr></table></figure>
<p>mysql 查询优化器会判断纠正这条 sql 语句该以什么样的顺序执行效率最高，最后才生成真正的执行计划。</p>
<p>因为对于三个索引的时候，只要是前两个存在，不论顺序是什么都是会使用索引的，</p>
<h3 id="覆盖索引"><a class="markdownIt-Anchor" href="#覆盖索引">#</a> 覆盖索引</h3>
<p>select * from T where k between 3 and 5</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; create table T (</span><br><span class="line">ID int primary key,</span><br><span class="line">k int NOT NULL DEFAULT 0, </span><br><span class="line">s varchar(16) NOT NULL DEFAULT &#x27;&#x27;,</span><br><span class="line">index k(k))</span><br><span class="line">engine=InnoDB;</span><br><span class="line"></span><br><span class="line">insert into T values(100,1, &#x27;aa&#x27;),(200,2,&#x27;bb&#x27;),(300,3,&#x27;cc&#x27;),(500,5,&#x27;ee&#x27;),(600,6,&#x27;ff&#x27;),(700,7,&#x27;gg&#x27;);</span><br></pre></td></tr></table></figure>
<p><img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/dcda101051f28502bd5c4402b292e38d.png" alt=""></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">现在，我们一起来看看这条 SQL 查询语句的执行流程：</span><br><span class="line">在 k 索引树上找到 k=3 的记录，取得 ID = 300；</span><br><span class="line">再到 ID 索引树查到 ID=300 对应的 R3；</span><br><span class="line">在 k 索引树取下一个值 k=5，取得 ID=500；</span><br><span class="line">再回到 ID 索引树查到 ID=500 对应的 R4；</span><br><span class="line">在 k 索引树取下一个值 k=6，不满足条件，循环结束。</span><br></pre></td></tr></table></figure>
<p><strong>在这个过程中，回到主键索引树搜索的过程，我们称为回表</strong></p>
<p>如果执行的语句是 select ID from T where k between 3 and 5，这时只需要查 ID 的值，而 ID 的值已经在 k 索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引 k 已经 “覆盖了” 我们的查询需求，我们称为覆盖索引。</p>
<p><strong>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</strong></p>
<h3 id="其他索引"><a class="markdownIt-Anchor" href="#其他索引">#</a> 其他索引</h3>
<p>我们国家的身份证号，一共 18 位，其中前 6 位是地址码，所以同一个县的人的身份证号前 6 位一般会是相同的。</p>
<p>假设你维护的数据库是一个市的公民信息系统，这时候如果对身份证号做长度为 6 的前缀索引的话，这个索引的区分度就非常低了。</p>
<p>按照我们前面说的方法，可能你需要创建长度为 12 以上的前缀索引，才能够满足区分度要求。</p>
<p>但是，索引选取的越长，占用的磁盘空间就越大，相同的数据页能放下的索引值就越少，搜索的效率也就会越低。</p>
<p>** 第一种方式是使用倒序存储。** 如果你存储身份证号的时候把它倒过来存，每次查询的时候，你可以这么写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select field_list from t where id_card = reverse(&#x27;input_id_card_string&#x27;);</span><br></pre></td></tr></table></figure>
<p>由于身份证号的最后 6 位没有地址码这样的重复逻辑，所以最后这 6 位很可能就提供了足够的区分度。当然了，实践中你不要忘记使用 count (distinct) 方法去做个验证。</p>
<p>** 第二种方式是使用 hash 字段。** 你可以在表上再创建一个整数字段，来保存身份证的校验码，同时在这个字段上创建索引。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; alter table t add id_card_crc int unsigned, add index(id_card_crc);</span><br></pre></td></tr></table></figure>
<p>然后每次插入新记录的时候，都同时用 crc32 () 这个函数得到校验码填到这个新字段。由于校验码可能存在冲突，也就是说两个不同的身份证号通过 crc32 () 函数得到的结果可能是相同的，所以你的查询语句 where 部分要判断 id_card 的值是否精确相同。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select field_list from t where id_card_crc=crc32(&#x27;input_id_card_string&#x27;) and id_card=&#x27;input_id_card_string&#x27;</span><br></pre></td></tr></table></figure>
<p>这样，索引的长度变成了 4 个字节，比原来小了很多。</p>
<p>它们的相同点是，都不支持范围查询。倒序存储的字段上创建的索引是按照倒序字符串的方式排序的，已经没有办法利用索引方式查出身份证号码在 [ID_X, ID_Y] 的所有市民了。同样地，hash 字段的方式也只能支持等值查询。</p>
<p>从查询效率上看，使用 hash 字段方式的查询性能相对更稳定一些。因为 crc32 算出来的值虽然有冲突的概率，但是概率非常小，可以认为每次查询的平均扫描行数接近 1。而倒序存储方式毕竟还是用的前缀索引的方式，也就是说还是会增加扫描行数。</p>
<h3 id="一颗高度为3的b树能存储多少数据"><a class="markdownIt-Anchor" href="#一颗高度为3的b树能存储多少数据">#</a> 一颗高度为 3 的 B + 树，能存储多少数据</h3>
<h4 id="innodb页结构"><a class="markdownIt-Anchor" href="#innodb页结构">#</a> InnoDB 页结构</h4>
<ul>
<li>在 InnoDB 中，索引默认使用的数据结构为 B + 树，而 <code>B+树里的每个节点都是一个页</code> ，默认的页大小为 <code>16KB</code> 。</li>
<li>非叶子节点存的是索引值以及页的偏移量，而叶子节点上存放的则是完整的每行记录</li>
</ul>
<p><img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221129161706609.png" alt="image-20221129161706609"></p>
<h4 id="非叶子节点能存多少条数据"><a class="markdownIt-Anchor" href="#非叶子节点能存多少条数据">#</a> 非叶子节点能存多少条数据</h4>
<blockquote>
<ul>
<li>
<p>页默认 16KB</p>
</li>
<li>
<p>File Header、Page Header 等一共占 102 个字节</p>
</li>
<li>
<p>Infimum + Supremum 分别占 13 个字节</p>
</li>
<li>
<p>记录头占 5 个字节</p>
</li>
<li>
<p>id 占为 int，占 4 个字节</p>
</li>
<li>
<p>页目录的偏移量占 4 个字节</p>
</li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   非叶子节点能存放的索引记录</span><br><span class="line">=  (页大小 - File Header - Page Header - ...) / ( 记录头 + 主键 + 页偏移量)</span><br><span class="line">= （16KB - 128B) / (5B + 4B + 4B) </span><br><span class="line">=  16256 / 13</span><br><span class="line">=  1250 条</span><br></pre></td></tr></table></figure>
<h4 id="叶子节点能存多少条数据"><a class="markdownIt-Anchor" href="#叶子节点能存多少条数据">#</a> 叶子节点能存多少条数据</h4>
<blockquote>
<ul>
<li>变长列表占 1 个字节</li>
<li>null 标志位忽略</li>
<li>记录头占 5 个字节</li>
<li>id 占为 int，占 4 个字节</li>
<li>name 为 VARCHAR，编码为 UTF8，为了好算，所有行记录我都只用两个中文，那就是 2 * 3B = 6 个字节</li>
<li>事务 ID 列占 6 个字节</li>
<li>回滚指针列占 7 个字节</li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   叶子节点能存放的数据记录</span><br><span class="line">=  (页大小 - File Header - Page Header - ...) / ( 主键 + 字段 + 下一条记录的偏移量)</span><br><span class="line">= （16KB - 128B) / (1B + 5B + 4B + 6B + 6B + 7B) </span><br><span class="line">=  16256 / 29</span><br><span class="line">=  560 条</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>根节点能放 1250 条索引记录</li>
<li>第二层能放 1250 * 1250 = 1,562,500 条索引记录</li>
<li>叶子节点 1250 * 1250 * 560 = 875,000,000 条数据记录，八亿多条数据</li>
</ul>
</blockquote>
<h3 id="n叉树的n可以修改吗"><a class="markdownIt-Anchor" href="#n叉树的n可以修改吗">#</a> N 叉树的 N 可以修改吗</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   非叶子节点能存放的索引记录</span><br><span class="line">=  (页大小 - File Header - Page Header - ...) / ( 记录头 + 主键 + 页偏移量)</span><br><span class="line">= （16KB - 128B) / (5B + 4B + 4B) </span><br><span class="line">=  16256 / 13</span><br><span class="line">=  1250 条</span><br></pre></td></tr></table></figure>
<p>主键大小使我们可控的，如果是 bigint = 956</p>
<p>我们也可以控制 Innodb_page_size，默认 16k，我们可以通过配置改为 8k</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDgxMTg1MS9hcnRpY2xlL2RldGFpbHMvMTI1Nzg2MDky">https://blog.csdn.net/weixin_44811851/article/details/125786092</span></p>
<h2 id="视图"><a class="markdownIt-Anchor" href="#视图">#</a> 视图</h2>
<p>视图中的字段与对应的数据均来自已经存在的表，对于视图来说，这些已经存在的表就被称为” 基表”, 基表可以是一张表，也可以是多张表， 视图的本质可以理解为一条查询语句，视图中显示的结果，就是这条查询语句查询出的结果。</p>
<p>应该是 mysql 对于子查询的优化不是很好，而使用视图本身往往就意味着使用子查询，所以，如果我们必须使用视图时，最好将视图中的 sql 语句尽量优化，或者说，数据量大的时候尽量避免使用视图。</p>
<p>创建视图的原始表为基表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create view view1 as select * from stu where age &gt; 100</span><br><span class="line">select * from view1;</span><br></pre></td></tr></table></figure>
<p>删除视图</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">drop view  view1</span><br><span class="line">drop view if exists testvi;</span><br></pre></td></tr></table></figure>
<p>查看视图</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from information_schema.views where table_schema=stu;</span><br></pre></td></tr></table></figure>
<p>修改视图</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter view testvi as select  name,age from students;</span><br></pre></td></tr></table></figure>
<h2 id="ddl"><a class="markdownIt-Anchor" href="#ddl">#</a> DDL</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into  stu (name,age) values (&#x27;haha&#x27;,5),(&#x27;shabi&#x27;,6)</span><br></pre></td></tr></table></figure>
<p>insert 字段可以调换顺序，前后一起调换即可</p>
<p>tinyint 最大范围为 127</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into values (&#x27;haha&#x27;,44)</span><br></pre></td></tr></table></figure>
<p>不写字段名必须按照字段顺序和字段数插入，包括自增主键的值也需要手写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into stu set 1=1;</span><br></pre></td></tr></table></figure>
<p>int (8) 代表显示 8 位数字，int 永远占四个字节</p>
<p>concat &amp;&amp; group_concat()</p>
<p>concat 连接时数据不能超过一行</p>
<p>group_concat 将数据拼成一行</p>
<p>substr &amp;&amp; substring</p>
<p>从第一位开始截取两位，mysql 从 1 开始下标</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">select substring(&#x27;aaaaa&#x27;,1,2)   // aa</span><br><span class="line">select substr(&#x27;aaaaaa&#x27;,1,1)</span><br></pre></td></tr></table></figure>
<p>删除表中所有数据</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">delete from stu where id in(1,2,3);</span><br><span class="line">truncate table stu;</span><br><span class="line">delete from tb1 where name rlike &#x27;^t.*&#x27;;</span><br><span class="line">[^abc] 匹配 或关系</span><br></pre></td></tr></table></figure>
<p>更新</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update yanchuang set name=&#x27;aaa&#x27;,age=333 where id = 1</span><br></pre></td></tr></table></figure>
<p>修改表结构</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table aaa add bbb int(10) not null after id;</span><br><span class="line">alter table ccc add bbb int(10) not null first;</span><br></pre></td></tr></table></figure>
<p>修改字段类型</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table aaa modify no int not null</span><br></pre></td></tr></table></figure>
<p>修改字段类型和内容</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table chenke change stu students int not null</span><br></pre></td></tr></table></figure>
<h2 id="acid"><a class="markdownIt-Anchor" href="#acid">#</a> ACID</h2>
<p>原子性</p>
<p>一致性</p>
<p>持久性</p>
<p>隔离性</p>
<h2 id="隔离级别"><a class="markdownIt-Anchor" href="#隔离级别">#</a> 隔离级别</h2>
<p READ-UNCOMMITTED="" |="" READ-COMMITTED="" |="" REPEATABLE-READ="" |="" SERIALIZABLE="">transaction-isolation =</p>
<p>transaction-isolation 默认为可重复读 REPEATABLE-READ</p>
<p>5.7 以前为 tx_isolation，之后变为 transcation_isolation</p>
<p>开启事务</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">begin /  start transaction</span><br></pre></td></tr></table></figure>
<p>READ-UNCOMMITTED</p>
<p>该隔离级别下允许一个事务读取到其它事务未提交的写操作</p>
<p>数据不一致 - 脏读 - 读未提交造成的问题 (read-uncommitted)，即不提交也会使数据改变</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">begin 										begin</span><br><span class="line">select a  //100								select a  //100</span><br><span class="line">											update a = 200</span><br><span class="line">select a  //200</span><br></pre></td></tr></table></figure>
<p><img data-src="https://cdn.nlark.com/yuque/0/2022/png/2759285/1659959307923-5e69136b-42dd-4503-a4c6-42c1780ad717.png" alt="img"></p>
<p>读已提交 (read-committed) 未提交时不会收到脏数据污染，但提交后还是会受污染，造成幻读（不可重复读）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">begin											begin</span><br><span class="line">select a   //200								select a    //200</span><br><span class="line">												update a = 300 </span><br><span class="line">												select a    //300</span><br><span class="line">select a   //200</span><br><span class="line">												commit</span><br><span class="line">select a   //300</span><br></pre></td></tr></table></figure>
<p>repeatable-read 可重复读，修改后无论是否提交都不会改变查询结果，当两端都修改了数据后，会造成最先修改的一方的更新丢失</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">begin											begin</span><br><span class="line">select a   //300								select a    //300</span><br><span class="line">												update a = 400 		</span><br><span class="line">select a   //300								select a    //400 </span><br><span class="line">												commit</span><br><span class="line">select a   //300</span><br><span class="line">commit</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">begin											begin</span><br><span class="line">select a   //400								select a    //400</span><br><span class="line">												update a = 500</span><br><span class="line">select a   //400								select a    //500</span><br><span class="line">												commit</span><br><span class="line">update a = 600</span><br><span class="line">commit											</span><br><span class="line">select a	//600								select a    //600</span><br></pre></td></tr></table></figure>
<p>serialize</p>
<p>该隔离级别下很好的解决了 lost udpate 的问题</p>
<p>读时加锁，别的进程不能修改，效率慢</p>
<p>MySQL 提供了四种不同的隔离级别，分别是：read-uncommit、read-commit、repeated-read 和 serializable，后三种隔离级别分别结果了脏读、幻读、lost update 的问题。虽然 serializable 解决了全部的问题，但是实际运行时它的性能是最差的。所以日常生产环境中我们一般使用 read-commit、repeated-read 两种隔离级别，既能解决一些严重的不一致问题又能保持 MySQL 比较高的性能。</p>
<p>解决更新丢失</p>
<p>对于使用 InnoDB 存储引擎的表，其<span class="exturl" data-url="aHR0cHM6Ly9zby5jc2RuLm5ldC9zby9zZWFyY2g/cT0lRTglODElOUElRTclQjAlODclRTclQjQlQTIlRTUlQkMlOTUmYW1wO3NwbT0xMDAxLjIxMDEuMzAwMS43MDIw">聚簇索引</span>记录中包含了两个重要的隐藏列：</p>
<p>trx_id：每当事务对聚簇索引中的记录进行修改时，都会把当前事务的事务 id 记录到 trx_id 中。</p>
<p>roll_pointer：每当事务对聚簇索引中的记录进行修改时，都会把该记录的旧版本记录到 undo 日志中，通过 roll_pointer 这个指针可以用来获取该记录旧版本的信息。</p>
<p>如果在一个事务中多次对记录进行修改，则每次修改都会生成 undo 日志，并且这些 undo 日志通过 roll_pointer 指针串联成一个版本链，版本链的头结点是该记录最新的值，尾结点是事务开始时的初始值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BEGIN;</span><br><span class="line">UPDATE book SET stock = 200 WHERE id = 1;</span><br><span class="line">UPDATE book SET stock = 300 WHERE id = 1;</span><br></pre></td></tr></table></figure>
<p><img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/20200620204317155.png" alt="img"></p>
<p>undo log 记录回滚指针，可以在回滚的时候恢复原始数据，</p>
<p><strong>事务隔离界别通过快照实现，但仅针对读已提交和可重复读</strong></p>
<p><strong>对于使用 Read Uncommitted 隔离级别的事务来说，只需要读取版本链上最新版本的记录即可；</strong></p>
<p><strong>对于使用 Serializable 隔离级别的事务来说，InnoDB 使用加锁的方式来访问记录；</strong></p>
<p>事务 id 是递增分配的。ReadView 的机制就是在生成 ReadView 时确定了以下几种信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">m_ids：表示在生成ReadView时当前系统中活跃的读写事务的事务id列表。</span><br><span class="line"></span><br><span class="line">min_trx_id：表示在生成ReadView时当前系统中活跃的读写事务中最小的事务id，也就是m_ids中的最小值。</span><br><span class="line"></span><br><span class="line">max_trx_id：表示生成ReadView时系统中将要分配给下一个事务的id值。</span><br><span class="line"></span><br><span class="line">creator_trx_id：表示生成该ReadView的事务的事务id。</span><br></pre></td></tr></table></figure>
<p>这样事务 id 就可以分成 3 个区间：</p>
<p><strong>区间 (0, min_trx_id)：如果被访问版本的 trx_id 小于 m_ids 中的最小值 up_limit_id，说明生成该版本的事务在 ReadView 生成前就已经提交了，所以该版本可以被当前事务访问</strong></p>
<p><strong>区间 [min_trx_id, max_trx_id): 如果被访问版本的 trx_id 属性值在 m_ids 列表中最大值和最小值之间（包含），那就需要判断一下 trx_id 的值是不是在 m_ids 列表中。如果在，说明创建 ReadView 时生成该版本所属事务还是活跃的，因此该版本不可以被访问，需要查找 Undo Log 链得到上一个版本，然后根据该版本的 DB_TRX_ID 再从头计算一次可见性；如果不在，说明创建 ReadView 时生成该版本的事务已经被提交，该版本可以被访问。</strong></p>
<p><strong>区间 [max_trx_id, +∞)：如果被访问版本的 trx_id 大于 m_ids 列表中的最大值 low_limit_id，说明生成该版本的事务在生成 ReadView 后才生成，所以该版本不可以被当前事务访问。需要根据 Undo Log 链找到前一个版本，然后根据该版本的 DB_TRX_ID 重新判断可见性</strong></p>
<p>之前说到 ReadView 的机制只在 Read Committed 和 Repeatable Read 隔离级别下生效，所以只有这两种隔离级别才有 MVCC。在 Read Committed 隔离级别下，每次读取数据时都会生成 ReadView；而在 Repeatable Read 隔离级别下只会在事务首次读取数据时生成 ReadView，之后的读操作都会沿用此 ReadView。</p>
<p>Read Committed 下 MVCC 工作原理</p>
<p><strong>在提交前 [min_trx_id, max_trx_id) 在活跃别表中，读的是快照，提交后 (0, min_trx_id) 事务不再活跃，可以访问最新记录</strong></p>
<p>因为每次执行查询语句都会生成新的 ReadView，所以在 Read Committed 隔离级别下的事务读取到的是查询时刻表中已提交事务修改之后的数据。</p>
<p>Repeatable read 下 MVCC 工作原理</p>
<p><strong>当第二次执行 SELECT 语句时不会生成新的 ReadView，依然会使用第一次查询时生成 ReadView。因此我们查询到的版本记录跟第一次查询到的结果是一样的：</strong></p>
<p>只会查询出最开始的视图快照</p>
<p>普通读 / 快照读</p>
<p>普通读（也称快照读，英文名：Consistent Read），就是单纯的 SELECT 语句</p>
<p>快照读用于只能获得到快照的数据，不能获得最新数据  通过 undo log + mvcc 实现</p>
<p>事务会先使用 “排他锁” 锁定该行，将该行当前的值复制到 undo log 中，然后再真正地修改当前行的值，最后填写事务的 DB_TRX_ID ，使用回滚指针 DB_ROLL_PTR 指向 undo log 中修改前的行。</p>
<p>这里解释一下 DB_TRX_ID 和 DB_ROLL_PTR 所代表的含义：</p>
<ul>
<li><strong>DB_TRX_ID</strong> :  6 字节 DB_TRX_ID 字段，表示最后更新的事务 id (update , delete , insert) 。此外，删除在内部被视为更新，其中行中的特殊位被设置为将其标记为已软删除。</li>
<li><strong>DB_ROLL_PTR</strong> :  7 字节回滚指针，指向前一个版本的 undo log 记录，组成 undo 链表。如果更新了行，则撤消日志记录包含在更新行之前重建行内容所需的信息。</li>
</ul>
<p>解决快照读：永远读取最新的数据 - 当前读   ，当前读通过加锁</p>
<p>修改数据时一定会加锁，select 通过 for update 加锁 ，即悲观锁</p>
<p>select * from money where id=1 for update</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">begin															begin</span><br><span class="line">select a for update   //800										select a for update //被加锁，卡主</span><br><span class="line">update a = 900													</span><br><span class="line">																update a = 1000  // 被加锁，只要第一个进程不commit，这啥都干不了</span><br><span class="line">commit			</span><br><span class="line">																update 锁被释放，update执行</span><br></pre></td></tr></table></figure>
<p>线程 1 加锁时线程 2 只能不加锁的 select</p>
<p>当前读</p>
<p>当前读，读取的是最新版本，并且需要先获取对应记录的锁</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select ... lock in share mode 、</span><br><span class="line">select ... for update、</span><br><span class="line">update 、delete 、insert </span><br></pre></td></tr></table></figure>
<p>当前读是通过 next-key 锁 (行记录锁 + 间隙锁) 来是实现的。</p>
<blockquote>
<p>行锁（Record Lock）：锁直接加在索引记录上面。</p>
<p>间隙锁（Gap Lock）：是 Innodb 为了解决幻读问题时引入的锁机制，所以只有在 Read Repeatable 、Serializable 隔离级别才有。</p>
<p>Next-Key Lock ：Record Lock + Gap Lock，锁定一个范围并且锁定记录本身 。</p>
</blockquote>
<p><img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/0c9e065743a31aef701442efd48f4dd2.png" alt="img"></p>
<p>测试可知 delete from T where age = 7; 语句在 age 上的加锁区间为 (4,10) , 图解如下</p>
<p><img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/a3e94774374bfffd6390ebf7e3b4804c.png" alt="img"></p>
<p>乐观锁</p>
<p>通过增加额外字段实现</p>
<p><img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221130172132896.png" alt="image-20221130172132896"></p>
<h2 id="redo-log"><a class="markdownIt-Anchor" href="#redo-log">#</a> redo log</h2>
<p>事务的原子性、一致性和持久性由事务的 redo 日志和 undo 日志来保证。</p>
<p>配置了 autocommit 后会自动提交，只有显示进入 begin 或者关闭该选项后手动提交</p>
<p><img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/4c5ffaa6a9d64486b793c17e53494883.png" alt=""></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">第1步：先将原始数据从磁盘中读入内存中来，修改数据的内存拷贝</span><br><span class="line"></span><br><span class="line">第2步：生成一条重做日志并写入redo log buffer，记录的是数据被修改后的值</span><br><span class="line"></span><br><span class="line">第3步：当事务commit时，将redo log buffer中的内容刷新到 redo log file，对 redo log file采用追加 写的方式</span><br><span class="line"></span><br><span class="line">第4步：定期将内存中修改的数据刷新到磁盘中</span><br></pre></td></tr></table></figure>
<p><strong>注意，redo log buffer 刷盘到 redo log file 的过程并不是真正的刷到磁盘中去，只是刷入到文件系统缓存（page cache）中去（这是现代操作系统为了提高文件写入效率做的一个优化</strong>）</p>
<p><img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221201143107759.png" alt="image-20221201143107759"></p>
<p>真正的写入会交给系统自己来决定（比如 page cache 足够大了）。那么对于 InnoDB 来说就存在一个问题，如果交给系统来同步，同样如果系统宕机，那么数据也丢失了</p>
<p>InnoDB 给出 innodb_flush_log_at_trx_commit 参数，该参数控制 commit 提交事务时，如何将 redo log buffer 中的日志刷新到 redo log file 中。它支持三种策略：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">设置为0 ：表示每次事务提交时不进行刷盘操作。（系统默认master thread每隔1s进行一次重做日志的同步）</span><br><span class="line"></span><br><span class="line">设置为1 ：表示每次事务提交时都将进行同步，刷盘操作（ 默认值 ）</span><br><span class="line"></span><br><span class="line">设置为2 ：表示每次事务提交时都只把 redo log buffer 内容写入 page cache，不进行同步。由os自己决定什么时候同步到磁盘文件。</span><br></pre></td></tr></table></figure>
<p><img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/1be6cdfbf3f54bd8ac637ac73d45caed.png" alt=""></p>
<p>=0 系统崩溃会丢失一秒数据</p>
<p>=2 在极端环境下会丢失一秒数据，只写入内存</p>
<p>&lt;=5.5MyISAM 不支持 redolog</p>
<p><img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/57decf7a3f214140bb3829fac1e849ac.png" alt=""></p>
<p><img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/dd905e10eb73483bbfe327c4e70a5ecd.png" alt=""></p>
<p><img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/8f6087b82bc64e788d2f00ae6438291f.png" alt=""></p>
<p>redo log crash safe writepos checkpoint</p>
<p>binlog 和 redolog 差异</p>
<p>在记录 1 刷盘后，记录 2 未刷盘时，数据库 crash。重启后，只通过 binlog 数据库无法判断这两条记录哪条已经写入磁盘哪条没有写入磁盘，不管是两条都恢复至内存，还是都不恢复，对 ID=2 这行数据来说，都不对。</p>
<p>通过插入大量数据可以查看三种刷盘策略的不同</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(root@localhost) [hellodb]&gt; call sp_testlog;</span><br><span class="line">Query OK, 1 row affected (45.36 sec) #用时45秒</span><br><span class="line"></span><br><span class="line">(root@localhost) [hellodb]&gt; begin;call sp_testlog;commit;</span><br><span class="line">#我们看到将存储过程call sp_testlog作为一个事务来说，其内部的十万条insert合起来一个事务的所有操作。</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">Query OK, 1 row affected (4.01 sec)</span><br><span class="line">Query OK, 0 rows affected (0.49 sec)</span><br></pre></td></tr></table></figure>
<p>备份</p>
<p>差异备份 - 和完全备份有多少区别就备份多少</p>
<p>全量备份</p>
<p>增量备份</p>
<p>mysqldump -uroot -p123  test &gt; /tmp/bak.sql</p>
<p>mysqldump -uroot -p123 --databases test test1 &gt; /tmp/bak.sql</p>
<p>xtrabackup</p>
<h2 id="binlog"><a class="markdownIt-Anchor" href="#binlog">#</a> binlog</h2>
<p>Binlog 用于对还没没备份的数据进行恢复。它记录了所有的 DDL (create alter drop) 和 DML 语句（除了数据查询语句 select），以事件形式记录，还包含语句所执行的消耗的时间，MySQL 的二进制日志是事务安全型的。</p>
<p>mysqlbinlog 常见的选项有以下几个：<br>
–start-datetime：从二进制日志中读取指定等于时间戳或者晚于本地服务器的时间<br>
–stop-datetime：从二进制日志中读取指定小于时间戳或者等于本地服务器的时间 取值和上述一样<br>
–start-position：从二进制日志中读取指定 position 事件位置作为开始。<br>
–stop-position：从二进制日志中读取指定 position 事件位置作为事件截至</p>
<p>binlog 日志有两个最重要的使用场景<br>
 1）MySQL 主从复制：MySQL Replication 在 Master 端开启 binlog，Master 把它的二进制日志传递给 slaves 来达到<br>
 master-slave 数据一致的目的。<br>
2）自然就是数据恢复了，通过使用 mysqlbinlog 工具来使恢复数据。</p>
<p>binlog 日志包括两类文件<br>
 1）二进制日志索引文件（文件名后缀为.index）用于记录所有的二进制文件<br>
 2）二进制日志文件（文件名后缀为.00000*）记录数据库所有的 DDL 和 DML (除了数据查询语句 select) 语句事件。</p>
<p>开启：在配置文件中加入以下内容</p>
<p>[root@vm-002 ~]# vim /etc/my.cnf</p>
<p>log_bin = mysql_bin   // 给 binlog 日志取名，并开启 binlog</p>
<p>每次服务器（数据库）重启，服务器会调用 flush logs;，新创建一个 binlog 日志！</p>
<p>flush logs; flush 刷新 log 日志，自此刻开始产生一个新编号的 binlog 日志文件</p>
<p>使用 mysqlbinlog 自带查看命令法：</p>
<p>–&gt;binlog 是二进制文件，普通文件查看器 cat、more、vim 等都无法打开，必须使用自带的 mysqlbinlog 命令查看</p>
<p>–&gt;binlog 日志与数据库文件在同目录中</p>
<p>–&gt; 在 MySQL5.5 以下版本使用 mysqlbinlog 命令时如果报错，就加上 “–no-defaults” 选项</p>
<p>binlog_format 修改该变量</p>
<p>二进制日志有 3 种记录方式，三种方式如下：</p>
<p>statement 模式：记录对数据库做出修改的语句，比如，update A set test=’test’, 如果使用 statement 模式，那么这条 update 语句将会被记录到二进制日志中，使用 statement 模式时，优点是 binlog 日志量少，IO 压力小，性能较高，缺点是为了能够尽量的完全一致的还原操作，除了记录语句本身以外，可能还需要记录一些相关的信息，而且，在使用一些特定的函数时，并不能保证恢复操作与记录时完全一致。</p>
<p>row 模式：记录对数据库做出修改的语句所影响到的数据行以及这些行的修改，比如，update A set test=’test’，如果使用 row 模式，那么这条 update 语句所影响到的行所对应的修改，将会记录到 binlog 中，比如，A 表中有 1000 条数据，那么当执行这条 update 语句以后，由于 1000 条数据都会被修改，所以会有 1000 行数据被记录到二进制日志中，以及它们是怎样被修改的，使用 row 模式时，优点是能够完全的还原或者复制日志被记录时的操作，缺点是记录日志量较大，IO 压力大，性能消耗较大。</p>
<p>mixed 模式：混合使用上述两种模式，一般的语句使用 statment 方式进行保存，如果遇到一些特殊的函数，则使用 row 模式进行记录，这种记录方式被称之为 mixed，看上去这种方式似乎比较美好，但是在生产环境中，为了保险起见，一般会使用 row 模式。</p>
<p>DDL - create alter  drop</p>
<p>DML - update，insert，delete</p>
<p>show master log    // 查看最新生成 binlog</p>
<p>show binlog events in ‘mysqlbin.0000001’   // 以位置方式查看 binlog</p>
<p>mysqlbinlog mysqlbin.0000001  // 以时间方式查看 binlog</p>
<p>​</p>
<p>mysqlbinlog mysqllog000003 &gt; 00003.sql</p>
<p>vim 00003.sql    查看 binlog 信息</p>
<p>mysql -uroot -p123456 &lt; 00003.sql   恢复 binlog</p>
<p>flush log   刷新创建新 binlog</p>
<p>基于位置信息恢复</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqlbinlog --start-position=660 --stop-position=773 --database=haha mysqlbin.00003 | mysql -uroot -p123456 -v</span><br></pre></td></tr></table></figure>
<p>基于时间信息恢复</p>
<p>[root@vm-002 backup]# cp /var/lib/mysql/mysql-bin.000003 /opt/backup<br>
[root@vm-002 backup]# mysqlbinlog /opt/backup/mysql-bin.000003 &gt; /opt/backup/000003.sql<br>
 [root@vm-002 backup]# vim /opt/backup/000003.sql #删除里面的 drop 语句<br>
 [root@vm-002 backup]# mysql -uroot -p -v &lt; /opt/backup/000003.sql</p>

  </div>

   <footer>

    <div class="meta">
  <span class="item">
    <span class="icon">
      <i class="ic i-calendar-check"></i>
    </span>
    <span class="text">Edited on</span>
    <time title="Modified: 2022-12-14 10:18:18" itemprop="dateModified" datetime="2022-12-14T10:18:18+08:00">2022-12-14</time>
  </span>
</div>

      
<div class="reward">
  <button><i class="ic i-heartbeat"></i> Donate</button>
  <p>Give me a cup of [coffee]~(￣▽￣)~*</p>
  <div id="qr">
      
      <div>
        <img data-src="/images/wechatpay.png" alt="John Doe WeChat Pay">
        <p>WeChat Pay</p>
      </div>
      
      <div>
        <img data-src="/images/alipay.png" alt="John Doe Alipay">
        <p>Alipay</p>
      </div>
      
      <div>
        <img data-src="/images/paypal.png" alt="John Doe PayPal">
        <p>PayPal</p>
      </div>
  </div>
</div>

      

<div id="copyright">
<ul>
  <li class="author">
    <strong>Post author:  </strong>John Doe <i class="ic i-at"><em>@</em></i>Hexo
  </li>
  <li class="link">
    <strong>Post link: </strong>
    <a href="http://example.com/2022/12/28/mysql/" title="Mysql">http://example.com/2022/12/28/mysql/</a>
  </li>
  <li class="license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> unless stating additionally.
  </li>
</ul>
</div>

  </footer>

</article>

  </div>
  

<div class="post-nav">
    <div class="item left">
      

  <a href="/2022/12/27/SSTI/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;img.timelessq.com&#x2F;images&#x2F;2022&#x2F;07&#x2F;26&#x2F;cc1a734b8a0734243d5071644d60f360.jpg" title="SSTI">
  <span class="type">Previous Post</span>
  <span class="category"><i class="ic i-flag"></i> web安全</span>
  <h3>SSTI</h3>
  </a>

    </div>
    <div class="item right">
      

  <a href="/2022/12/31/webshell/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;img.timelessq.com&#x2F;images&#x2F;2022&#x2F;07&#x2F;26&#x2F;46d0371c19c0586fb0629e97bac23133.jpg" title="webshell">
  <span class="type">Next Post</span>
  <span class="category"><i class="ic i-flag"></i> web安全</span>
  <h3>webshell</h3>
  </a>

    </div>
</div>

  
  <div class="wrap" id="comments"></div>


        </div>
        <div id="sidebar">
          

<div class="inner">

  <div class="panels">
    <div class="inner">
      <div class="contents panel pjax" data-title="Contents">
          <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#mysql"><span class="toc-number">1.</span> <span class="toc-text"> MySQL</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95"><span class="toc-number">1.1.</span> <span class="toc-text"> 索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%B8%B8%E8%A7%81%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.1.1.</span> <span class="toc-text"> 索引常见模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%B8%8C%E8%A1%A8"><span class="toc-number">1.1.1.1.</span> <span class="toc-text"> 哈希表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="toc-number">1.1.1.2.</span> <span class="toc-text"> 有序数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-number">1.1.1.3.</span> <span class="toc-text"> 二叉搜索树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b-tree"><span class="toc-number">1.1.1.4.</span> <span class="toc-text"> B-tree</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#btree"><span class="toc-number">1.1.1.5.</span> <span class="toc-text"> B+tree</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#innodb%E7%B4%A2%E5%BC%95%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.1.2.</span> <span class="toc-text"> InnoDB 索引模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E7%B4%A2%E5%BC%95"><span class="toc-number">1.1.3.</span> <span class="toc-text"> 最左前缀索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8"><span class="toc-number">1.1.4.</span> <span class="toc-text"> 索引下推</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A6%86%E7%9B%96%E7%B4%A2%E5%BC%95"><span class="toc-number">1.1.5.</span> <span class="toc-text"> 覆盖索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E7%B4%A2%E5%BC%95"><span class="toc-number">1.1.6.</span> <span class="toc-text"> 其他索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E9%A2%97%E9%AB%98%E5%BA%A6%E4%B8%BA3%E7%9A%84b%E6%A0%91%E8%83%BD%E5%AD%98%E5%82%A8%E5%A4%9A%E5%B0%91%E6%95%B0%E6%8D%AE"><span class="toc-number">1.1.7.</span> <span class="toc-text"> 一颗高度为 3 的 B + 树，能存储多少数据</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#innodb%E9%A1%B5%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.7.1.</span> <span class="toc-text"> InnoDB 页结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E8%83%BD%E5%AD%98%E5%A4%9A%E5%B0%91%E6%9D%A1%E6%95%B0%E6%8D%AE"><span class="toc-number">1.1.7.2.</span> <span class="toc-text"> 非叶子节点能存多少条数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%B6%E5%AD%90%E8%8A%82%E7%82%B9%E8%83%BD%E5%AD%98%E5%A4%9A%E5%B0%91%E6%9D%A1%E6%95%B0%E6%8D%AE"><span class="toc-number">1.1.7.3.</span> <span class="toc-text"> 叶子节点能存多少条数据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#n%E5%8F%89%E6%A0%91%E7%9A%84n%E5%8F%AF%E4%BB%A5%E4%BF%AE%E6%94%B9%E5%90%97"><span class="toc-number">1.1.8.</span> <span class="toc-text"> N 叉树的 N 可以修改吗</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%86%E5%9B%BE"><span class="toc-number">1.2.</span> <span class="toc-text"> 视图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ddl"><span class="toc-number">1.3.</span> <span class="toc-text"> DDL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#acid"><span class="toc-number">1.4.</span> <span class="toc-text"> ACID</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">1.5.</span> <span class="toc-text"> 隔离级别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redo-log"><span class="toc-number">1.6.</span> <span class="toc-text"> redo log</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#binlog"><span class="toc-number">1.7.</span> <span class="toc-text"> binlog</span></a></li></ol></li></ol>
      </div>
      <div class="related panel pjax" data-title="Related">
      </div>
      <div class="overview panel" data-title="Overview">
        <div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="image" itemprop="image" alt="John Doe"
      data-src="/images/avatar.jpg">
  <p class="name" itemprop="name">John Doe</p>
  <div class="description" itemprop="description"></div>
</div>

<nav class="state">
    <div class="item posts">
      <a href="/archives/">
        <span class="count">43</span>
        <span class="name">posts</span>
      </a>
    </div>
    <div class="item categories">
      <a href="/categories/">
        <span class="count">6</span>
        <span class="name">categories</span>
      </a>
    </div>
    <div class="item tags">
      <a href="/tags/">
        <span class="count">6</span>
        <span class="name">tags</span>
      </a>
    </div>
</nav>

<div class="social">
</div>

<ul class="menu">
  
    
  <li class="item">
    <a href="/" rel="section"><i class="ic i-home"></i>Home</a>
  </li>


</ul>

      </div>
    </div>
  </div>

  <ul id="quick">
    <li class="prev pjax">
        <a href="/2022/12/27/SSTI/" rel="prev" title="Previous Post"><i class="ic i-chevron-left"></i></a>
    </li>
    <li class="up"><i class="ic i-arrow-up"></i></li>
    <li class="down"><i class="ic i-arrow-down"></i></li>
    <li class="next pjax">
        <a href="/2022/12/31/webshell/" rel="next" title="Next Post"><i class="ic i-chevron-right"></i></a>
    </li>
    <li class="percent"></li>
  </ul>
</div>


        </div>
        <div class="dimmer"></div>
      </div>
    </main>
    <footer id="footer">
      <div class="inner">
        <div class="widgets">
          
<div class="rpost pjax">
  <h2>Random Posts</h2>
  <ul>
      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/2023/07/15/%E4%B8%AD%E9%97%B4%E4%BB%B6%E6%BC%8F%E6%B4%9E/" title="中间件漏洞">中间件漏洞</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E8%BF%90%E7%BB%B4/" title="In 运维">运维</a>
</div>

    <span><a href="/2023/04/03/iptables2/" title="iptables">iptables</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E9%80%86%E5%90%91/" title="In 逆向">逆向</a>
</div>

    <span><a href="/2023/08/22/%E5%8E%BB%E5%BC%B9%E7%AA%97%E7%BB%BF%E5%8C%96/" title="破解相关">破解相关</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/web%E5%AE%89%E5%85%A8/" title="In web安全">web安全</a>
</div>

    <span><a href="/2022/08/16/Unserialize/" title="unserialize">unserialize</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/web%E5%AE%89%E5%85%A8/" title="In web安全">web安全</a>
</div>

    <span><a href="/2022/05/27/CSRF/" title="CSRF">CSRF</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E7%BD%91%E7%BB%9C/" title="In 网络">网络</a>
</div>

    <span><a href="/2023/01/17/Segment%20Routing/" title="Segment Routing">Segment Routing</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E8%BF%90%E7%BB%B4/" title="In 运维">运维</a>
</div>

    <span><a href="/2022/11/27/CDN/" title="CDN&amp;DNS">CDN&DNS</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/2023/03/27/http/" title="http">http</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E7%A7%8B%E6%8B%9B/" title="In 秋招">秋招</a>
</div>

    <span><a href="/2022/10/28/%E7%A7%8B%E6%8B%9B%E9%9D%A2%E8%AF%95%E9%A2%98/" title="秋招面试题">秋招面试题</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E7%BD%91%E7%BB%9C/" title="In 网络">网络</a>
</div>

    <span><a href="/2023/01/20/VXLAN/" title="VXLAN">VXLAN</a></span>
  </li>

  </ul>
</div>
<div>
  <h2>Recent Comments</h2>
  <ul class="leancloud-recent-comment"></ul>
</div>

        </div>
        <div class="status">
  <div class="copyright">
    
    &copy; 2010 – 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="ic i-sakura rotate"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">John Doe @ Yume Shoka</span>
  </div>
  <div class="powered-by">
    Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span>
  </div>
</div>

      </div>
    </footer>
  </div>
<script data-config type="text/javascript">
  var LOCAL = {
    path: '2022/12/28/mysql/',
    favicon: {
      show: "（●´3｀●）Goooood",
      hide: "(´Д｀)Booooom"
    },
    search : {
      placeholder: "Search for Posts",
      empty: "We didn't find any results for the search: ${query}",
      stats: "${hits} results found in ${time} ms"
    },
    valine: true,fancybox: true,
    copyright: 'Copied to clipboard successfully! <br> All articles in this blog are licensed under <i class="ic i-creative-commons"></i>BY-NC-SA.',
    ignores : [
      function(uri) {
        return uri.includes('#');
      },
      function(uri) {
        return new RegExp(LOCAL.path+"$").test(uri);
      }
    ]
  };
</script>

<script src="https://cdn.polyfill.io/v2/polyfill.js"></script>

<script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script>

<script src="/js/app.js?v=0.2.5"></script>




</body>
</html>
