{
    "version": "https://jsonfeed.org/version/1",
    "title": "Hexo • All posts by \"秋招\" category",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2022/10/28/%E7%A7%8B%E6%8B%9B%E9%9D%A2%E8%AF%95%E9%A2%98/",
            "url": "http://example.com/2022/10/28/%E7%A7%8B%E6%8B%9B%E9%9D%A2%E8%AF%95%E9%A2%98/",
            "title": "秋招面试题",
            "date_published": "2022-10-28T05:38:45.000Z",
            "content_html": "<h1 id=\"秋招面试题\"><a class=\"markdownIt-Anchor\" href=\"#秋招面试题\">#</a> 秋招面试题</h1>\n<h2 id=\"1特斯拉-网络工程师-一面\"><a class=\"markdownIt-Anchor\" href=\"#1特斯拉-网络工程师-一面\">#</a> 1. 特斯拉 - 网络工程师 - 一面</h2>\n<blockquote>\n<p>0. 自我介绍 (不限语言)</p>\n<p>1. 有哪些直辖市</p>\n<p>2. 鲁迅故居</p>\n<p>3. 东三省</p>\n<p>4. 曹操哪个朝代</p>\n<p>5. 唐宋八大家</p>\n<p>6. 苏轼苏洵苏辙 关系</p>\n<p>7. 表格堂哥区别</p>\n<p>6.DHCP 工作原理</p>\n<p>7.DNS port</p>\n<p>8.dhcp 配置时 IP helper-address</p>\n<p>9.Liunx 内核，发行版</p>\n<p>10.mac 地址哪一层</p>\n<p>11. 网管干啥</p>\n<p>12.aws 干啥</p>\n<p>13. 项目和实习时的区别</p>\n<p>14. 能用 python 写一些自动获取 ip 的脚本吗，不是 dhcp，是 SDN 那类</p>\n<p>15.kali 一般用那些工具</p>\n<p>16. 生涯规划 你到底要干安全还是网络<br>\n (面网络别提安全)</p>\n<p>17. 你还有啥想问的</p>\n<p>立即推 ， 当场送走</p>\n<p>一共 22 分钟，两个面试官，先问常识，再问网络，最后实习项目校园经历，一般都是按照简历顺序问的</p>\n</blockquote>\n<h2 id=\"2理想汽车-安全运营-一面\"><a class=\"markdownIt-Anchor\" href=\"#2理想汽车-安全运营-一面\">#</a> 2. 理想汽车 - 安全运营 - 一面</h2>\n<blockquote>\n<p>有啥安全相关的项目或者实习经历<br>\n答：没有，但我干过 CTF</p>\n<p>CTF 那件事情你最印象深刻<br>\n答：php 反序列化<br>\n此处省略 1k 字<br>\n从原理防御 到 pop 链</p>\n<p>既然说到了 pop 链，说说看 php 里面的魔法方法吧</p>\n<p>说到了 wakeup 绕过，这个在 php 某些版本有用，还是通杀<br>\n答：只记得是 cve 漏洞，在 &lt; 7.0 的版本测试过</p>\n<p>逻辑漏洞任意邮箱注册怎么修 指的是激活账号时修改邮箱导致任意邮箱注册，也可以理解为任意邮箱激活<br>\n答：加 token 追问：在哪加，是注册的时候加，还是激活的时候加<br>\n寄</p>\n<p>富文本编辑器 XSS 怎么修</p>\n<p>sql 注入防御</p>\n<p>PDO 在无法限制的场景比如 order by 该怎么办</p>\n<p>以上三道及回答均在胡扯，答案自己百度去吧</p>\n<p>入侵排查 排查哪些 shell 脚本一般要写哪些</p>\n<p>追问 netstat 怎么查看，那么多 ip 那个是危险的<br>\n - lntup grep establish<br>\n 怎么找到进程<br>\n有对应的 PID<br>\n 排查进程启动项…</p>\n<p>渗透的时候印象深刻的事<br>\n横向，向日葵</p>\n<p>discuz 漏洞复现<br>\n任意文件删除 cookie 存注入</p>\n<p>cookie 对单个参数限制长度，如何绕过</p>\n<p>能用 sqlmap 为啥还要自己写脚本</p>\n<p>Python 私有方法 lamdba 表达式 map sum<br>\na[1,2,3,4,5]<br>\na[1::3]<br>\nsum(map(lamdba(x:x+3))) == 13</p>\n<p>数组切片</p>\n<p>对于出现了 0day，该怎么对公司资产进行排查</p>\n<p>全程大概 1 个小时，人都麻了</p>\n</blockquote>\n<h2 id=\"3快手-idc运营网络方向-一面\"><a class=\"markdownIt-Anchor\" href=\"#3快手-idc运营网络方向-一面\">#</a> 3. 快手 - IDC 运营网络方向 - 一面</h2>\n<blockquote>\n<p>我看你写的网络工程，讲讲你的专业课掌握程度<br>\n答：tcpip 会一点，网络编程一般</p>\n<p>专业排名</p>\n<p>tcpip 滑动窗口原理 滑动窗口初始值是多少<br>\n慢启动是啥<br>\n tcpip 多少层，都是啥，每层作用 (参考数据包的封装 解封装)<br>\n tcp syc flood 原理防御<br>\n答：限制连接数和连接时间<br>\n然后用他就反驳了我，这两个办法都有待商榷</p>\n<p>ospf<br>\n 负载分担怎么实现 答：开销<br>\n两台路由器之间取消负载分担，只需要 A-&gt;B 不负载分担，回程不管，在哪配开销，为什么 答：在 A 配，路由表的原因<br>\n那 b 呢，如果不配来回路径不一致会有问题吗</p>\n<p>一个区域中如果网络类型为 p2p 会有几类 LSA</p>\n<p>lsa 类型 只需要说常见的既可以</p>\n<p>ospf 防环 区域间区域内</p>\n<p>spf 算法</p>\n<p>bgp 属性</p>\n<p>origin network 路由和汇总路由都是什么 origin 不同 origin 优先级那个更优 origin 怎么控制选路 答： bgprou -&gt; iprou</p>\n<p>双点双向 重发布</p>\n<p>项目 交换机类型 上下连 端口 收敛比</p>\n<p>全程 35 分钟左右，我又又又裂开了</p>\n</blockquote>\n<h2 id=\"4shareit-sre-一面\"><a class=\"markdownIt-Anchor\" href=\"#4shareit-sre-一面\">#</a> 4.SHAREit - SRE - 一面</h2>\n<blockquote>\n<p>接不接受 7*24oncall</p>\n<p>crontab * 字段含义</p>\n<p>Linux 版本</p>\n<p>http 状态码</p>\n<p>tcp 和 udp 区别</p>\n<p>怎样学习新知识</p>\n<p>k8s 了解</p>\n<p>怎样看文件夹大小 (du)</p>\n<p>分区挂载过程</p>\n<p>mysql 新建用户</p>\n<p>mysql 查看权限</p>\n<p>如果在周末出了 serv2 你第一个看到你怎么做</p>\n<p>使用过公有云吗</p>\n<p>有哪些负载均衡器</p>\n<p>有哪些监控软件</p>\n<p>怎样查看和本机建立了连接的 IP</p>\n<p>怎么判断主机之间是否连通</p>\n<p>怎么样判断主机之间端口是否开放</p>\n<p>用过 python 和 shell 吗，用 python 干了啥，用 shell 干了啥</p>\n</blockquote>\n<h2 id=\"5信锐-技术服务工程师-一面\"><a class=\"markdownIt-Anchor\" href=\"#5信锐-技术服务工程师-一面\">#</a> 5. 信锐 - 技术服务工程师 - 一面</h2>\n<blockquote>\n<p>自我介绍</p>\n<p>实习干啥的</p>\n<p>访问网页过程</p>\n<p>电脑获取地址方法 (讲了手工配和 dhcp, 详细讲了 dhcp)</p>\n<p>接上一题：你说 dhcp 有哪些报文？</p>\n<p>路由协议分类</p>\n<p>讲一种你熟悉的路由协议</p>\n<p>学习方法 (怎样学习新知识)</p>\n<p>网管干啥的 (简历上的，在学校担任过)</p>\n<p>讲了一下在学校 troubleshooting 的思路</p>\n<p>唐都项目干啥的</p>\n<p>讲了一下干了个啥</p>\n<p>生涯规划</p>\n<p>还有啥问题想问的</p>\n</blockquote>\n<h2 id=\"6信锐-技术支持-二面\"><a class=\"markdownIt-Anchor\" href=\"#6信锐-技术支持-二面\">#</a> 6. 信锐 - 技术支持 - 二面</h2>\n<blockquote>\n<p>自我介绍</p>\n<p>网络通信两种模型，区别<br>\n OSI TCP</p>\n<p>怎么保证可靠性和安全性<br>\n冗余 安全</p>\n<p>为什么要考 ie<br>\n 先说了一个技术方面，他说只有技术吗，没有对职业的规划？我后面补充了我是网工的啦，以后想干这行啦，最后也扯回到了职业规划</p>\n<p>ie 证书咋考的，为啥第一次面试没过，我说项目题挂了，他追问有哪些项目题，我说了一个企业网架构，三层架构，他追问每一层是干啥的，用到啥技术</p>\n<p>追着项目往死里问，问我为啥一个项目能做两个月，咋割接的，都 tm 快和他吵起来了，我和他讲是因为配置迁移问题，他死活说有问题</p>\n<p>唐都那个项目干啥了<br>\n简单说了一下排错和优化</p>\n<p>有啥没考过的证书</p>\n<p>过去一年最难的事<br>\n考 ie</p>\n<p>大学中印象最深的事<br>\n奖学金</p>\n<p>生涯规划</p>\n<p>你觉得和别人相比，你的优势是什么<br>\n我说我对于设备更了解一些啦</p>\n<p>有女朋友吗，为什么不找。那你是从来没谈过吗，高中谈过吗<br>\n沉迷学习，日渐消瘦</p>\n<p>如果有个你很喜欢的姑娘，但你父母死活不同意，怎么办<br>\n沟通，然后他就搞了各种各样的</p>\n<p>对技术支持的了解<br>\n对接客户和工程师</p>\n<p>以上两个是对逻辑的考察，评价是整体偏弱，需要考虑客户的痛点</p>\n<p>还有啥问题，我问的除了我说的两条，还有对于技术支持的工作还有什么补充的吗，他说的上面那条逻辑偏差</p>\n</blockquote>\n<h2 id=\"7深信服-安全服务-一面\"><a class=\"markdownIt-Anchor\" href=\"#7深信服-安全服务-一面\">#</a> 7. 深信服 - 安全服务 - 一面</h2>\n<blockquote>\n<p>自我介绍</p>\n<p>三层交换机和二层交换机的区别</p>\n<p>查看用户历史命令 怎么查看别人的历史命令</p>\n<p>文件上传 getshell 了但不能链接怎么排查</p>\n<p>你熟悉那种漏洞<br>\n答：sql 注入</p>\n<p>sql 注入有哪几种</p>\n<p>union select 后面可以跟 union select insert 吗</p>\n<p>union select 叫啥名字</p>\n<p>怎么通过数据库获取系统权限 mysql 呢，SQL server 呢<br>\n答 mysql 可以写 shell<br>\n 估计是想听 mysql 提权</p>\n<p>mysql 写 shell 的命令是啥</p>\n<p>堆叠注入原理</p>\n<p>堆叠注入和 union select 有啥区别</p>\n<p>报错注入原理，语句</p>\n<p>时间盲注原理，语句</p>\n<p>shrio 反序列化，fastjson 反序列化</p>\n<p>struct 漏洞<br>\n答：三个都不会</p>\n<p>讲讲 Java 反序列化</p>\n<p>内网渗透搭隧道怎么搭<br>\n答：可以用 earthworm</p>\n<p>earthworm 三种模式</p>\n<p>还有其他方法吗</p>\n<p>内网横向有哪些方法<br>\n答：ipc wmin psexec</p>\n<p>psexec 忘了问了啥了</p>\n<p>wmin 端口是啥，横向之后是什么权限</p>\n<p>权限维持有哪几种</p>\n<p>有安全项目和实习嘛</p>\n<p>怎么学习</p>\n<p>职业规划</p>\n<p>机构的课程结束了嘛</p>\n<p>有你印象的技术类博客嘛</p>\n</blockquote>\n<h2 id=\"8安天-网络安全管培生一面\"><a class=\"markdownIt-Anchor\" href=\"#8安天-网络安全管培生一面\">#</a> 8. 安天 - 网络安全管培生一面</h2>\n<blockquote>\n<p>我的自我介绍</p>\n<p>对于安全的理解</p>\n<p>学校主修的除了网安还有啥</p>\n<p>项目有啥和安全相关的</p>\n<p>实习有啥和安全相关的</p>\n<p>登录框有啥漏洞</p>\n<p>入侵排查</p>\n<p>讲讲你学的，举个例子<br>\n异或取反 beef</p>\n<p>有很多项目同时给你你咋办</p>\n<p>我们在沈阳北京哈尔滨都有站点，但沈阳是小站点，你怎么规划，如果你 base 沈阳</p>\n<p>如果你带领五个人的团队你怎么管理</p>\n<p>你又要干技术又要管理你怎么办</p>\n<p>网管碰到棘手的人咋办</p>\n<p>这哥们第一年招管培生和我谈论今天穿了什么</p>\n<p>你对于职业规划</p>\n<p>上一个来的是个 985 博士，已经研究员了</p>\n</blockquote>\n<p>9. 长亭 - 技术支持 - 一面</p>\n<blockquote>\n<p>自我介绍</p>\n<p>印象深刻项目<br>\n说了说割接</p>\n<p>然后问的挺详细</p>\n<p>实习经历</p>\n<p>说说看交换机 troubleshooting</p>\n<p>说说看服务器 troubleshooting</p>\n<p>有部署会操作系统吗<br>\n没有他们都是 pxe</p>\n<p>ce 和 ie 啥时候考的</p>\n<p>我看你网络的，说说 osi 每层协议</p>\n<p>osi 封装解封装</p>\n<p>tcp 四次挥手 timewait</p>\n<p>为啥握手三次挥手四次</p>\n<p>http 有哪几个版本，区别是啥</p>\n<p>https 原理<br>\n http 有哪些组成<br>\n头 行</p>\n<p>拿 linux 搭过什么服务<br>\n搭过网站</p>\n<p>哪些网站，怎么搭的</p>\n<p>nigix 搭过吗，讲讲特性</p>\n<p>nginx 有哪些负载分担模式</p>\n<p>邮件搭过吗 dns 搭过吗</p>\n<p>dns 原理是啥<br>\n我不知道于是我开始扯 log4j2 dnslog 外带</p>\n<p>我看你安全很懂哦，说说看 xss<br>\n 命名空间混淆突变，dom 破坏</p>\n<p>waf 是干啥的，那一层的</p>\n<p>类似于生涯规划的问题</p>\n<p>说说看你对长亭的理解</p>\n<p>说说看你对岗位的理解</p>\n<p>工作地点</p>\n<p>Q&amp;A</p>\n</blockquote>\n<h2 id=\"10宏杉-技术支持-一面\"><a class=\"markdownIt-Anchor\" href=\"#10宏杉-技术支持-一面\">#</a> 10. 宏杉 - 技术支持 - 一面</h2>\n<blockquote>\n<p>自我介绍</p>\n<p>考研吗考公吗</p>\n<p>大学啥专业，为啥投这个岗位</p>\n<p>证书自己花钱还是父母的钱</p>\n<p>ie 多少钱</p>\n<p>为啥考</p>\n<p>六级多少分四级多少分</p>\n<p>籍贯</p>\n<p>面试通过多久过来实习</p>\n<p>路由协议有哪些</p>\n<p>生成树作用</p>\n<p>super vlan</p>\n<p>dhcp</p>\n<p>链路聚合协议哪几种优缺点</p>\n<p>linux 启动过程</p>\n<p>定时任务</p>\n<p>全国分配可以接受？</p>\n<p>明年过年结束后可以过来</p>\n<p>家里干啥的</p>\n<p>兄弟姐妹几个</p>\n<p>期望薪资</p>\n</blockquote>\n<h2 id=\"11中科曙光-云平台网络研发工程师-一面\"><a class=\"markdownIt-Anchor\" href=\"#11中科曙光-云平台网络研发工程师-一面\">#</a> 11. 中科曙光 - 云平台网络研发工程师 - 一面</h2>\n<blockquote>\n<p>1.OSI 二层和三层有哪些协议</p>\n<p>2. 用过防火墙吗，有哪些功能，怎么保证安全，内部实现</p>\n<p>3.VPN 用过吗，IPSEC 详细原理了解过吗</p>\n<p>4.DHCP 报文交互过程，重启虚拟机发什么包</p>\n<p>5. 服务器端口没有 up</p>\n<p>6. 交换机端口没有 up</p>\n<p>7. 链路捆绑，两个端口 LACP 断了一边</p>\n<p>8. 开发接触过吗，python 作过哪些项目</p>\n<p>9. 毕业论文</p>\n<p>10. 啥时候实习</p>\n</blockquote>\n<h2 id=\"12汉德-云解决方案工程师-一面\"><a class=\"markdownIt-Anchor\" href=\"#12汉德-云解决方案工程师-一面\">#</a> 12. 汉德 - 云解决方案工程师 - 一面</h2>\n<blockquote>\n<p>0x00<br>\n 这家是秋招面了四五十家技术含量最高的企业，没有之一，问的太广了，问的还很深，扛不住扛不住，告辞</p>\n<p>linux<br>\n1.linux 进程状态<br>\n 3 running, 144 sleeping, 0 stopped, 1 zombie</p>\n<p>2. 检查服务是否运行</p>\n<p>3. 查看服务器 CPU，内存，磁盘利用率，linux 版本<br>\n内存：<br>\n[lighthouse@VM-16-11-centos ~]$ free<br>\ntotal used free shared buff/cache available<br>\nMem: 1881996 577340 112936 17348 1191720 1091156<br>\nSwap: 1049596 524544 525052<br>\n/proc/meminfo 内存<br>\n vmstat 内存<br>\n top 命令一般用于查看进程的 CPU 和内存使用情况<br>\n df -h lsblk fdisk -l 硬盘</p>\n<p>4.crontab<br>\n5. 常用 linux 命令<br>\n 6. 更改文件权限 chmod</p>\n<p>网络<br>\n 1.tcp 和 udp 区别<br>\n 2.get 和 post 区别<br>\n 3. 访问 www.xxx.com 发生了什么<br>\n 4.cookie 和 session 区别<br>\n 5. 状态码</p>\n<p>安全<br>\n 1.sql 注入，防御<br>\n 2. 安全工具<br>\n 3. 靶场<br>\n 4. 有哪些加密算法</p>\n<p>mysql<br>\n1.acid<br>\n2.mysql 锁<br>\n 3. 隔离界别<br>\n 4. 主键，外键，主键和索引区别</p>\n<p>操作系统<br>\n死锁<br>\n预防死锁<br>\n内存泄漏</p>\n<p>项目<br>\n实习</p>\n<p>比赛经历</p>\n<p>猜数字<br>\n四个数字不重复<br>\n 3456 1A 1B A 代表位置数字正确 B 代表只有数字正确</p>\n</blockquote>\n<h2 id=\"13宏杉-技术支持-二面\"><a class=\"markdownIt-Anchor\" href=\"#13宏杉-技术支持-二面\">#</a> 13. 宏杉 - 技术支持 - 二面</h2>\n<blockquote>\n<p>DRBDR</p>\n<p>LVM 磁盘满了，用另一块磁盘扩容的命令</p>\n<p>工作地点</p>\n<p>你的你的同事做一个项目，因为同事的原因失败了，领导批评了你，你怎么办</p>\n<p>领导给你一个你不会做的比较难的任务，你怎么办</p>\n<p>生涯规划，啥时候来实习</p>\n</blockquote>\n<h2 id=\"14中科闻歌-运维工程师-一面\"><a class=\"markdownIt-Anchor\" href=\"#14中科闻歌-运维工程师-一面\">#</a> 14. 中科闻歌 - 运维工程师 - 一面</h2>\n<blockquote>\n<p>OSI 模型</p>\n<p>STP 选举</p>\n<p>防火墙用过吗，啥型号的，A 访问 B 时在防火墙配置单向还是双向，如果是交换机，需要配置单向还是双向</p>\n<p>BGP 选路</p>\n<p>OSPF 邻居建立</p>\n<p>项目</p>\n</blockquote>\n<h2 id=\"15吉利英伦-网络管理专员-一面\"><a class=\"markdownIt-Anchor\" href=\"#15吉利英伦-网络管理专员-一面\">#</a> 15. 吉利英伦 - 网络管理专员 - 一面</h2>\n<blockquote>\n<p>200-300 人的小型网怎么做<br>\n 200-300 人的小型网怎么做<br>\n我说三层，他说只有接入和核心</p>\n<p>链路选择，光还是电，都用在什么场景，传输距离</p>\n<p>有哪些 vpn<br>\n 他说现在都是硬件的，ipsec</p>\n<p>lvm 是啥</p>\n<p>iaas paas saas</p>\n<p>链路可靠性 (聚合</p>\n<p>堆叠，假如五台做堆叠，有一台有上联，怎么搞，堆叠需要啥<br>\n需要堆叠线缆</p>\n<p>怎么控制访问，比如不让访问 qq</p>\n<p>有哪些 cs 的服务，我说 web，他追问中间件有哪些， nginx 干啥的，有啥功能，咋做负载分担<br>\n我说服务器集群，他说还得有数据库集群和其他集群</p>\n<p>怎么样通过域名访问服务器<br>\n我说内网搭个 dns，他说这样只有内网，我又说买个域名设置 ip 解析，他没说啥</p>\n<p>防火墙在出口，怎么保证可靠，还有上网行为管理可靠</p>\n<p>网关在核心，vlan 怎么划分</p>\n<p>上网行为管理放哪，哪种模式</p>\n</blockquote>\n<h2 id=\"16迪普-技术支持-一面\"><a class=\"markdownIt-Anchor\" href=\"#16迪普-技术支持-一面\">#</a> 16. 迪普 - 技术支持 - 一面</h2>\n<blockquote>\n<p>IPSEC 了解过吗</p>\n<p>三层转发源目 IP 源目 MAC 变吗</p>\n<p>BGP 邻居建立</p>\n<p>BGP 传递路由，撤销路由</p>\n<p>bgp refresh import export</p>\n<p>ospf 卡在 exstart 状态原因</p>\n<p>ospf 影响邻居建立因素</p>\n<p>p2mp 和 p2p 能建邻居吗</p>\n<p>linux 压缩解压缩</p>\n<p>tar 命令每个参数含义</p>\n<p>scp 了解过吗</p>\n<p>防火墙转发机制</p>\n<p>防火墙有哪些安全域，dmz 优先级多少</p>\n<p>防火墙区域内互访通吗，区域间呢</p>\n<p>防火墙对于多通道协议支持</p>\n<p>防火墙多通道协议对于 nat 支持</p>\n<p>sql 注入原因与防御</p>\n<p>上网行为管理不通怎么排查   查日志</p>\n<p>割接失败怎么办</p>\n<p>你怎么割接的</p>\n<p>你的优势是什么</p>\n</blockquote>\n",
            "tags": []
        },
        {
            "id": "http://example.com/2022/10/27/%E7%A7%8B%E6%8B%9B%E6%80%BB%E7%BB%93/",
            "url": "http://example.com/2022/10/27/%E7%A7%8B%E6%8B%9B%E6%80%BB%E7%BB%93/",
            "title": "秋招总结",
            "date_published": "2022-10-27T05:38:45.000Z",
            "content_html": "<h1 id=\"秋招总结\"><a class=\"markdownIt-Anchor\" href=\"#秋招总结\">#</a> 秋招总结</h1>\n<h2 id=\"0x00-废话~\"><a class=\"markdownIt-Anchor\" href=\"#0x00-废话~\">#</a> 0x00 废话～</h2>\n<p>秋招从七月份投的第一家特斯拉开始，到目前 (2022.10.15)，已经投了快 170 家了，有安全，网络，运维岗，我只能投这三个岗，因为我也只会这三个。我常因为自己太菜与你们格格不入～。目前 offer 有四家。</p>\n<blockquote>\n<p>1. 信锐 (技术支持)</p>\n<p>通过三面拿到的 offer，一面基本技术面，二面半技术半问答 (文章接下来的问答指的均是聊天，比如有女朋友吗，对技服了解吗这类非技术相关的问题)，三面纯问答聊天。最终想薪资也是目前到现在最高的，年薪可以达到 20</p>\n<p>2. 兴唐通信 (系统集成)</p>\n<p>这是一家国企，带有一些保密性质，因此入职三年之内不能离职，这可能是我最不能接受的点，因为子曾经曰过:“安全人，安全魂，安全人都是人上人”，我的计划是今年经济形势不好先随便找个给的多的企业苟着，来年再战，混到安全去！因此我拒绝了这家的 offer。第二个原因就是给的是在有点少，虽然 base 在上海，我立即推当场回家，但上海不到 1W (具体多少也不能透露，反正没有 1W，大概 ***)，着实有些难受，而且他的风评也有些诡异，告辞，惹不起～。补充一句，这家也有三面，好像三面都没怎么问技术</p>\n<p>3. 中海达 (技术支持)</p>\n<p>这是一家鸽王<sub>，第一批面试的时候鸽了我 20 分钟，当时还在实习，是在是等不起，于是到了第二批。第二批又鸽了我二十分钟，上午的面试，中午才给我打电话，说改到下午五点，五点又迟到 8 分钟</sub>大无语事件。但那天一面面完第二天还是第三天直接发 offer 了。offer 上面没写薪资没写待遇福利，实在难以下咽，遂告辞。更新 1.0:offer 是九月底发的，但十月中旬突然又来和我探讨薪资的事，您这个跨度有些大啊～，而且给的和兴唐差不多，难顶 (薪资水平 *** 左右)</p>\n<p>4. 保融科技 (技术支持)</p>\n<p>这家公司只有二面，两次面试都没咋问技术，但聊得很开心，是秋招目前为止聊得最开心的公司，一面的小姐姐也很好看<sub>好评</sub>，但无奈薪资问题和预期差距过大，毕竟第一个信锐 offer 拿到后，后面面的给的都没信锐多，厂商规模也没信锐大，这家 base 在杭州，但我的 offer 是实施，就是全国出差的那种，那其实和信锐没啥区别了，两家做的东西都相同的情况下，肯定是找大厂和工资高的，保融啊<sub>我对不起你啊</sub> (2,3,4 这三家其实薪资都差不多)(记一下吧反正不发出去，这个基本薪资 ***，也有烂七八糟的补贴)<br>\n 10.20 补充</p>\n<p>今天又拿了两家 offer，再来废话两句</p>\n<p>5. 宏杉科技 (技术支持)</p>\n<p>这是个存储的公司，在全国大部分城市都有办事处，工作地点也和信锐一样，结合自己的意愿和公司实际情况分配。这家是目前为止除了信锐给的第一多的，一个月基本工资能有 ***，还有乱七八糟的房补，和其他补贴。但他不讲武德的地方在于，如果你把它违约了你需要支付违约金，但如果你因为他把别人违约了他是一分不给。(学学信锐，哪有这么白嫖的)，而且常住地，户籍所在地是没有房补的。没有必要，拒了。面试一共两次，第一次问了点技术，第二次也问了点，但比第一次少很多，第二次多了很多职场题目。</p>\n<p>6. 东方日升 (运维工程师)</p>\n<p>这家应该是做经济的，我投的好像是啥技术类管培生，他的 offer 上是这么写的，我也不记得我投了啥了。这家一共只有一面，是 hr 和一个问技术的一起面的，但技术没问啥，全问的项目实习，这种回答了几千遍的题目是在没意思，我全程输出，他根本插不上嘴，我一堆 span-leaf，border-leaf 把它杀穿。然后第二天就给 offer 了，问题在于实习 ***，转正 xxx。难顶啊～拒了拒了</p>\n<p>10.21 补充，又拿了一家 offer 再来 bb 两句 ，说实话，每次拿到 offer 都把我搞的精疲力尽</p>\n<p>7. 中科闻歌 (运维工程师)</p>\n<p>这家是面到现在最心动的一家公司，面试只有一面，但三个面试官，第一个问网络，第二个问项目，第三个 hr 随便问点，但他们给人一种很重视应届毕业生的感觉，也可能是错觉，而且这家公司规模其实能比信锐更大一些，我投的是做运维的，据他们说他们公司会让网络和搞云计算的一起工作，达成一些目的。但无奈薪资实在尴尬，北京 ***，没有房补，我真的要露宿街头了，当场贷款上班，告辞，最不巧的是给信锐寄方法和给中科翁工决定是同一天的同一个下午，但凡他有个房补，我当场违约。</p>\n<p>10.25 补充，这是昨天还是前天的 offer 了</p>\n<p>8. 石化盈科 (网络安全工程师)</p>\n<p>非常奇葩的面试，只有一面，但一面包车的面试官，一个腾讯会议进去十几个人，每个人都应该是部门的经理一类的，然后 hr 是先和你进行讨论的人，讲到哪个技术部门负责人感兴趣会对你进行追问，比如当时有个部门应该是搞渗透测试的，还有个应该是搞二进制的。这个 offer 也很奇葩，hr 告诉部门经理 offer 已经给我了，让他来找我沟通，结果我没有收到 offer，听这个人一顿讲，最后不知道薪资多少。最后还是他帮我问的，一个月 ***，还是包含房补的，工作地点在北六环附近，那边租房也得 2k-3k，抢钱啊～，但听那人最后的意思是找我去做数据中心运维…</p>\n<p>10.27 更新，203 家…</p>\n<p>我发的时候把薪资屏蔽了，如果想知道具体的可以找我私聊～</p>\n</blockquote>\n<p>再废话两句，1. 有能投的就投，千万别看大小，举个栗子，谁都没想到今年最高的是个没听过名字的机器人公司，你认为的小厂不一定是小厂，一般有机构看机构的就业群，没有找公众号，公众号的企业虽然多，但不是所有企业都要我这种 IT 的，秋招群里的信息实际上是老师们过滤之后的，有针对性了很多</p>\n<p>2. 笔试和测评可能很多很多，但还是要好好做的，万一呢～</p>\n<p>3. 考研，考研，考研，重要的事情说八百遍，今天面试的哥们问我你有 ie 为啥不去华为，我:…，华为是不会要双非的本科的，考研最好也往 211 考。</p>\n<p>4. 最好对自己投的企业做个详细记录，同时对面试过程也做个详细记录，方便后续复盘，我今天的复盘的全部内容来自于我每次面完写的 CSDN，最好每次面完就复盘，这样对你下一家类似岗位的很有帮助，人不能在一个地方疯狂翻车</p>\n<p>5. 不要死磕运维 / 安全岗，有给的多的，差不多能干的就先跑，不雅等春招，某个企业的 HR 在和我聊得时候透露等春招他们就剩个位数岗位或者直接不招了，而且春招还要再加几百万研究生们，难度直接上天</p>\n<p>总结到这，废话说完了，开始正题，预计文章会有两大部分。 <code>1.网络岗，技术支持岗，运维岗面试总结</code>     <code>2.安全岗面试总结</code></p>\n<p>项目实习啥的就不说了问的基本上都一样，还有一些你遇到的困难，印象深刻的事啦，随缘临场发挥吧</p>\n<p>安全岗包括但不限于安服，网络安全管培生等职位，和安全相关的都在下面列举</p>\n<h2 id=\"0x01-网络技术支持运维岗总结\"><a class=\"markdownIt-Anchor\" href=\"#0x01-网络技术支持运维岗总结\">#</a> 0x01 网络，技术支持，运维岗总结</h2>\n<h3 id=\"1dhcp工作原理报文种类\"><a class=\"markdownIt-Anchor\" href=\"#1dhcp工作原理报文种类\">#</a> 1.DHCP 工作原理，报文种类</h3>\n<p><code>出现厂家：特斯拉一面(ip helper address)，信锐(获取地址方法，问的其实还是这个)，中科曙光，宏杉</code></p>\n<img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221016184839806.png\" alt=\"image-20221016184839806\" style=\"zoom: 67%;\" />\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.四次交互获取IP</span><br><span class=\"line\">广播发送discover报文，寻找DHCP服务器</span><br><span class=\"line\">offer单播回，其中包含着一个ip地址和一些配置信息比如，网关，租期，dns等</span><br><span class=\"line\">广播发送request请求这个IP地址，发广播的原因可能网络中还有其他的DHCP服务器，告诉他们自己有了IP地址</span><br><span class=\"line\">dhcp服务器收到a的request之后单播发送一个ACK,此地址才可以开始使用</span><br><span class=\"line\"></span><br><span class=\"line\">2.租期，续约</span><br><span class=\"line\">当租期到达50%会单播发送request包，服务器收到单播回复ack，主机租期刷新</span><br><span class=\"line\">在租期到达85%会广播发送request包，网络上任何一台DHCP服务器都可以应答ack或者nak，收到ACK刷新租期，收到NAK重新申请IP</span><br><span class=\"line\">当租期到达100%会发送release报文，释放IP地址，之后重新discover申请地址</span><br><span class=\"line\">即可以通过request刷新租期，release释放地址</span><br><span class=\"line\"></span><br><span class=\"line\">3.DHCP是UDP的，使用67(server),68(client)</span><br><span class=\"line\"></span><br><span class=\"line\">4.dhcp一共八种报文，剩下四种</span><br><span class=\"line\">NAK：服务器拒绝请求</span><br><span class=\"line\">release：释放IP地址</span><br><span class=\"line\">infrom：向服务端请求一些信息</span><br><span class=\"line\">decline：地址冲突时，告知服务器禁止使用此地址</span><br><span class=\"line\"></span><br><span class=\"line\">5.一些协议细节~</span><br><span class=\"line\">1.如果该客户端上次也问服务端要过地址，那么客户端在检查该地址没有被分配有还是会分配给这个客户端(所以说dhcp是C/S的)</span><br><span class=\"line\">2.客户端发的discover含有request ip，服务端检查地址是否可用，如果可用，还是会分给客户端此地址</span><br><span class=\"line\">3.客户端发的discover不含request ip，服务端从地址池上找一个最小的可用IP分配</span><br><span class=\"line\">4.NAK的情况：请求的静态IP，MAC无法与之对应。ack中验证失败</span><br><span class=\"line\"></span><br><span class=\"line\">6.DHCP offer中有租期是华为特有,其他厂商是使用inform报文</span><br><span class=\"line\">最好看看不同厂商对于DHCP的支持</span><br></pre></td></tr></table></figure>\n<h3 id=\"3tcpudp相关\"><a class=\"markdownIt-Anchor\" href=\"#3tcpudp相关\">#</a> 3.TCP/UDP 相关</h3>\n<h4 id=\"tcp滑动窗口初始值慢启动流控快手\"><a class=\"markdownIt-Anchor\" href=\"#tcp滑动窗口初始值慢启动流控快手\">#</a> tcp 滑动窗口初始值，慢启动，流控 (快手)</h4>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">滑动窗口</span><br><span class=\"line\">TCP连接每一方的接收缓冲空间大小都固定，接收端只允许另一端发送接收端缓冲区所能接纳的数据，TCP在滑动窗口的基础上提供流量控制，防止较快主机致使较慢主机的缓冲区溢出；TCP也是一样的，除了入口有发送方滑动窗口，出口处也设立有接收方滑动窗口。</span><br><span class=\"line\">拥塞控制</span><br><span class=\"line\">防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。</span><br><span class=\"line\">拥塞控制避免</span><br><span class=\"line\">慢开始( slow-start )、拥塞避免( congestion avoidance )、快重传( fast retransmit )和快恢复( fast recovery )。</span><br><span class=\"line\">发送方维持一个拥塞窗口 cwnd ( congestion window )的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞。</span><br><span class=\"line\">发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。</span><br><span class=\"line\">慢开始算法：当主机开始发送数据时，如果立即所大量数据字节注入到网络，那么就有可能引起网络拥塞，因为现在并不清楚网络的负荷情况。因此，较好的方法是 先探测一下，即由小到大逐渐增大发送窗口，也就是说，由小到大逐渐增大拥塞窗口数值。通常在刚刚开始发送报文段时，先把拥塞窗口 cwnd 设置为一个最大报文段MSS的数值。而在每收到一个对新的报文段的确认后，把拥塞窗口增加至多一个MSS的数值。用这样的方法逐步增大发送方的拥塞窗口 cwnd ，可以使分组注入到网络的速率更加合理。</span><br><span class=\"line\">...自己看吧，我也不知道这啥玩意</span><br><span class=\"line\">https://blog.csdn.net/qq_41431406/article/details/97926927</span><br><span class=\"line\">https://blog.csdn.net/ligupeng7929/article/details/79597423</span><br></pre></td></tr></table></figure>\n<h4 id=\"tcp-syn-flood-防御快手\"><a class=\"markdownIt-Anchor\" href=\"#tcp-syn-flood-防御快手\">#</a> TCP syn flood 防御 (快手)</h4>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">利用TCP三次握手协议，大量与服务器建立半连接，服务器默认需要重试5次，耗时63s才会断开接，这样，攻击者就可以把服务器的syn连接队列耗尽，让正常的连接请求不能处理。</span><br><span class=\"line\">最直接的做法就是提高服务能力，比如组建集群，升级硬件。</span><br><span class=\"line\">对于防火墙这类安全设备而言，SYN报文是正常的业务报文，防火墙的安全策略必须允许其通过，否则服务器就无法对外提供服务。</span><br><span class=\"line\">如果能明确虚假源的IP地址，就能通过精细的安全策略阻止这些源发来的SYN报文。</span><br><span class=\"line\">此时需要anti-DDoS。Anti-DDoS系统处理SYN报文主要有两种手段，源认证和首包丢弃。</span><br><span class=\"line\">Anti-DDoS系统拦截客户端发送的SYN报文，代替服务器向客户端发送SYN-ACK报文，如果客户端不应答，则认为该客户端为虚假源；如果客户端应答，则Anti-DDoS系统认为该客户端为真实源，并将其IP地址加入白名单，在一段时间允许该源发送的所有SYN报文通过，也不做代答。</span><br><span class=\"line\">如果Anti-DDoS系统代替服务器应答了所有的SYN Flood攻击报文，那么性能瓶颈仅仅是从服务器转移到了Anti-DDoS系统而已。一旦Anti-DDoS系统的系统资源耗尽，攻击依旧会透传到服务器，而且大量反弹的SYN-ACK报文也会对网络造成一定的压力。Anti-DDoS系统利用首包丢弃来解决这个问题。</span><br><span class=\"line\">TCP协议的可靠性不仅体现在三次握手，还体现在超时与重传的机制。正常情况下客户端发送SYN报文后如果在一定时间没有收到服务器的SYN-ACK应答，客户端会重新发送SYN报文。Anti-DDoS系统会丢弃掉收到的第一个SYN报文。SYN Flood攻击时，黑客发送的绝大多数是变源的SYN报文，所有的SYN报文对于Anti-DDoS系统来说都是首包，都将被直接丢弃。如果客户端重传了SYN报文，Anti-DDoS系统再对该报文进行源认证。如此一来，大大减少了Anti-DDoS系统代答的压力。首包丢弃和源认证两种手段结合，对于防御SYN Flood（特别是不断变换源IP和源端口的虚假源攻击）非常有效。</span><br><span class=\"line\">hping3</span><br><span class=\"line\">hping3是一个很有名的网络安全工具，使用它可以很容易构造各种协议包。</span><br><span class=\"line\">增大tcp_max_syn_backlog   增大队列用来存放还没有确认ACK的客户端请求</span><br><span class=\"line\">减小tcp_synack_retries    减少服务端重发ack的次数</span><br><span class=\"line\">启用tcp_syncookies\t\t当启用tcp_syncookies时，backlog满了后，linux内核生成一个特定的n值，而不并把客户的连接放到半连接的队列backlog里（即没有存储任何关于这个连接的信息，不浪费内存）。当客户端提交第三次握手的ACK包时，linux内核取出n值，进行校验，如果通过，则认为这个是一个合法的连接。</span><br><span class=\"line\"></span><br><span class=\"line\">过滤</span><br><span class=\"line\">增加积压</span><br><span class=\"line\">减少SYN-RECEIVED定时</span><br><span class=\"line\">复用古老的半开通TCP</span><br><span class=\"line\">SYN缓存</span><br><span class=\"line\">SYN Cookie</span><br><span class=\"line\">混合方法</span><br><span class=\"line\">防火墙和代理</span><br></pre></td></tr></table></figure>\n<h4 id=\"tcp和udp区别茄子汉得\"><a class=\"markdownIt-Anchor\" href=\"#tcp和udp区别茄子汉得\">#</a> tcp 和 UDP 区别 (茄子，汉得)</h4>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.</span><br><span class=\"line\">TCP（Transmission Control Protocol，传输控制协议）是面向连接的协议</span><br><span class=\"line\">UDP（User Data Protocol）是一个非连接的协议，传输数据之前源端和终端不建立连接</span><br><span class=\"line\"></span><br><span class=\"line\">2.UDP和TCP报头长度</span><br><span class=\"line\">UDP 8字节</span><br><span class=\"line\">TCP 20字节</span><br><span class=\"line\"></span><br><span class=\"line\">3.</span><br><span class=\"line\">UDP面向报文，尽力而为，没有拥塞控制等算法</span><br><span class=\"line\">TCP可靠，有差错校验，滑动窗口，流控，面向字节流</span><br><span class=\"line\"></span><br><span class=\"line\">4.</span><br><span class=\"line\">TCP只能点到点全双工，UDP支持一对一，一对多，多对一</span><br><span class=\"line\"></span><br><span class=\"line\">5.</span><br><span class=\"line\">TCP要求的系统资源较多，UDP较少</span><br></pre></td></tr></table></figure>\n<h4 id=\"tcp四次挥手timewait作用长亭\"><a class=\"markdownIt-Anchor\" href=\"#tcp四次挥手timewait作用长亭\">#</a> tcp 四次挥手 timewait 作用 (长亭)</h4>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/7bc94edb74608af80fbb4de8ab9c1bd7.png\" alt=\"img\"></p>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/11bd3c08694c9f869c3607fe32edb8ff.png\" alt=\"img\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">timewait的作用：</span><br><span class=\"line\">为了确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭。</span><br><span class=\"line\">在这里，如果图中主机 1 的 ACK 报文没有传输成功，那么主机 2 就会重新发送 FIN 报文。如果主机 1 没有维护 TIME_WAIT 状态，而直接进入 CLOSED 状态，它就失去了当前状态的上下文，只能回复一个 RST 操作，从而导致被动关闭方出现错误。而重发fin一来一去正好两个MSL</span><br><span class=\"line\">让之前因为某些原因延迟到达路由器的报文消失，如果关闭的连接被重用了，那么这些延迟收到的包就有可能会跟新连接混在一起</span><br><span class=\"line\">time-wait是从主机A收到FIN后发送ack开始计时的</span><br><span class=\"line\"></span><br><span class=\"line\">timewait的危害</span><br><span class=\"line\">第一是内存资源占用</span><br><span class=\"line\">第二是对端口资源的占用，一个 TCP 连接至少消耗一个本地端口。</span><br></pre></td></tr></table></figure>\n<h4 id=\"为啥挥四次握三次长亭\"><a class=\"markdownIt-Anchor\" href=\"#为啥挥四次握三次长亭\">#</a> 为啥挥四次握三次 (长亭)</h4>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">为了保证A发送的最有一个ACK报文段能够到达B。</span><br><span class=\"line\">没有数据传输，服务端的SYN和ACK报文可以一起发送，但是挥手时有数据传输,等待自己的数据传输完成后再ACK，ACK和FIN报文不能同时发送</span><br></pre></td></tr></table></figure>\n<h4 id=\"接下来是八股文时间~\"><a class=\"markdownIt-Anchor\" href=\"#接下来是八股文时间~\">#</a> 接下来是八股文时间：~</h4>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0x00 TCP第一次握手SYN包丢包</span><br><span class=\"line\">重传第一个包，重传次数由/proc/sys/net/ipv4/tcp_syn_retries决定，每次重传的时间翻倍上涨的，直至达到tcp_syn_retries决定，不在重传，开始摆烂</span><br><span class=\"line\">1 2 4 8 16 32 酱紫翻倍的</span><br><span class=\"line\"></span><br><span class=\"line\">0x01 TCP第二次握手SYN包丢包</span><br><span class=\"line\">客户端无法收到synack包，会重传syn。</span><br><span class=\"line\">服务端收到客户的SYN包后，就会回SYN、ACK包，但是客户端一直没有回ACK，服务端在超时后，重传了 </span><br><span class=\"line\">SYN、ACK 包，接着一会，客户端超时重传的SYN包又抵达了服务端，服务端收到后，超时定时器就重新</span><br><span class=\"line\">计时，然后回SYN、ACK包，所以相当于服务端的超时定时器只触发了一次，又被重置了；</span><br><span class=\"line\">当第二次握手的SYN、ACK丢包时，客户端会超时重发SYN包，服务端也会超时重传SYN、ACK包。同时客户端重传次数由tcp_syn_retries决定</span><br><span class=\"line\"></span><br><span class=\"line\">0x02</span><br><span class=\"line\">TCP第三次握手SYN包丢包</span><br><span class=\"line\">如果第三次握手的ACK，服务端无法收到，则服务端就会短暂处于SYN_RECV状态，并且依次等待3秒、6秒、12秒后重新发送SYN+ACK包，而客户端会处于 ESTABLISHED 状态。由于服务端一直收不到TCP第三次握手的ACK，则会一直重传SYN、ACK包，直到重传次数超过tcp_synack_retries,直至重传次数超过tcp_synack_retries</span><br><span class=\"line\"></span><br><span class=\"line\">0x03</span><br><span class=\"line\">// 第一次握手重传次数限制</span><br><span class=\"line\">cat /proc/sys/net/ipv4/tcp_syn_retries</span><br><span class=\"line\"></span><br><span class=\"line\">// 第二次握手重传次数限制</span><br><span class=\"line\">cat /proc/sys/net/ipv4/tcp_synack_retries</span><br><span class=\"line\"></span><br><span class=\"line\">// 数据包最大重传次数限制</span><br><span class=\"line\">cat /proc/sys/net/ipv4/tcp_retries2</span><br><span class=\"line\"></span><br><span class=\"line\">参考链接：https://juejin.cn/post/6844904181795389454</span><br><span class=\"line\">师傅在文章里还有详细截图，看不懂我写的可以去看他写的~</span><br><span class=\"line\"></span><br><span class=\"line\">0x04 TCP第一次挥手FIN包丢包</span><br><span class=\"line\">client发的FIN包丢了，对于client，因为没收对应的ACK包，应当一直重传(像普通包一样)，直至到达上限次数，直接关闭连接；对于server，它应该无任何感知；</span><br><span class=\"line\"> </span><br><span class=\"line\">0x05 TCP第二次挥手ACK包丢包</span><br><span class=\"line\">server回client的ACK包丢了，对于client，将执行（1），对于server将像丢普通的ack一样，再次收到FIN后，再发一个ACK包；</span><br><span class=\"line\"></span><br><span class=\"line\">0x06 TCP第三次挥手FIN包丢包</span><br><span class=\"line\">如果client收到ACK后，server直接跑路。client将永远停留在这个状态（半打开状态，就像client关闭了输出一样）。linux有tcp_fin_timeout这个参数，设置一个超时时间 cat /proc/sys/net/ipv4/tcp_fin_timeout 查看，默认60s。</span><br><span class=\"line\">server发的FIN包丢了，对于server，像丢普通的包一样，重传。若此时client早已跑路且与其他人建立的连接，client应会不认识这个FIN包，直接回个RST包给server。如若client没跑路，且没收到server的FIN包，如（3）描述；</span><br><span class=\"line\"></span><br><span class=\"line\">0x07 TCP第三次挥手ACK包丢包</span><br><span class=\"line\">防止回复的ACK包丢失（丢失后，server因为没收FIN的ACK，所以会再发一个FIN），将等待2MSL(最大报文存活时间)</span><br><span class=\"line\"></span><br><span class=\"line\">0x08 大结局</span><br><span class=\"line\">syn = 1丢了 计时器超时后重传第一个包(syn=1)</span><br><span class=\"line\">syn = 1, ack = 1丢了 重传第一个(syn=1)和第二个包(syn=1,ack=1)</span><br><span class=\"line\">ack = 1丢了 等待3秒、6秒、12秒后重新发送第二个(syn=1,ack=1)包</span><br><span class=\"line\">客户端fin = 1丢了 重传第一个包(fin=1)</span><br><span class=\"line\">服务端ack = 1丢了 重传第一个(fin=1)和第二个包(ack=1)</span><br><span class=\"line\">服务端fin = 1丢了 服务端重传第三个包(fin=1),client行为分类讨论，如果已经和别人建立了连接，那么回RST，如果没跑路，那么client将永远停留在这个状态(fin-wait)</span><br><span class=\"line\">客户端ack = 1丢了 服务端重传第三个包(fin=1),客户端等待Time-wait，即2MSL</span><br><span class=\"line\">如果他接下来再问你wait-time是干啥的，你直接创他</span><br><span class=\"line\">但我上面写了，别说我没写</span><br><span class=\"line\"></span><br><span class=\"line\">链接：https://www.cnblogs.com/quehualin/p/10409607.html</span><br><span class=\"line\">这个师傅写得很详细，师傅流啤~</span><br></pre></td></tr></table></figure>\n<h3 id=\"4osi相关\"><a class=\"markdownIt-Anchor\" href=\"#4osi相关\">#</a> 4.OSI 相关</h3>\n<h4 id=\"路由协议分类宏杉中科曙光信锐\"><a class=\"markdownIt-Anchor\" href=\"#路由协议分类宏杉中科曙光信锐\">#</a> 路由协议分类 (宏杉，中科曙光，信锐)</h4>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">从大类分，分为BGP和IGP 即内部网关和边界网关协议</span><br><span class=\"line\">BGP 中只有BGP这一个协议,BGP 又可以称为路径矢量型协议</span><br><span class=\"line\">IGP 中可以分为两大类：</span><br><span class=\"line\">\t距离矢量: RIP,EIGRP(高级的距离矢量型协议，Cisco私有)</span><br><span class=\"line\">\t链路状态：ISIS ,OSPF</span><br><span class=\"line\">然后慢慢扩展吧，千万别说完这个就不说了，你说说每个协议的应用场景等</span><br></pre></td></tr></table></figure>\n<h4 id=\"ositcpip区别\"><a class=\"markdownIt-Anchor\" href=\"#ositcpip区别\">#</a> osi/tcpip 区别</h4>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">OSI:\t\t\t\t\t\t\tTCP/IP</span><br><span class=\"line\">应用层\t\t\t\t\t\t\t应用层\t\t</span><br><span class=\"line\">表示层\t\t\t</span><br><span class=\"line\">会话层</span><br><span class=\"line\">传输层\t\t\t\t\t\t\t传输层</span><br><span class=\"line\">网络层\t\t\t\t\t\t\t网路层</span><br><span class=\"line\">数据链路层\t\t\t\t\t  网络接口层</span><br><span class=\"line\">网络层</span><br><span class=\"line\"></span><br><span class=\"line\">层数不同—-OSI为7层，TCP/IP为四层或五层</span><br><span class=\"line\">TCP/IP支持跨层封装；OSI不支持  跨层封装主要用于非终端设备间相互沟通的流量，非远距离；</span><br><span class=\"line\">TCP/IP仅仅支持IP网络协议;  OSI支持多种网络层协议（IP    IPX    APPLE  TALK    NOVELL   NSAP）</span><br><span class=\"line\">TCP/IP 参考模型没有对网络接口层进行细分，只是一些概念性的描述； OSI 参考模型对服务和协议做了明确的区分。</span><br><span class=\"line\">OSI 先有模型，后有协议规范，适合于描述各种网络；TCP/IP 是先有协议集然后建立模型，不适用于非 TCP/IP 网络。</span><br><span class=\"line\">TCP/IP 一开始就提出面向连接和无连接服务，而 OSI 一开始只强调面向连接服务，直到很晚才开始制定无连接的服务标准。</span><br><span class=\"line\">OSI 实现起来较困难；相反，TCP/IP作为一种简化的分层结构还是比较成功的。</span><br></pre></td></tr></table></figure>\n<h4 id=\"二层三层交换机的区别深信服\"><a class=\"markdownIt-Anchor\" href=\"#二层三层交换机的区别深信服\">#</a> 二层三层交换机的区别 (深信服)</h4>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">二层交换机属数据链路层设备</span><br><span class=\"line\">三层交换机工作在网络层</span><br><span class=\"line\"></span><br><span class=\"line\">二层交换机的原理是当交换机从某个端口收到一个数据包，它会先读取包中的源MAC地址，再去读取包中的目的MAC地址，并在地址表中查找对应的端口，如表中有和目的MAC地址对应的端口，就把数据包直接复制到这个端口上。</span><br><span class=\"line\">三层交换机的原理比较简单，就是一次路由多次交换，通俗来说就是第一次进行源到目的的路由，三层交换机会将此数据转到二层，那么下次无论是目的到源还是源到目的都可以进行快速交换。</span><br><span class=\"line\"></span><br><span class=\"line\">二层交换机基于MAC地址访问，只做数据的转发，并且不能配置IP地址</span><br><span class=\"line\">三层交换机将二层交换技术和三层转发功能结合在一起，也就是说三层交换机在二层交换机的基础上增加了路由功能，可配置不同VLAN的IP地址，可通过三层路由实现不同VLAN之间通讯。</span><br><span class=\"line\"></span><br><span class=\"line\">二层交换机主要用于网络接入层和汇聚层</span><br><span class=\"line\">三层交换机主要用于网络核心层，但是也存在少部分三层交换机用于汇聚层的现象</span><br></pre></td></tr></table></figure>\n<h4 id=\"osi每层协议长亭招联中科曙光\"><a class=\"markdownIt-Anchor\" href=\"#osi每层协议长亭招联中科曙光\">#</a> OSI 每层协议 (长亭，招联，中科曙光)</h4>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">应用层:</span><br><span class=\"line\">http/https 80/443</span><br><span class=\"line\">dns 53</span><br><span class=\"line\">snmp 161/162</span><br><span class=\"line\">smtp 25</span><br><span class=\"line\">ftp 20/21</span><br><span class=\"line\">pop3 110</span><br><span class=\"line\">telnet 22</span><br><span class=\"line\"></span><br><span class=\"line\">表示层</span><br><span class=\"line\">GIF</span><br><span class=\"line\">JPEG</span><br><span class=\"line\">ASCII</span><br><span class=\"line\">HTML</span><br><span class=\"line\">encryption</span><br><span class=\"line\"></span><br><span class=\"line\">会话层：</span><br><span class=\"line\">NetBIOS</span><br><span class=\"line\">AppleTalk</span><br><span class=\"line\">NFS</span><br><span class=\"line\"></span><br><span class=\"line\">传输层：</span><br><span class=\"line\">tcp</span><br><span class=\"line\">udp</span><br><span class=\"line\"></span><br><span class=\"line\">网络层：</span><br><span class=\"line\">IP，IPX</span><br><span class=\"line\"></span><br><span class=\"line\">数据链路层</span><br><span class=\"line\">FR</span><br><span class=\"line\">HDLC</span><br><span class=\"line\">PPP</span><br><span class=\"line\">802.3</span><br><span class=\"line\">ATM</span><br><span class=\"line\"></span><br><span class=\"line\">物理层</span><br><span class=\"line\">RJ45</span><br><span class=\"line\">Ethernet</span><br><span class=\"line\"></span><br><span class=\"line\">TCP/IP</span><br><span class=\"line\">应用层：参考OSI</span><br><span class=\"line\">传输层：TCP,UDP</span><br><span class=\"line\">网络层：ICMP，IGMP</span><br><span class=\"line\">数据链路层：ARP</span><br><span class=\"line\"></span><br><span class=\"line\">你真想混起来将我觉得也没事，估计面试官也分不清楚，我之前一致混起来讲的，面试官听得挺开心，我讲的也挺开心~</span><br><span class=\"line\">毕竟分太细容易把自己埋了，他不问你不说，大家dddd</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">顺带着我就把常见端口写了</span><br><span class=\"line\">http/https tcp 80/443</span><br><span class=\"line\">dns tcp+udp 53</span><br><span class=\"line\">snmp udp 161/162</span><br><span class=\"line\">smtp tcp 25</span><br><span class=\"line\">ftp tcp 20/21</span><br><span class=\"line\">pop3 tcp 110</span><br><span class=\"line\">telnet 23</span><br><span class=\"line\">dhcp 67/68</span><br><span class=\"line\">ssh 22</span><br><span class=\"line\">tftp udp 60</span><br><span class=\"line\">JBOSS  Tomcat 8080</span><br><span class=\"line\">RDP 3389</span><br><span class=\"line\">Oracle 1521</span><br><span class=\"line\">mssql tcp/udp 1433,1434</span><br><span class=\"line\">mysql 3306</span><br><span class=\"line\">samba 139</span><br><span class=\"line\">ladp 389</span><br><span class=\"line\">redis 6379</span><br><span class=\"line\">weblogic 7001</span><br></pre></td></tr></table></figure>\n<h4 id=\"封装解封装长亭\"><a class=\"markdownIt-Anchor\" href=\"#封装解封装长亭\">#</a> 封装解封装 (长亭)</h4>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">应用层，人机交互接口，接收用户输入</span><br><span class=\"line\">表示层，将接收到的数据翻译成二进制数组成的计算机语言，并对数据进行压缩和解压、数据加密和解密等工作</span><br><span class=\"line\">会话层，建立、管理、中止会话。</span><br><span class=\"line\">传输层，为每个数据封装 TCP或UDP 报文头部。 在头部有一个关键的字段信息——端口号，它用于标识上层的协议或应用程序，确保上层应用数据的正常通信。</span><br><span class=\"line\">网络层，上层数据被封装上新的报文头部——IP 头部。 在 IP 头部中有一个关键的字段信息——IP 地址，进行逻辑地址寻址</span><br><span class=\"line\">数据链路层，上层数据被封装一个 MAC 头部，其内部有一个关键的字段信息 ——MAC 地址，在 MAC 头部也同时封装着目标 MAC 地址和源 MAC 地址，进行硬件地址寻址、差错校验等功能。</span><br><span class=\"line\">在物理层，将这些二进制数字组成的比特流转换成电信号在网络中传输。</span><br><span class=\"line\"></span><br><span class=\"line\">在物理层，首先将电信号转换成二进制数据，并将数据送至数据链路层</span><br><span class=\"line\">在数据链路层， 将查看目标 MAC 地址，判断其是否与自己的 MAC 地址吻合，并据此完成后续处理。如果 数据报文的目标 MAC 地址就是自己的 MAC 地址，数据的 MAC 头部将被“拆掉”，并将剩余 的数据送至上一层；如果目标 MAC 地址不是自己的 MAC 地址，对于终端设备来说，它将 会丢弃数据</span><br><span class=\"line\">在网络层与在数据链路层类似，目标 IP 地址将被核实是否与自己的 IP 地址相 同，从而确定是否送至上一层</span><br><span class=\"line\">到了传输层，首先要根据 TCP 头部判断数据段送往哪个应用层协议或应用程序，然后将之前被分组的数据段重组，再送往应用层</span><br><span class=\"line\">会话层，建立、管理、中止会话。</span><br><span class=\"line\">表示层，将接收到的二进制变为应用的数据，并对数据进行压缩和解压、数据加密和解密等工作</span><br><span class=\"line\">在应用层，这些数据将经历复杂的解码过程，以还原发送者所传输的原始信息。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h3 id=\"5ospf相关\"><a class=\"markdownIt-Anchor\" href=\"#5ospf相关\">#</a> 5.OSPF 相关</h3>\n<h4 id=\"ospf负载分担快手\"><a class=\"markdownIt-Anchor\" href=\"#ospf负载分担快手\">#</a> ospf 负载分担 (快手)</h4>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">华为产品文档ospf cost命令原话</span><br><span class=\"line\">当有多条发现协议、开销值、目的地址都相同的路由时，这几条路由就满足负载分担的条件。请根据实际组网情况，通过修改接口开销值来选择是否需要进行负载分担。</span><br></pre></td></tr></table></figure>\n<h4 id=\"需要a-b不负载分担回程不管在哪配开销来回路径不一致有问题吗快手\"><a class=\"markdownIt-Anchor\" href=\"#需要a-b不负载分担回程不管在哪配开销来回路径不一致有问题吗快手\">#</a> 需要 A-&gt;B 不负载分担，回程不管，在哪配开销，来回路径不一致有问题吗（快手）</h4>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在A配，因为A发送时需要查看路由表，只有路由表中没有开销相同的路由才不会负载分担</span><br><span class=\"line\"></span><br><span class=\"line\">路由来回路径不一致虽然还是可以通信，但是可能会出现偶尔访问慢或规律丢包等现象。</span><br><span class=\"line\">因此可考虑配置路由优先级或冗余端口来实现主备。</span><br><span class=\"line\">但对安全设备来说，有影响，可能对应报文会被丢弃。</span><br><span class=\"line\"></span><br><span class=\"line\">华为中fw可以如下操作：</span><br><span class=\"line\">如果出现来回路径不一致情况，不管是在路由模式下，还是在透明模式下，此时默认都是开启的链路状态检测。要解决这个问题，关闭链路状态检测即可，即：</span><br><span class=\"line\">undo firewall session link-state check</span><br></pre></td></tr></table></figure>\n<h4 id=\"单区域网络类型p2p有几种lsa快手\"><a class=\"markdownIt-Anchor\" href=\"#单区域网络类型p2p有几种lsa快手\">#</a> 单区域网络类型 P2P 有几种 LSA (快手)</h4>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">只有1类</span><br></pre></td></tr></table></figure>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221020210537797.png\" alt=\"image-20221020210537797\"></p>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221020210832630.png\" alt=\"image-20221020210832630\"></p>\n<h4 id=\"54lsa常见类型快手\"><a class=\"markdownIt-Anchor\" href=\"#54lsa常见类型快手\">#</a> 5.4LSA 常见类型 (快手)</h4>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1类LSA 每台运行ospf协议的路由器都会产生，用于描述加入到OSPF进程中自身直连链路的状态。有路由和拓扑信息</span><br><span class=\"line\">2类LSA 携带DR的router-id，DR接口子网掩码，伪节点的邻居，单区域p2p是没有2类的，有路由和拓扑信息</span><br><span class=\"line\">3类LSA 在区域间传递LSA，只有路由信息</span><br><span class=\"line\">4类LSA ABR产生，描述了ASBR的位置，类似路由信息</span><br><span class=\"line\">5类LSA 外部LSA，携带重发布的路由信息，只有路由信息</span><br><span class=\"line\">7类LSA NSSA区域引入外部路由时产生</span><br></pre></td></tr></table></figure>\n<h4 id=\"55ospf防环快手\"><a class=\"markdownIt-Anchor\" href=\"#55ospf防环快手\">#</a> 5.5OSPF 防环 (快手)</h4>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">区域内通过spf防环</span><br><span class=\"line\">区域间通过：</span><br><span class=\"line\">\t区域间水平分割(1类，2类优于3类，骨干3类优于非骨干3类)</span><br><span class=\"line\">\t区域设计原则(非骨干必须和骨干直接相连)</span><br><span class=\"line\">\tABR(只有ABR能产生泛洪3类LSA)</span><br><span class=\"line\">区域间防环:</span><br><span class=\"line\">\t5类LSA在整个区域泛洪时link id,adv rtr,type 都不改变</span><br><span class=\"line\">\tASBR同一区域的路由器通过SPF计算出去往ASBR的无环路径，即通过1类2类防环</span><br><span class=\"line\">\tASBR不同区域的路由器通过4类LSA防环，4类防环规则与3类一致</span><br></pre></td></tr></table></figure>\n<h4 id=\"56spf算法快手\"><a class=\"markdownIt-Anchor\" href=\"#56spf算法快手\">#</a> 5.6SPF 算法 (快手)</h4>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">https://blog.csdn.net/qq_57686163/article/details/123466172</span><br><span class=\"line\">这篇文章师傅写的很明白了，我不想写了，摆烂</span><br></pre></td></tr></table></figure>\n<h4 id=\"57drbdr宏杉\"><a class=\"markdownIt-Anchor\" href=\"#57drbdr宏杉\">#</a> 5.7DR，BDR (宏杉)</h4>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">基于链路选择。即在每一条广播型链路或NBMA链路都需要进行DR，BDR选举，BDR可选存在。即在每一条广播型链路或NBMA链路上DR只有一个，BDR如果存在有且只有一个</span><br><span class=\"line\">DR只会从DR的合集当中竞选，BDR只会从BDR的合集当中竞选。如果集合当中有路由器，优先从集合当中竞选。</span><br><span class=\"line\"></span><br><span class=\"line\">DR选举(包含在hello包内)：  1.比较优先级 （范围：0-255，默认优先级为1 ，越大越优）  </span><br><span class=\"line\">2.比较各自的router-id，越大越优</span><br><span class=\"line\"></span><br><span class=\"line\">1.DR抢占是关闭的      </span><br><span class=\"line\">3.优先级范围0-255，数字为0代表不参与选举，默认为1，若两个直连路由器优先级都为0，则不能学习LSA，只能维持邻居关系  </span><br><span class=\"line\">4.先选举BDR ，再升级为DR  (BDR备份路由器，当BDR选举超过40秒后(=dead time),升级为DR，将剩下最优的作为BDR)</span><br><span class=\"line\">当DR BDR选举完成时，会给224.0.0.6发送组播传递LSA，且只有DR和BDR才会接收，DR和BDR在用224.0.0.5发送给所有</span><br></pre></td></tr></table></figure>\n<h4 id=\"58ospf建立邻居\"><a class=\"markdownIt-Anchor\" href=\"#58ospf建立邻居\">#</a> 5.8ospf 建立邻居</h4>\n<blockquote>\n<p>Down: 这是邻居的初始状态，表示没有从邻居收到任何信息。</p>\n<p>Init: 判断邻居参数可以建立邻居后 init。在此状态下，路由器已经从邻居收到了 Hello 报文，但是自己的 router-id 不在所收到的 Hello 报文的邻居列表中，表示尚未与邻居建立双向通信关系，可以称为 one-way。在此状态下的邻居要被包含在自己所发送的 Hello 报文的邻居列表中。</p>\n<p>2-Way: 在此状态下，收到邻居 hello 包，并从 hello 包中发现自己 router-id。两台路由器已确认可以双向通信，邻居关系已经建立；但是还没有建立邻接关系。若发送方收到的 hello 包中有自己 id，可以直接进入 two-way。这是建立邻接关系以前的最高级状态。如果网络为广播网络或者 NBMA 网络则选举 DR/BDR。drother 之间停留此状态，不会进行 LSDB 同步，其他情况会继续进行 LSDB 同步</p>\n<p>exstart 状态，开始发送 DBD 报文。主要完成主从选举，为可靠的 LSDB 同步做准备工作，不会携带任何 LSDB 中 LSA 头部信息</p>\n<p>exchange 主从选举完成后，一旦发送携带 LSA 头部的 DD 报文，则进入 exchange，slave 路由器开始发送携带自身 LSDB 中 LSA 的头部信息的 DBD 报文，并使用</p>\n<p>loading 状态发送 LSR，LSU，LSACK ，LSACK 中会将 LSU 的 Seq 作为自己的 seq，同时携带摘要作为显示确认</p>\n<p>FUll：LSR 重传列表为空，发送和接受 LSACK 报文后，防止同步出现问题。</p>\n<p>attempt— 过度状态，在某些不能发送的 hello 包的网络中，不能主动建立邻居。通过单播邻居方式建立，需要选 DR 时，等待选举状态为 attempt 状态</p>\n<p>停留 attempt 状态说明单播指邻居邻居指错</p>\n</blockquote>\n<h3 id=\"6bgp相关\"><a class=\"markdownIt-Anchor\" href=\"#6bgp相关\">#</a> 6.BGP 相关</h3>\n<h4 id=\"61origin属性network和import都是什么属性优先级origin控制选路快手\"><a class=\"markdownIt-Anchor\" href=\"#61origin属性network和import都是什么属性优先级origin控制选路快手\">#</a> 6.1origin 属性，network 和 import 都是什么属性，优先级，origin 控制选路 (快手)</h4>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">定义路径信息的来源。描述该路由是用什么方式成为BGP路由的，公认必尊</span><br><span class=\"line\">1.将IGP路由network到BGP中     i</span><br><span class=\"line\">2.将EGP路由import到BPG中      e</span><br><span class=\"line\">3.将IGP路由import到BGP中      ?</span><br><span class=\"line\">选路时origin  i &gt; e &gt; ?</span><br><span class=\"line\">手动汇总路由继承明细路由中优先级最低起源属性，自动汇总origin全部为incomplete(?)</span><br></pre></td></tr></table></figure>\n<h4 id=\"bgp选路中科闻歌绿盟\"><a class=\"markdownIt-Anchor\" href=\"#bgp选路中科闻歌绿盟\">#</a> bgp 选路（中科闻歌，绿盟）</h4>\n<blockquote>\n<p>1. 优选协议首选值 (PrefVal) 最高的路由</p>\n<p>2. 优选本地优先级 (Local_Pref) 最高的路由</p>\n<p>3. 优选本地生成的路由，解决路由冲突，<strong>agg &gt; auto &gt; network &gt; import &gt; peer</strong></p>\n<p>4. 优选 AS 路径 (AS_Path）最短的路由</p>\n<p>5. 比较 Origin 属性，依次优选 Origin 类型为 IGP、EGP、Incomplete 的路由</p>\n<p>6. 优选 MED 值最低的路由</p>\n<p>7. 优选从 EBGP 邻居学来的路由 (EBGP 路由优先级高于 IBGP 路由)</p>\n<p>8. 优选到下一跳 IGP Metric 较小的路由</p>\n<p>----------------------------</p>\n<p>9. 优选 Cluster_List 最短的路由，没有簇列表簇列表为空，没有簇列表一定更优</p>\n<p>10. 优选起源 ID，越小越优</p>\n<p>11. 优选 Router lD 最小的路由器发布的路由</p>\n<p>12. 比较对等体的 IP Address，优选从具有较小 IP Address 的对等体学来的路由</p>\n<p>简单来说</p>\n<p>P L L A O M E N   漂亮老男人</p>\n<p>Pref LocalPre Local AS origin MED EBGP next_cost</p>\n</blockquote>\n<h3 id=\"7双点双向重发布快手\"><a class=\"markdownIt-Anchor\" href=\"#7双点双向重发布快手\">#</a> 7. 双点双向重发布 (快手)</h3>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在多点双向重发布中，若A协议的优先级大于（次）B协议，此时若将A协议通过一台ASBR引入到B协议时，那此优先级会降低（变优），会导致另一台ASBR路由表的生成，此时另一台ASBR再次将B往A协议重发布时，原先A协议的路由会再次回到A协议中--路由回馈</span><br><span class=\"line\">解决方案:将重发布进来的路由优先级改高--Cisco提出，在Cisco的EIGRP协议中，内部路由优先级90，外部170。所以，华为设备因为不支持EIGRP，仅支持OSPF，所以借鉴了Cisco的做法--在华为中，OSPF内部优先级10，外部150</span><br><span class=\"line\">OSPF协议学习OSPF网络内的所有环回接口网段时，学习到的都是32为的主机路由，但是将本设备工作在OSPF的直连接口重发布时时原本的掩码，</span><br><span class=\"line\">所以可能会导致在重发布时同一条路由条目变成不同的掩码发布到另一协议</span><br><span class=\"line\">解决方案：</span><br><span class=\"line\">1）修改环回接口掩码直接为32位 </span><br><span class=\"line\">2）修改环回接口的OSPF工作的网络类型</span><br><span class=\"line\">在进行多点双向重发布时，由于协议之间不兼容，因此原路由的度量值进入新协议时，会被起始度量代替，所以存在选路不佳的问题</span><br><span class=\"line\">解决方案：需要人为的干涉选路---路由策略技术</span><br><span class=\"line\">注意：BGP与OSPF或其他协议做多点多向重发布，会出现瞬时环路。</span><br><span class=\"line\">就是BGP收敛慢，OSPF收敛快，两个协议启动会存在时差，在这个时差内协议的边界路由器是没有BGP协议的路由，那么在协议边界路由上就存在路由黑洞</span><br></pre></td></tr></table></figure>\n<h3 id=\"8httphttps相关问题\"><a class=\"markdownIt-Anchor\" href=\"#8httphttps相关问题\">#</a> 8.http/https 相关问题</h3>\n<h4 id=\"http状态码汉得曙光\"><a class=\"markdownIt-Anchor\" href=\"#http状态码汉得曙光\">#</a> http 状态码 (汉得，曙光)</h4>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">常见状态码          </span><br><span class=\"line\">200\t请求成功</span><br><span class=\"line\">301 永久重定向</span><br><span class=\"line\">302 临时重定向</span><br><span class=\"line\">400 请求错误，通常是访问的域名未绑定引起</span><br><span class=\"line\">403 禁止访问</span><br><span class=\"line\">404 请求的内容未找到或已删除</span><br><span class=\"line\">500 服务器端程序错误</span><br><span class=\"line\">502 网关无响应</span><br><span class=\"line\">503 服务器端临时错误</span><br><span class=\"line\">504\t网关超时</span><br><span class=\"line\">https://seo.juziseo.com/doc/http_code/</span><br></pre></td></tr></table></figure>\n<h4 id=\"访问网页过程信锐汉得\"><a class=\"markdownIt-Anchor\" href=\"#访问网页过程信锐汉得\">#</a> 访问网页过程 (信锐，汉得)</h4>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.首先在浏览器地址栏中输入URL或者域名。</span><br><span class=\"line\">2.电脑开始域名解析：</span><br><span class=\"line\">看查找IP是否是本机。不是再去查询浏览器缓存，本机hosts文件，如果有对应的IP则进行反馈，然后进行下一步。如果本机Hosts文件不含有，则本机向发出一个DNS请求到本地DNS服务器。</span><br><span class=\"line\">DNS请求到达本地DNS服务器之后，本地DNS服务器会首先查询它的缓存记录，如果缓存中有此条记录，就可以直接返回结果。如果没有，本地DNS服务器还要向DNS根服务器进行查询。</span><br><span class=\"line\">根DNS服务器没有记录具体的域名和IP地址的对应关系，而是告诉本地DNS服务器，你可以到域服务器上去继续查询，并给出域服务器的地址。</span><br><span class=\"line\">最后，本地DNS服务器向域名的解析服务器发出请求，这时就能收到一个域名和IP地址对应关系，本地DNS服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问。</span><br><span class=\"line\">网址真正的解析过程为:  . -&gt; .com -&gt; Microsoft.com. -&gt; www.Microsoft.com. </span><br><span class=\"line\">3.进行tcp三次握手</span><br><span class=\"line\">上面八股文你有写过，自己看吧</span><br><span class=\"line\">4.http/https请求和返回</span><br><span class=\"line\">HTTP报文是包裹在TCP报文中发送的，服务器端收到TCP报文时会解包提取出HTTP报文。</span><br><span class=\"line\">https = http + tls，具体下面有写，这边就不写了，开摆</span><br><span class=\"line\">浏览器对服务器发出HTTP请求报文</span><br><span class=\"line\">发送HTTP请求的过程就是构建HTTP请求报文并通过TCP协议中发送到服务器指定端口(HTTP协议80/8080, HTTPS协议443)。HTTP请求报文是由三部分组成: 请求行, 请求报头和请求正文。</span><br><span class=\"line\">服务器处理请求并返回HTTP响应报文</span><br><span class=\"line\">后端从在固定的端口接收到TCP报文开始，这一部分对应于编程语言中的socket。它会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成HTTP Request对象，供上层使用。HTTP响应报文也是由三部分组成: 状态码, 响应报头和响应报文。</span><br><span class=\"line\">5.浏览器渲染页面</span><br><span class=\"line\">浏览器在收到HTML,CSS,JS文件后，浏览器是一个边解析边渲染的过程。首先浏览器解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。</span><br></pre></td></tr></table></figure>\n<h4 id=\"https长亭\"><a class=\"markdownIt-Anchor\" href=\"#https长亭\">#</a> https (长亭)</h4>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTPS是一种透过计算机网络进行安全通信的传输协议。HTTPS 经由 HTTP 进行通信，但利用 SSL/TLS 来加密数据包。</span><br><span class=\"line\">https = http + tls</span><br><span class=\"line\">tls 位于传输层上层</span><br><span class=\"line\">HTTPS在传输数据之前需要客户端与服务器进行一个握手(TLS/SSL握手)，在握手过程中将确立双方加密传输数据的密码信息。TLS/SSL使用了非对称加密，对称加密以及hash等。</span><br><span class=\"line\">HTTPS 默认工作在 TCP 协议443端口，它的工作流程一般如以下方式：</span><br><span class=\"line\">1、TCP 三次同步握手</span><br><span class=\"line\">2、客户端验证服务器数字证书</span><br><span class=\"line\">3、DH 算法协商对称加密算法的密钥、hash 算法的密钥</span><br><span class=\"line\">4、SSL 安全加密隧道协商完成</span><br><span class=\"line\">5、网页以加密的方式传输，用协商的对称加密算法和密钥加密，保证数据机密性；用协商的hash算法进行数据完整性保护，保证数据不被篡改。</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>1、客户端发起 HTTPS 请求</strong></p>\n<p>就是用户在浏览器里输入一个 https 网址，然后连接到 server 的 443 端口。</p>\n<p><strong>2、服务端的配置</strong></p>\n<p>采用 HTTPS 协议的服务器必须要有一套<em>数字证书</em>，可以自己制作，也可以向组织申请，区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面 (startssl 就是个不错的选择，有 1 年的免费服务)。</p>\n<p><em>这套证书其实就是一对公钥和私钥</em>，如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。</p>\n<p><strong>3、传送证书</strong></p>\n<p>这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。</p>\n<p><strong>4、客户端解析证书</strong></p>\n<p>这部分工作是有客户端的 TLS 来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。</p>\n<p>如果证书没有问题，那么就生成一个随机值，然后用证书对该随机值进行加密，就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。</p>\n<p><strong>5、传送加密信息</strong></p>\n<p>这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。</p>\n<p><strong>6、服务端解密信息</strong></p>\n<p>服务端用私钥解密后，得到了客户端传过来的随机值 (私钥)，然后把内容通过该值进行对称加密，所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。</p>\n<p><strong>7、传输加密后的信息</strong></p>\n<p>这部分信息是服务段用私钥加密后的信息，可以在客户端被还原。</p>\n<p><strong>8、客户端解密信息</strong></p>\n<p>客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容，整个过程第三方即使监听到了数据，也束手无策。</p>\n</blockquote>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221022105328092.png\" alt=\"image-20221022105328092\"></p>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cucnVub29iLmNvbS93M2Nub3RlL2h0dHAtdnMtaHR0cHMuaHRtbA==\">HTTP 与 HTTPS 的区别 | 菜鸟教程 (runoob.com)</span></p>\n<h4 id=\"httphttps区别没人问我自己问着玩\"><a class=\"markdownIt-Anchor\" href=\"#httphttps区别没人问我自己问着玩\">#</a> http/https 区别 (没人问，我自己问着玩)</h4>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HTTP 明文传输，数据都是未加密的，安全性较差，HTTPS（SSL+HTTP） 数据传输过程是加密的，安全性较好。</span><br><span class=\"line\"></span><br><span class=\"line\">使用 HTTPS 协议需要到 CA（Certificate Authority，数字证书认证机构） 申请证书，一般免费证书较少，因而需要一定费用。证书颁发机构如：Symantec、Comodo、GoDaddy 和 GlobalSign 等。</span><br><span class=\"line\"></span><br><span class=\"line\">HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。</span><br><span class=\"line\"></span><br><span class=\"line\">http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80，后者是 443。</span><br><span class=\"line\"></span><br><span class=\"line\">HTTPS 其实就是建构在 SSL/TLS 之上的 HTTP 协议，所以，要比较 HTTPS 比 HTTP 要更耗费服务器资源。</span><br></pre></td></tr></table></figure>\n<h4 id=\"http1011和20区别长亭\"><a class=\"markdownIt-Anchor\" href=\"#http1011和20区别长亭\">#</a> http1.0,1,1 和 2.0 区别 (长亭)</h4>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.1.0和1.1之间的区别</span><br><span class=\"line\">1.缓存策略:</span><br><span class=\"line\">http1.0的缓存策略主要是依赖header中的If-Modiified-Since,Expire(到期)</span><br><span class=\"line\">http1.1的缓存策略要比http1.0略多,例如 Entity tag(实体标签), If-Unmodified-Since, If-Match, If-None-Match等.</span><br><span class=\"line\">2. 宽带和网络连接优化:</span><br><span class=\"line\">http1.0中会存在一些性能浪费,比如我们的只需要对象中的一部分,但是每次请求返回的却是整个对象,这无疑造成了性能的损害</span><br><span class=\"line\">http1.1则不然,它可以通过在请求头处设置range头域,就可以返回请求资源的某一部分,也就是返回码为206(Partial Content)的时候,这对于性能优化很有必要.</span><br><span class=\"line\">这里所谓的请求资源的一部分,也就是大家常说的断点续传</span><br><span class=\"line\">关于断点续传的应用场景,例如用户需要下载一个大文件,最佳的方式是将这个大文件分割成几部分,然后由多个进程同时进行.</span><br><span class=\"line\">这个时候,我们可以在请求头中设置range字段,来规定分割的byte数范围.</span><br><span class=\"line\">而服务端会给客户端返回一个包含着content-range的响应头,来对应相应的分割byte数范围</span><br><span class=\"line\">请求头中:</span><br><span class=\"line\">Range: bytes=0-801 // 一般请求下载整个文件是bytes=0- 或不用这个头</span><br><span class=\"line\">响应头中:</span><br><span class=\"line\">Content-Range: bytes 0-800/801 //801:文件总大小</span><br><span class=\"line\">3. 新增部分错误通知:</span><br><span class=\"line\">http1.1版本新增了24个错误状态响应码,比如</span><br><span class=\"line\">409(Conflict)表示: 请求的资源与当前的状态发生冲突</span><br><span class=\"line\">410(Gone)表示服务器上某个资源被永久性的删除了</span><br><span class=\"line\">4.Host头处理:</span><br><span class=\"line\">http1.0中默认每台服务器都绑定唯一的一个IP地址,所以请求消息中url并没有传递主机名,也就是hostname.</span><br><span class=\"line\">http1.1中请求消息和响应消息都支持Host头域,而且,如果我们不传这个字段还会报一个400(bad request)的状态码</span><br><span class=\"line\">通用头域:</span><br><span class=\"line\">Cache-Control: 缓存头域 =&gt; 常见值为no-cache(不允许缓存), no-store(无论请求还是响应均不允许缓存), max-age(规定可以客户端可以接受多长生命期的数据)</span><br><span class=\"line\">Keep-Alive: 使得服务端和客户端的链接长时间有效</span><br><span class=\"line\">Date: 信息发送的时间</span><br><span class=\"line\">Host: 请求资源的主机IP和端口号</span><br><span class=\"line\">Range: 请求资源的某一部分</span><br><span class=\"line\">User-Agent: 发出请求的用户的信息(鉴权)</span><br><span class=\"line\">5. 长连接:</span><br><span class=\"line\">http1.1支持长连接和请求的流水线(pipelining),在一个TCP链接上可以传送多个http请求和响应.这样就不用多次建立和关闭TCP连接了.</span><br><span class=\"line\"></span><br><span class=\"line\">2.1.x和2.0的区别</span><br><span class=\"line\">http1的解析是基于文本协议的各式解析,而http2.0的协议解析是二进制格式,更加的强大</span><br><span class=\"line\">多路复用(Mutiplexing) : 一个连接上可以有多个request,且可以随机的混在一起,每个不同的request都有对应的id,服务端可以通过request_id来辨别,大大加快了传输速率</span><br><span class=\"line\">header压缩: http1.x中的header需要携带大量信息.而且每次都要重复发送.http2.0使用encode来减少传输的header大小.而且客户端和服务端可以各自缓存(cache)一份header filed表,避免了header的重复传输,还可以减少传输的大小.</span><br><span class=\"line\">服务端推送(server push): 可以通过解析html中的依赖,只能的返回所需的其他文件(css或者js等),而不用再发起一次请求.</span><br><span class=\"line\">Keep-Alive：</span><br><span class=\"line\">Keep-Alive 是使用同一个 TCP 连接来发送和接收多个 HTTP 请求/应答，而不是为每一个新的请求/应答打开新的连接的方法。我们知道 HTTP 协议采用“请求-应答”模式，当使用普通模式，即非 Keep-Alive 模式时，每个请求/应答客户和服务器都要新建一个连接，完成 之后立即断开连接（ HTTP 协议为无连接的协议）；当使用 Keep-Alive 模式（又称持久连接）时，Keep-Alive 功能使客户端到服 务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive 功能避免了建立或者重新建立连接。</span><br><span class=\"line\"></span><br><span class=\"line\">总结：</span><br><span class=\"line\">HTTP1.0</span><br><span class=\"line\">浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接</span><br><span class=\"line\">HTTP1.1</span><br><span class=\"line\">引入了持久连接，即TCP连接默认不关闭，可以被多个请求复用</span><br><span class=\"line\">在同一个TCP连接里面，客户端可以同时发送多个请求</span><br><span class=\"line\">虽然允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的，服务器只有处理完一个请求，才会接着处理下一个请求。如果前面的处理需要时间特别长特别慢，后面的请求只能排队等着</span><br><span class=\"line\">新增了一些请求方法put、delete、options</span><br><span class=\"line\">新增了一些请求头和响应头</span><br><span class=\"line\">HTTP2.0</span><br><span class=\"line\">采用二进制格式而非文本格式</span><br><span class=\"line\">完全多路复用，而非有序并阻塞的、只需一个连接即可实现并行</span><br><span class=\"line\">使用报头压缩，降低开销</span><br><span class=\"line\">服务器可以推送</span><br><span class=\"line\">链接：https://juejin.cn/post/7089068858241515551</span><br></pre></td></tr></table></figure>\n<h4 id=\"http报文组成长亭-头行\"><a class=\"markdownIt-Anchor\" href=\"#http报文组成长亭-头行\">#</a> http 报文组成 (长亭) 头行</h4>\n<blockquote>\n<p>HTTP 请求报文是由三部分组成: <strong>请求行</strong>，<strong>请求报头</strong>和<strong>请求正文</strong>。</p>\n<p>后端从在固定的端口接收到 TCP 报文开始，这一部分对应于编程语言中的 socket。它会对 TCP 连接进行处理，对 HTTP 协议进行解析，并按照报文格式进一步封装成 HTTP Request 对象，供上层使用。</p>\n<p>HTTP 响应报文也是由三部分组成: <strong>状态码</strong>，<strong>响应报头</strong>和<strong>响应报文</strong>。</p>\n</blockquote>\n<img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/aHR0cDovL2RsLml0ZXllLmNvbS91cGxvYWQvYXR0YWNobWVudC8wMDY5LzM0NTEvNDEyYjQ0NTEtMjczOC0zZWJjLWIxZjYtYTBjYzEzYjk2OTdiLmpwZw\" alt=\"img\" style=\"zoom:80%;\" />\n<blockquote>\n<p>①是请求方法，GET 和 POST 是最常见的 HTTP 方法，除此以外还包括 DELETE、HEAD、OPTIONS、PUT、TRACE。不过，当前的大多数浏览器只支持 GET 和 POST</p>\n<p>②为请求对应的 URL 地址，它和报文头的 Host 属性组成完整的请求 URL。</p>\n<p>③是协议名称及版本号。</p>\n<p>④是 HTTP 的报文头，报文头包含若干个属性，格式为 “属性名：属性值”，服务端据此获取客户端的信息。</p>\n<p>⑤是报文体，它将一个页面表单中的组件值通过 param1=value1&amp;m2=value2 的键值对形式编码成一个格式化串，它承载多个请求参数的数据。不但报文体可以传递请求参数，请求 URL 也可以通过类似于 “/chapter15/user.html? param1=value1&amp;m2=value2” 的方式传递请求参数。</p>\n</blockquote>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/aHR0cDovL2RsLml0ZXllLmNvbS91cGxvYWQvYXR0YWNobWVudC8wMDY5LzM0ODcvY2RjNGRiYmItZjk4ZS0zMWQ1LTgyNzAtM2MzN2JmMWM1NGU1LmpwZw\" alt=\"img\"></p>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/aHR0cDovL2RsLml0ZXllLmNvbS91cGxvYWQvYXR0YWNobWVudC8wMDY5LzM0OTIvYmRkYjAwYjYtYTNlMS0zMTEyLWE0ZjQtNGIzY2I4Njg3YzcwLmpwZw\" alt=\"img\"></p>\n<blockquote>\n<p>①报文协议及版本；<br>\n②状态码及状态描述；<br>\n③响应报文头，也是由多个属性组成；<br>\n④响应报文体，服务器返回给浏览器的文本信息，通常 HTML, CSS, JS, 图片等文件就放在这一部分。</p>\n</blockquote>\n<h4 id=\"get和post区别汉得\"><a class=\"markdownIt-Anchor\" href=\"#get和post区别汉得\">#</a> get 和 post 区别（汉得）</h4>\n<blockquote>\n<p>Form 中的 get 和 post 方法，在数据传输过程中分别对应了 HTTP 协议中的 GET 和 POST 方法。二者主要区别如下：</p>\n<ul>\n<li>1、Get 是用来从服务器上获得数据，而 Post 是用来向服务器上传递数据。</li>\n<li>2、Get 将表单中数据的按照 variable=value 的形式，添加到 action 所指向的 URL 后面，并且两者使用 “?” 连接，而各个变量之间使用 “&amp;” 连接；Post 是将表单中的数据放在 form 的数据体中，按照变量和值相对应的方式，传递到 action 所指向 URL。</li>\n<li>3、Get 是不安全的，因为在传输过程，数据被放在请求的 URL 中，而如今现有的很多服务器、代理服务器或者用户代理都会将请求 URL 记录到日志文件中，然后放在某个地方，这样就可能会有一些隐私的信息被第三方看到。另外，用户也可以在浏览器上直接看到提交的数据，一些系统内部消息将会一同显示在用户面前。Post 的所有操作对用户来说都是不可见的。</li>\n<li>4、Get 传输的数据量小，这主要是因为受 URL 长度限制；而 Post 可以传输大量的数据，所以在上传文件只能使用 Post（当然还有一个原因，将在后面的提到）。</li>\n<li>5、Get 限制 Form 表单的数据集的值必须为 ASCII 字符；而 Post 支持整个 ISO10646 字符集。</li>\n<li>6、Get 是 Form 的默认方法。</li>\n</ul>\n<p>使用 Post 传输的数据，可以通过设置编码的方式正确转化中文；而 Get 传输的数据却没有变化。在以后的程序中，我们一定要注意这一点。</p>\n</blockquote>\n<h4 id=\"session和cookie区别汉得\"><a class=\"markdownIt-Anchor\" href=\"#session和cookie区别汉得\">#</a> session 和 cookie 区别（汉得）</h4>\n<blockquote>\n<p>1.Cookie 的工作原理<br>\n（1）浏览器端第一次发送请求到服务器端</p>\n<p>（2）服务器端创建 Cookie，该 Cookie 中包含用户的信息，然后将该 Cookie 发送到浏览器端</p>\n<p>（3）浏览器端再次访问服务器端时会携带服务器端创建的 Cookie</p>\n<p>（4）服务器端通过 Cookie 中携带的数据区分不同的用户</p>\n<p>————————————————</p>\n<p>2.Session 的工作原理</p>\n<p>（1）浏览器端第一次发送请求到服务器端，服务器端创建一个 Session，同时会创建一个特殊的 Cookie（name 为 JSESSIONID 的固定值，value 为 session 对象的 ID），然后将该 Cookie 发送至浏览器端</p>\n<p>（2）浏览器端发送第 N（N&gt;1）次请求到服务器端，浏览器端访问服务器端时就会携带该 name 为 JSESSIONID 的 Cookie 对象</p>\n<p>（3）服务器端根据 name 为 JSESSIONID 的 Cookie 的 value (sessionId), 去查询 Session 对象，从而区分不同用户。</p>\n<p>name 为 JSESSIONID 的 Cookie 不存在（关闭或更换浏览器），返回 1 中重新去创建 Session 与特殊的 Cookie</p>\n<p>name 为 JSESSIONID 的 Cookie 存在，根据 value 中的 SessionId 去寻找 session 对象</p>\n<p>value 为 SessionId 不存在 **（Session 对象默认存活 30 分钟）**，返回 1 中重新去创建 Session 与特殊的 Cookie</p>\n<p>value 为 SessionId 存在，返回 session 对象</p>\n<p>————————————————</p>\n<p>(1) cookie 数据存放在客户的浏览器上，session 数据放在服务器上，但是服务端的 session 的实现对客户端的 cookie 有依赖关系的；</p>\n<p>(2) cookie 不是很安全，别人可以分析存放在本地的 COOKIE 并进行 COOKIE 欺骗，如果主要考虑到安全应当使用 session</p>\n<p>(3) session 会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，如果主要考虑到减轻服务器性能方面，应当使用 COOKIE</p>\n<p>(4) 单个 cookie 在客户端的限制是 3K，就是说一个站点在客户端存放的 COOKIE 不能 3K。</p>\n<p>(5) 所以：将登陆信息等重要信息存放为 SESSION; 其他信息如果需要保留，可以放在 COOKIE 中</p>\n</blockquote>\n<h3 id=\"9一些linux命令\"><a class=\"markdownIt-Anchor\" href=\"#9一些linux命令\">#</a> 9. 一些 linux 命令</h3>\n<h4 id=\"0liunx查看内核版本发行版特斯拉茄子\"><a class=\"markdownIt-Anchor\" href=\"#0liunx查看内核版本发行版特斯拉茄子\">#</a> 0.Liunx 查看内核版本，发行版 (特斯拉，茄子)</h4>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.</span><br><span class=\"line\">[root@VM-16-11-centos ~]# uname -r</span><br><span class=\"line\">3.10.0-1160.45.1.el7.x86_64</span><br><span class=\"line\">//3 –内核版本   10 –重大修订  0 –轻微修订  1160 –错误修复</span><br><span class=\"line\">2.</span><br><span class=\"line\">[root@VM-16-11-centos ~]# uname -a</span><br><span class=\"line\">Linux VM-16-11-centos 3.10.0-1160.45.1.el7.x86_64 #1 SMP Wed Oct 13 17:20:51 UTC 2021 x86_64 x86_64 x86_64 GNU/Linux</span><br><span class=\"line\">Linux –内核名称。 如果在BSD或macOS上运行相同的命令，结果将有所不同。</span><br><span class=\"line\">VM-16-11-centos –主机名</span><br><span class=\"line\">3.10.0-1160.45.1.el7c –内核版本</span><br><span class=\"line\">#1 SMP Wed Oct 13 17:20:51 UTC 2021 – 这意味着Ubuntu编译了3.10.0-1160.45.1.el7 1次。最后的编译时间戳也在那里。</span><br><span class=\"line\">x86_64 –机器架构</span><br><span class=\"line\">x86_64 –处理器架构</span><br><span class=\"line\">x86_64 –操作系统体系结构（您可以在64位处理器上运行32位OS）</span><br><span class=\"line\">GNU/Linux –操作系统（不，它不会显示发行名称）</span><br><span class=\"line\">3.</span><br><span class=\"line\">[root@VM-16-11-centos ~]# cat /proc/version</span><br><span class=\"line\">Linux version 3.10.0-1160.45.1.el7.x86_64 (mockbuild@kbuilder.bsys.centos.org) (gcc version 4.8.5 20150623 (Red Hat 4.8.5-44) (GCC) ) #1 SMP Wed Oct 13 17:20:51 UTC 2021</span><br><span class=\"line\">4.</span><br><span class=\"line\">[root@VM-16-11-centos ~]# dmesg | grep Linux</span><br><span class=\"line\">[    0.000000] Linux version 3.10.0-1160.45.1.el7.x86_64 (mockbuild@kbuilder.bsys.centos.org) (gcc version 4.8.5 20150623 (Red Hat 4.8.5-44) (GCC) ) #1 SMP Wed Oct 13 17:20:51 UTC 2021</span><br><span class=\"line\"></span><br><span class=\"line\">Ubuntu 完整的桌面 Linux 操作系统</span><br><span class=\"line\">Fedora 是商业版RedHat的上游。</span><br><span class=\"line\">Debian 应用程序最丰富的 Linux 发行版。</span><br><span class=\"line\">openSUSE 成为最简单易用、最广泛的发行版</span><br><span class=\"line\">kali dddd</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"crontab-的含义茄子\"><a class=\"markdownIt-Anchor\" href=\"#crontab-的含义茄子\">#</a> crontab * 的含义 (茄子)</h4>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Example of job definition:</span><br><span class=\"line\"># .---------------- minute (0 - 59)</span><br><span class=\"line\"># |  .------------- hour (0 - 23)</span><br><span class=\"line\"># |  |  .---------- day of month (1 - 31)</span><br><span class=\"line\"># |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...</span><br><span class=\"line\"># |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat</span><br><span class=\"line\"># |  |  |  |  |</span><br><span class=\"line\"># *  *  *  *  * user-name  command to be executed</span><br><span class=\"line\"></span><br><span class=\"line\">vim /etc/crontab</span><br><span class=\"line\">crontab -u root -e</span><br><span class=\"line\">crontab -u root -l</span><br></pre></td></tr></table></figure>\n<h4 id=\"查看linux文件夹大小茄子\"><a class=\"markdownIt-Anchor\" href=\"#查看linux文件夹大小茄子\">#</a> 查看 linux 文件夹大小 (茄子)</h4>\n<blockquote>\n<p>先来说明一件事：</p>\n<p>drwxr-xr-x   5 root root 4.0K Apr  5  2022 src<br>\ndrwxr-xr-x   2 www  www  4.0K Apr  5  2022 maomao</p>\n<ul>\n<li>文件储存在硬盘上，硬盘的最小存储单位叫做 “扇区”（Sector）。每个扇区储存 512 字节（相当于 0.5KB）。</li>\n<li>操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个 “块”（block）。这种由多个扇区组成的 “块”，是文件存取的最小单位。“块” 的大小，最常见的是 4KB，即连续八个 sector 组成一个 block。</li>\n<li>文件数据都储存在 “块” 中，那么很显然，我们还必须找到一个地方储存文件的元信息，比如文件的创建者、文件的创建日期、文件的大小等等。这种储存文件元信息的区域就叫做 inode，中文译名为 “索引节点”。</li>\n<li>每一个文件都有对应的 inode，里面包含了与该文件有关的一些信息。</li>\n</ul>\n<p>而 Linux 系统中，目录（directory）也是一种文件。打开目录，实际上就是打开目录文件。目录文件的结构非常简单，就是一系列目录项（dirent）的列表。每个目录项，由两部分组成：所包含文件的文件名，以及该文件名对应的 inode 号码。</p>\n<p><strong>所以 ls -al 命令实际显示的就是目录文件的大小。又因为 OS 定义的文件最小存取单位 “块”（block）是 4KB，所以目录一般显示为 4096B。</strong></p>\n</blockquote>\n<p>[<span class=\"exturl\" data-url=\"aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vaWlpaWhlci9wLzg1MTEzNTEuaHRtbA==\">svc] 为何 linux ext4 文件系统目录默认大小是 4k? - _毛台 - 博客园 (cnblogs.com)</span></p>\n<img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/806469-20180305205644145-2050317113.png\" alt=\"img\" style=\"zoom:67%;\" />\n<blockquote>\n<p>[lighthouse@VM-16-11-centos ]$ du -h -d 0 sqllab/<br>\n9.2M    sqllab/</p>\n<ol>\n<li>-h , 简单可读的现实大小，自动判断 B,K,M,G…</li>\n<li>-d 0 , 现实列表深度为 0，就是只现实.kde 目录的占用，如果 - d 1 会显示第一级文件的大小，以此类推</li>\n</ol>\n<p>du -sh 命令，可查看当前文件夹的总大小</p>\n<p>du -h --max-depth=1<br>\n9.2M    ./sqllab<br>\n32K     ./maomao<br>\n59M     ./wordpress<br>\n199M    ./besides<br>\n13M     ./src<br>\n5.6M    ./sqli<br>\n223M    ./vulhub<br>\n377M    ./keshe<br>\n44M     ./html<br>\n942M    .</p>\n</blockquote>\n<h4 id=\"分区挂载过程茄子\"><a class=\"markdownIt-Anchor\" href=\"#分区挂载过程茄子\">#</a> 分区挂载过程 (茄子)</h4>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">（1）虚拟机添加硬盘</span><br><span class=\"line\"> fdisk -l</span><br><span class=\"line\">（2）分区</span><br><span class=\"line\">fdisk /dev/sdb</span><br><span class=\"line\">e 即分为逻辑分区，按 p 即分为主分区</span><br><span class=\"line\">+1024m</span><br><span class=\"line\">（3）格式化</span><br><span class=\"line\">mkfs -t ext3 -c /dev/sdb1mkfs -t ext3 -c /dev/sdb1</span><br><span class=\"line\">（4）挂载</span><br><span class=\"line\">mount /dev/sdb1 /mnt</span><br><span class=\"line\">（5）设置可以自动挂载</span><br><span class=\"line\">vim /etc/fstab</span><br></pre></td></tr></table></figure>\n<h4 id=\"查看历史命令查看自己的和别人的深信服\"><a class=\"markdownIt-Anchor\" href=\"#查看历史命令查看自己的和别人的深信服\">#</a> 查看历史命令，查看自己的和别人的 (深信服)</h4>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">history</span><br><span class=\"line\">history命令后面可以加选项：</span><br><span class=\"line\">-c：清空历史命令（包括缓存和文件）</span><br><span class=\"line\">-w：把缓存中的历史命令写入历史命令保存文件~/.bash_history（显然每个用户有自己的文件）</span><br><span class=\"line\">-r\t将命令历史文件中的内容读入到目前shell的history记忆中【就是按↑能翻到】</span><br><span class=\"line\">数字#\t列出最近的#条命令</span><br><span class=\"line\"></span><br><span class=\"line\">历史命令最多可以保存1000条，可以在/etc/profile中进行修改：</span><br><span class=\"line\">source /etc/profile使环境变量生效。</span><br><span class=\"line\">history -c 只能清除history命令查看的，不能清除.bash_history文件中的，需要自己手动删除</span><br><span class=\"line\"></span><br><span class=\"line\">查看别人的，去别人家目录看.bash_history</span><br><span class=\"line\"></span><br><span class=\"line\">查看history时，还能看执行时间</span><br><span class=\"line\">vim /etc/profile</span><br><span class=\"line\">export HISTTIMEFORMAT=&quot;%Y-%m-%d %H:%M:%S &quot;</span><br></pre></td></tr></table></figure>\n<h4 id=\"定时任务有哪些宏杉\"><a class=\"markdownIt-Anchor\" href=\"#定时任务有哪些宏杉\">#</a> 定时任务有哪些 (宏杉)</h4>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">crontab //前面讲过</span><br><span class=\"line\">at 一次性任务</span><br><span class=\"line\">at +时间</span><br><span class=\"line\">atq</span><br><span class=\"line\">atrm jobid</span><br><span class=\"line\">at 10:00      #输入“at  时间”；开始设置at   ，支持am、pm           </span><br><span class=\"line\">at&gt; touch /home/cjk      #输入任务内容</span><br><span class=\"line\">at&gt; echo &quot;hello&quot; &gt;&gt; /home/cjk&lt;EOT&gt; </span><br></pre></td></tr></table></figure>\n<h4 id=\"linux启动过程宏杉\"><a class=\"markdownIt-Anchor\" href=\"#linux启动过程宏杉\">#</a> linux 启动过程 (宏杉)</h4>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Linux系统的启动过程并不是大家想象中的那么复杂，其过程可以分为5个阶段：</span><br><span class=\"line\"></span><br><span class=\"line\">内核的引导。</span><br><span class=\"line\">\t当计算机打开电源后，首先是BIOS开机自检，按照BIOS中设置的启动设备（通常是硬盘）来启动。</span><br><span class=\"line\">\t操作系统接管硬件以后，首先读入 /boot 目录下的内核文件。</span><br><span class=\"line\">运行 init。</span><br><span class=\"line\">\tinit 进程是系统所有进程的起点，你可以把它比拟成系统所有进程的老祖宗，没有这个进程，系统中任何进程都不会启动。</span><br><span class=\"line\">\tinit 程序首先是需要读取配置文件 /etc/inittab。</span><br><span class=\"line\">\t运行级别</span><br><span class=\"line\">\t\t许多程序需要开机启动。它们在Windows叫做&quot;服务&quot;（service），在Linux就叫做&quot;守护进程&quot;（daemon）。</span><br><span class=\"line\">\t\tinit进程的一大任务，就是去运行这些开机启动的程序。</span><br><span class=\"line\">\t\tLinux允许为不同的场合，分配不同的开机启动程序，这就叫做&quot;运行级别&quot;（runlevel）。也就是说，启动时根据&quot;运行级别&quot;，确定要运行哪些程序。</span><br><span class=\"line\">系统初始化。</span><br><span class=\"line\">    在init的配置文件中有这么一行： si::sysinit:/etc/rc.d/rc.sysinit　它调用执行了/etc/rc.d/rc.sysinit</span><br><span class=\"line\">    而rc.sysinit是一个bash shell的脚本，它主要是完成一些系统初始化的工作，rc.sysinit是每一个运行级别都要首先运行的重要脚本。</span><br><span class=\"line\">    它主要完成的工作有：激活交换分区，检查磁盘，加载硬件模块以及其它一些需要优先执行任务。</span><br><span class=\"line\">建立终端 。</span><br><span class=\"line\">\trc执行完毕后，返回init。这时基本系统环境已经设置好了，各种守护进程也已经启动了。</span><br><span class=\"line\">\tinit接下来会打开6个终端，以便用户登录系统。在inittab中的以下6行就是定义了6个终端：</span><br><span class=\"line\">\t同时它会显示一个文本登录界面，这个界面就是我们经常看到的登录界面，在这个登录界面中会提示用户输入用户名</span><br><span class=\"line\">\t而用户输入的用户将作为参数传给login程序来验证用户的身份。</span><br><span class=\"line\">用户登录系统。</span><br><span class=\"line\">\t一般来说，用户的登录方式有三种：</span><br><span class=\"line\">        （1）命令行登录</span><br><span class=\"line\">        （2）ssh登录</span><br><span class=\"line\">        （3）图形界面登录</span><br></pre></td></tr></table></figure>\n<h4 id=\"linux运行级别amazon\"><a class=\"markdownIt-Anchor\" href=\"#linux运行级别amazon\">#</a> linux 运行级别 (amazon)</h4>\n<blockquote>\n<p>Linux 系统有 7 个运行级别 (runlevel)：</p>\n<ul>\n<li>运行级别 0：系统停机状态，系统默认运行级别不能设为 0，否则不能正常启动</li>\n<li>运行级别 1：单用户工作状态，root 权限，用于系统维护，禁止远程登录</li>\n<li>运行级别 2：多用户状态 (没有 NFS)</li>\n<li>运行级别 3：完全的多用户状态 (有 NFS)，登录后进入控制台命令行模式</li>\n<li>运行级别 4：系统未使用，保留</li>\n<li>运行级别 5：X11 控制台，登录后进入图形 GUI 模式</li>\n<li>运行级别 6：系统正常关闭并重启，默认运行级别不能设为 6，否则不能正常启动</li>\n</ul>\n</blockquote>\n<h4 id=\"linux进程状态汉得\"><a class=\"markdownIt-Anchor\" href=\"#linux进程状态汉得\">#</a> linux 进程状态（汉得）</h4>\n<blockquote>\n<p>3 running, 144 sleeping,   0 stopped,   1 zombie</p>\n</blockquote>\n<img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/875796-20190926175737431-422827153.png\" alt=\"img\" style=\"zoom:67%;\" />\n<h4 id=\"查看服务是否运行汉得\"><a class=\"markdownIt-Anchor\" href=\"#查看服务是否运行汉得\">#</a> 查看服务是否运行（汉得）</h4>\n<blockquote>\n<p>ps ef  和  ps aux</p>\n<p>[root@VM-16-11-centos ~]# ps -ef | grep sshd<br>\nroot      2896     1  0 Mar22 ?        00:01:56 /usr/sbin/sshd -D<br>\nroot     11786  2896  0 09:52 ?        00:00:00 sshd: lighthouse [priv]<br>\nlightho+ 11800 11786  0 09:52 ?        00:00:00 sshd: lighthouse@pts/0<br>\nroot     13538 11930  0 09:57 pts/0    00:00:00 grep --color=auto sshd</p>\n<p>ps aux 最初用到 Unix Style 中，而 ps -ef 被用在 System V Style 中，两者输出略有不同。</p>\n<p>其中 STAT 状态位常见的状态字符有<br>\n D   // 无法中断的休眠状态（通常 IO 的进程）；<br>\nR   // 正在运行可中在队列中可过行的；<br>\nS   // 处于休眠状态；<br>\nT   // 停止或被追踪；<br>\nW   // 进入内存交换 （从内核 2.6 开始无效）；<br>\nX   // 死掉的进程 （基本很少见）；<br>\nZ   // 僵尸进程；<br>\n&lt;   // 优先级高的进程<br>\n N   // 优先级较低的进程<br>\n L   // 有些页被锁进内存；<br>\ns   // 进程的领导者（在它之下有子进程）；<br>\nl   // 多线程，克隆线程（使用 CLONE_THREAD, 类似 NPTL pthreads）；<br>\n+   // 位于后台的进程组；</p>\n</blockquote>\n<h4 id=\"查看服务器cpu内存磁盘利用率linux版本汉得\"><a class=\"markdownIt-Anchor\" href=\"#查看服务器cpu内存磁盘利用率linux版本汉得\">#</a> 查看服务器 CPU，内存，磁盘利用率，linux 版本（汉得）</h4>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">1.查看内存使用率</span><br><span class=\"line\"></span><br><span class=\"line\">[root@VM-16-11-centos ~]# free -h</span><br><span class=\"line\">              total        used        free      shared  buff/cache   available</span><br><span class=\"line\">Mem:           1.8G        685M        149M         12M        1.0G        947M</span><br><span class=\"line\">Swap:          1.0G        374M        650M</span><br><span class=\"line\">[root@VM-16-11-centos ~]# vmstat</span><br><span class=\"line\">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class=\"line\"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class=\"line\"> 3  0 383388 153348 213388 813048    0    0     2    26    0    1  3  1 95  0  0</span><br><span class=\"line\"></span><br><span class=\"line\">2.查看CPU使用率</span><br><span class=\"line\">[root@VM-16-11-centos ~]# top</span><br><span class=\"line\">top - 10:07:30 up 217 days, 10:19,  1 user,  load average: 0.42, 0.30, 0.21</span><br><span class=\"line\">Tasks: 150 total,   3 running, 146 sleeping,   0 stopped,   1 zombie</span><br><span class=\"line\">%Cpu(s):  3.0 us,  1.0 sy,  0.0 ni, 96.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br><span class=\"line\">[root@VM-16-11-centos ~]# cat /proc/cpuinfo  | grep physical | uniq -c</span><br><span class=\"line\">      1 physical id     : 0</span><br><span class=\"line\">      1 address sizes   : 46 bits physical, 48 bits virtual</span><br><span class=\"line\">[root@VM-16-11-centos ~]# dmidecode</span><br><span class=\"line\"># dmidecode 3.2</span><br><span class=\"line\">Getting SMBIOS data from sysfs.</span><br><span class=\"line\">SMBIOS 2.8 present.</span><br><span class=\"line\">9 structures occupying 398 bytes.</span><br><span class=\"line\">Table at 0x000F6A20.</span><br><span class=\"line\">...... </span><br><span class=\"line\"></span><br><span class=\"line\">3.查看磁盘利用率</span><br><span class=\"line\">[root@VM-16-11-centos ~]# df -h</span><br><span class=\"line\">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class=\"line\">devtmpfs        908M     0  908M   0% /dev</span><br><span class=\"line\">tmpfs           919M   32K  919M   1% /dev/shm</span><br><span class=\"line\">tmpfs           919M  1.1M  918M   1% /run</span><br><span class=\"line\">tmpfs           919M     0  919M   0% /sys/fs/cgroup</span><br><span class=\"line\">/dev/vda1        50G   21G   27G  43% /</span><br><span class=\"line\">tmpfs           184M     0  184M   0% /run/user/0</span><br><span class=\"line\">tmpfs           184M     0  184M   0% /run/user/1000</span><br><span class=\"line\">overlay          50G   21G   27G  43% /var/lib/docker/overlay2/6abafa18f5d96ab29f1273e0173f6573cb815fdfef8b88e2911fe106021c5cdc/merged</span><br><span class=\"line\">[root@VM-16-11-centos ~]# fdisk -l</span><br><span class=\"line\"></span><br><span class=\"line\">Disk /dev/vda: 53.7 GB, 53687091200 bytes, 104857600 sectors</span><br><span class=\"line\">Units = sectors of 1 * 512 = 512 bytes</span><br><span class=\"line\">Sector size (logical/physical): 512 bytes / 512 bytes</span><br><span class=\"line\">I/O size (minimum/optimal): 512 bytes / 512 bytes</span><br><span class=\"line\">Disk label type: dos</span><br><span class=\"line\">Disk identifier: 0x0009ac89</span><br><span class=\"line\"></span><br><span class=\"line\">   Device Boot      Start         End      Blocks   Id  System</span><br><span class=\"line\">/dev/vda1   *        2048   104857566    52427759+  83  Linux</span><br><span class=\"line\"></span><br><span class=\"line\">4.进程</span><br><span class=\"line\">ps -ef ps -aux</span><br><span class=\"line\"></span><br><span class=\"line\">5.内核</span><br><span class=\"line\">uname -a</span><br></pre></td></tr></table></figure>\n<p><span class=\"exturl\" data-url=\"aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kZXZlbG9wZXIvYXJ0aWNsZS8xNzIxNDA2\">Linux 系统查看 CPU、机器型号、内存等信息 - 腾讯云开发者社区 - 腾讯云 (tencent.com)</span></p>\n<h4 id=\"chmod改变文件所属者汉得\"><a class=\"markdownIt-Anchor\" href=\"#chmod改变文件所属者汉得\">#</a> chmod (改变文件所属者)（汉得）</h4>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chmod 777 /home/aaa/aaa.sh</span><br><span class=\"line\">chmod +x ./ssb.sh</span><br><span class=\"line\">chmod -R 644 a.txt</span><br><span class=\"line\">chmod 4775 file //设置了特殊权限位</span><br></pre></td></tr></table></figure>\n<h4 id=\"lvm宏杉吉利英伦\"><a class=\"markdownIt-Anchor\" href=\"#lvm宏杉吉利英伦\">#</a> LVM（宏杉，吉利英伦）</h4>\n<blockquote>\n<p>LVM 是逻辑盘卷管理（Logical Volume Manager）的简称，它是 Linux 环境下对磁盘分区进行管理的一种机制，LVM 是建立在硬盘和分区之上的一个逻辑层，来提高磁盘分区管理的灵活性。</p>\n<p>LVM 最大的特点就是可以对磁盘进行动态管理。因为逻辑卷的大小是可以动态调整的，而且不会丢失现有的数据。如果我们新增加了硬盘，其也不会改变现有上层的逻辑卷。作为一个动态磁盘管理机制，逻辑卷技术大大提高了磁盘管理的灵活性。</p>\n<p><strong>PV</strong>（Physical Volume）- 物理卷<br>\n物理卷在逻辑卷管理中处于最底层，它可以是实际物理硬盘上的分区，也可以是整个物理硬盘。<br>\n<strong>VG</strong>（Volumne Group）- 卷组<br>\n卷组建立在物理卷之上，一个卷组中至少要包括一个物理卷，在卷组建立之后可动态添加物理卷到卷组中。一个逻辑卷管理系统工程中可以只有一个卷组，也可以拥有多个卷组。<br>\n<strong>LV</strong>（Logical Volume）- 逻辑卷<br>\n逻辑卷建立在卷组之上，卷组中的未分配空间可以用于建立新的逻辑卷，逻辑卷建立后可以动态地扩展和缩小空间。系统中的多个逻辑卷可以属于同一个卷组，也可以属于不同的多个卷组</p>\n<p>PV 物理卷常用操作<br>\n pvcreate /dev/DEVICE: 创建 PV<br>\npvs：简要 PV 信息显示<br>\n pvdisplay：显示 PV 的详细信息<br>\n pvremove /dev/DEVICE: 移除 PV<br>\npvscan: 扫描系统中连接的所有硬盘，列出找到的物理卷列表</p>\n<p>VG 常用操作<br>\n vgcreate /dev/DEVICE: 创建 VG 卷组<br>\n vgs: 简要 VG 信息显示<br>\n vgextend：动态扩展 LVM 卷组，它通过向卷组中添加物理卷来增加卷组的容量<br>\n vgreduce：通过删除 LVM 卷组中的物理卷来减少卷组容量，不能删除 LVM 卷组中剩余的最后一个物理卷<br>\n vgdisplay：显示 VG 的详细信息<br>\n vgscan：查找系统中存在的 LVM 卷组，并显示找到的卷组列表<br>\n vgremove：删除卷组，其上的逻辑卷必须处于离线状态</p>\n<p>4、LV 常用操作<br>\n lvcreate : 用来创建 LVM 的逻辑卷<br>\n lvcreate -L #[mMgGtT] -n NAME VolumeGroup<br>\nlvs : 显示逻辑卷信息<br>\n lvscan：扫描当前系统中的所有逻辑卷，及其对应的设备文件<br>\n lvdisplay：显示逻辑卷属性<br>\n lvextend：可在线扩展逻辑卷空间<br>\n lvreduce：缩减逻辑卷空间，一般离线使用<br>\n lvremove：删除逻辑卷，需要处于离线（卸载）状态</p>\n<p><strong>缺点：</strong></p>\n<p>在从卷组中移除一个磁盘的时候必须使用 reducevg 命令（这个命令要求 root 权限，并且不允许在快照卷组中使用）。</p>\n<p>当卷组中的一个磁盘损坏时，整个卷组都会受到影响。</p>\n<p>因为加入了额外的操作，存储性能受到影响</p>\n<p>不能减小文件系统大小（受文件系统类型限制</p>\n</blockquote>\n<h3 id=\"10mysql相关\"><a class=\"markdownIt-Anchor\" href=\"#10mysql相关\">#</a> 10.mysql 相关</h3>\n<h4 id=\"mysql新建用户茄子\"><a class=\"markdownIt-Anchor\" href=\"#mysql新建用户茄子\">#</a> mysql 新建用户 (茄子)</h4>\n<blockquote>\n<ol>\n<li></li>\n</ol>\n<p>CREATE USER user_account IDENTIFIED BY password;  #CREATE USER dbadmin@localhost  IDENTIFIED BY ‘pwd123’;</p>\n<p>CREATE USER superadmin@’%’ IDENTIFIED BY ‘mypassword’; # 要允许用户帐户从任何主机连接，请使用百分比 ( <code>%</code> ) 通配符</p>\n<p>CREATE USER remote_user; #可以从任何主机连接到数据库服务器：</p>\n<ol start=\"2\">\n<li></li>\n</ol>\n<p>可以使用 INSERT 语句将用户的信息添加到 mysql.user 表中，但必须拥有对 mysql.user 表的 INSERT 权限。通常 INSERT 语句只添加 Host、User 和 authentication_string 这 3 个字段的值。</p>\n<p>INSERT INTO mysql.user(Host, User,  authentication_string, ssl_cipher, x509_issuer, x509_subject) VALUES (‘hostname’, ‘username’, PASSWORD(‘password’), ‘’, ‘’, ‘’);</p>\n<ol start=\"3\">\n<li></li>\n</ol>\n<p>GRANT SELECT ON*.* TO ‘test3’@localhost IDENTIFIED BY ‘test3’;</p>\n<p>4. 删除用户</p>\n<p>DROP USER ‘username’@‘host’;</p>\n<p>5. 更改密码</p>\n<p>SET PASSWORD FOR ‘username’@‘host’ = PASSWORD(‘newpassword’);</p>\n</blockquote>\n<h4 id=\"mysql查看权限茄子\"><a class=\"markdownIt-Anchor\" href=\"#mysql查看权限茄子\">#</a> mysql 查看权限 (茄子)</h4>\n<blockquote>\n<p>SHOW GRANTS FOR dbadmin@localhost;</p>\n<p>GRANT privileges ON databasename.tablename TO ‘username’@‘host’</p>\n<p>REVOKE privilege ON databasename.tablename FROM ‘username’@‘host’;</p>\n</blockquote>\n<h4 id=\"mysql备份中海达\"><a class=\"markdownIt-Anchor\" href=\"#mysql备份中海达\">#</a> mysql 备份 (中海达)</h4>\n<blockquote>\n<p>mysqldump -h 主机名 -P 端口 -u 用户名 -p 密码 –database 数据库名 &gt; 文件名.sql</p>\n</blockquote>\n<h4 id=\"mysql可靠中海达\"><a class=\"markdownIt-Anchor\" href=\"#mysql可靠中海达\">#</a> mysql 可靠 (中海达)</h4>\n<h4 id=\"acid汉得\"><a class=\"markdownIt-Anchor\" href=\"#acid汉得\">#</a> acid (汉得)</h4>\n<h4 id=\"mysql锁汉得\"><a class=\"markdownIt-Anchor\" href=\"#mysql锁汉得\">#</a> mysql 锁 (汉得)</h4>\n<h4 id=\"隔离级别汉得\"><a class=\"markdownIt-Anchor\" href=\"#隔离级别汉得\">#</a> 隔离级别 (汉得)</h4>\n<h4 id=\"主键外键区别主键索引区别汉得\"><a class=\"markdownIt-Anchor\" href=\"#主键外键区别主键索引区别汉得\">#</a> 主键，外键区别，主键，索引区别 (汉得)</h4>\n<p>10. 云计算相关问题</p>\n<p>使用过公有云吗，对公有云了解吗，中科还问了 OpenStack 了解吗 (中海达，茄子，中科曙光)</p>\n<p>ISSA，PAAS，SASS (吉利英伦)</p>\n<p>11. 有哪些负载均衡器 (茄子)</p>\n<p>12. 有哪些监控软件 (中海达，茄子)</p>\n<p>13.Nginx 了解吗 (中海达)</p>\n<p>Nginx 有哪些负载均衡模式 (长亭)</p>\n<p>Nginx 特性 (长亭)</p>\n<p>14. 连通性 /toubleshooting 问题</p>\n<p>14.1 判断和主机建立了连接的 IP (茄子)</p>\n<p>14.2 主机间是否连通，端口是否开放 (茄子)</p>\n<p>15. 怎么保证安全和可靠 (信锐)</p>\n<p>16.DNS 原理，端口 (特斯拉，长亭)</p>\n<p>递归和迭代区别 (这个目前还没人问，我闲着蛋疼自己问自己)</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">（1）递归查询</span><br><span class=\"line\">递归查询是一种DNS 服务器的查询模式，在该模式下DNS 服务器接收到客户机请求，必须使用一个准确的查询结果回复客户机。如果DNS 服务器本地没有存储查询DNS 信息，那么该服务器会询问其他服务器，并将返回的查询结果提交给客户机。</span><br><span class=\"line\"></span><br><span class=\"line\">（2）迭代查询</span><br><span class=\"line\">DNS 服务器另外一种查询方式为迭代查询，DNS 服务器会向客户机提供其他能够解析查询请求的DNS 服务器地址，当客户机发送查询请求时，DNS 服务器并不直接回复查询结果，而是告诉客户机另一台DNS 服务器地址，客户机再向这台DNS 服务器提交请求，依次循环直到返回查询的结果为止。</span><br></pre></td></tr></table></figure>\n<p>17. 二层相关</p>\n<p>stp 作用 (宏杉)</p>\n<p>super vlan (宏杉)</p>\n<p>stp 选举 (中科闻歌)</p>\n<p>18 链路聚合 (宏杉，中科曙光)</p>\n<p>19. 防火墙硬件实现，IPSEC 了解过吗 (中科曙光)</p>\n<p>防火墙用过吗，啥型号的，A 访问 B 时在防火墙配置单向还是双向，如果是交换机，需要配置单向还是双向 (中科闻歌)</p>\n<p>20. 项目题</p>\n<p>小型星星网络</p>\n<p>1. 确定网络设备</p>\n<p>2. 交换机设备和接口数量，交换机选型 (吞吐量)</p>\n<p>中型</p>\n<p>大型</p>\n<p>ping 丢包</p>\n<h2 id=\"0x02-安全岗总结\"><a class=\"markdownIt-Anchor\" href=\"#0x02-安全岗总结\">#</a> 0x02 安全岗总结</h2>\n<p>1. 反序列化相关</p>\n<p>PHP 反序列化的魔法方法，wakeup 绕过 (理想)</p>\n<p>shrio 反序列化，fastjson 反序列化，struct S062 (深信服)</p>\n<p>java 反序列化 (深信服)</p>\n<p>2. 逻辑漏洞类</p>\n<p>逻辑漏洞任意邮箱注册怎么修复 (理想)</p>\n<p>登录框有啥漏洞 (安天)</p>\n<p>3.XSS 类</p>\n<p>富文本编辑器 XSS 怎么解决 (理想)</p>\n<p>说说看 xss (长亭)</p>\n<p>4.SQL 注入类</p>\n<p>SQL 注入怎么防，PDO 在 order by 场景怎么防 (理想)</p>\n<p>sql 注入有几种 (深信服)</p>\n<p>union select 后面可以加 insert 吗，union select 叫啥名字 (深信服)</p>\n<p>怎么通过数据库获取系统权限，mysql，sqlserver (深信服)</p>\n<p>mysql 写 shell 命令 (深信服)</p>\n<p>堆叠注入原理，和 union select 有啥区别 (深信服)</p>\n<p>报错注入语句 (深信服)</p>\n<p>时间盲注原理，语句 (深信服)</p>\n<p>5. 入侵排查怎么查，netstat 怎么看，怎么找进程 (理想，安天)</p>\n<p>6.discuz 漏洞复现 (可能因为我简历里写了)(理想)</p>\n<p>7.cookie 对单个参数长度限制 (理想)</p>\n<p>8. 出现 0day，资产排查 (理想)</p>\n<p>10. 文件上传 shell 成功但不能连接，怎么办 (深信服)</p>\n<p>11. 内网渗透相关</p>\n<p>内网隧道怎么搭，earthworm 三种模式 (深信服)</p>\n<p>内网横向 (深信服)</p>\n<p>wmin 端口，横向之后啥权限 (深信服)</p>\n<p>12. 权限维持 (深信服)</p>\n<p>13.waf 是干啥的，哪一层的 (长亭)</p>\n",
            "tags": []
        }
    ]
}