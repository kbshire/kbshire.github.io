



<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#FFF">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">


<link rel="alternate" type="application/rss+xml" title="Hexo" href="http://example.com/rss.xml" />
<link rel="alternate" type="application/atom+xml" title="Hexo" href="http://example.com/atom.xml" />
<link rel="alternate" type="application/json" title="Hexo" href="http://example.com/feed.json" />

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="/css/app.css?v=0.2.5">

  
  <meta name="keywords" content="汇编" />


<link rel="canonical" href="http://example.com/2022/11/01/%E6%B1%87%E7%BC%96/">



  <title>
汇编 - 逆向 |
Yume Shoka = Hexo</title>
<meta name="generator" content="Hexo 5.4.2"></head>
<body itemscope itemtype="http://schema.org/WebPage">
  <div id="loading">
    <div class="cat">
      <div class="body"></div>
      <div class="head">
        <div class="face"></div>
      </div>
      <div class="foot">
        <div class="tummy-end"></div>
        <div class="bottom"></div>
        <div class="legs left"></div>
        <div class="legs right"></div>
      </div>
      <div class="paw">
        <div class="hands left"></div>
        <div class="hands right"></div>
      </div>
    </div>
  </div>
  <div id="container">
    <header id="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="inner">
        <div id="brand">
          <div class="pjax">
          
  <h1 itemprop="name headline">汇编
  </h1>
  
<div class="meta">
  <span class="item" title="Created: 2022-11-01 13:38:45">
    <span class="icon">
      <i class="ic i-calendar"></i>
    </span>
    <span class="text">Posted on</span>
    <time itemprop="dateCreated datePublished" datetime="2022-11-01T13:38:45+08:00">2022-11-01</time>
  </span>
</div>


          </div>
        </div>
        <nav id="nav">
  <div class="inner">
    <div class="toggle">
      <div class="lines" aria-label="Toggle navigation bar">
        <span class="line"></span>
        <span class="line"></span>
        <span class="line"></span>
      </div>
    </div>
    <ul class="menu">
      <li class="item title"><a href="/" rel="start">Yume Shoka</a></li>
    </ul>
    <ul class="right">
      <li class="item theme">
        <i class="ic i-sun"></i>
      </li>
      <li class="item search">
        <i class="ic i-search"></i>
      </li>
    </ul>
  </div>
</nav>

      </div>
      <div id="imgs" class="pjax">
        <ul>
          <li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipeuibk9fj20zk0m8ay2.jpg"></li>
          <li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipeyonbf9j20zk0m8e81.jpg"></li>
          <li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gicitht3xtj20zk0m8k5v.jpg"></li>
          <li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giclh3brzpj20zk0m8ann.jpg"></li>
          <li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1gipex2cdtbj20zk0m8x6p.jpg"></li>
          <li class="item" data-background-image="https://tva2.sinaimg.cn/large/6833939bly1giclxxcb6rj20zk0m8b29.jpg"></li>
        </ul>
      </div>
    </header>
    <div id="waves">
      <svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
        <defs>
          <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z" />
        </defs>
        <g class="parallax">
          <use xlink:href="#gentle-wave" x="48" y="0" />
          <use xlink:href="#gentle-wave" x="48" y="3" />
          <use xlink:href="#gentle-wave" x="48" y="5" />
          <use xlink:href="#gentle-wave" x="48" y="7" />
        </g>
      </svg>
    </div>
    <main>
      <div class="inner">
        <div id="main" class="pjax">
          
  <div class="article wrap">
    
<div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList">
<i class="ic i-home"></i>
<span><a href="/">Home</a></span><i class="ic i-angle-right"></i>
<span  class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/%E9%80%86%E5%90%91/" itemprop="item" rel="index" title="In 逆向"><span itemprop="name">逆向</span></a>
<meta itemprop="position" content="1" /></span>
</div>

    <article itemscope itemtype="http://schema.org/Article" class="post block" lang="en">
  <link itemprop="mainEntityOfPage" href="http://example.com/2022/11/01/%E6%B1%87%E7%BC%96/">

  <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="image" content="/images/avatar.jpg">
    <meta itemprop="name" content="John Doe">
    <meta itemprop="description" content=", ">
  </span>

  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Hexo">
  </span>

  <div class="body md" itemprop="articleBody">
    

    <h1 id="汇编"><a class="markdownIt-Anchor" href="#汇编">#</a> 汇编</h1>
<p>1. 汇编语言组成</p>
<p>汇编指令 ，伪指令，其他符号</p>
<p>2. 汇编不区分大小写</p>
<p>3. 数据总线，控制总线，地址总线 – 外部总线</p>
<h2 id="寄存器cpu"><a class="markdownIt-Anchor" href="#寄存器cpu">#</a> 寄存器（CPU）</h2>
<p>CPU 由运算器，控制器，寄存器组成，靠内部总线相连</p>
<p>8086 有 14 个寄存器，它们的名称为 AB,BX,CX,DX，SI，DI，SP，BP，IP，CS，SS，DS，ES，PSW，都是 16 位</p>
<p>AX,BX,CX,DX 为通用结存器，最大可以存储 2^16-1</p>
<img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221009203327558.png" alt="image-20221009203327558" style="zoom:50%;" />
<p>每个又可以分为 H 和 L，比如 AH 和 AL，可以分开独立使用</p>
<img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221009204003372.png" alt="image-20221009204003372" style="zoom:50%;" />
<p>1word = 2 Byte</p>
<p>16 位 CPU 特征：1. 运算器一次最多处理 16 位 2，寄存器最大宽度为 16 位 3. 寄存器和运算器之间通路 16 位</p>
<p>由于 cpu 内部总线是 16 位，但外部总线是 20 位</p>
<p>8086 内部使用两个 16 位内部地址来将器变为 20 位</p>
<img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221009211023097.png" alt="image-20221009211023097" style="zoom:50%;" />
<p>第一个地址为段地址，第二个为偏移地址 ，通过地址加法器变为 20 位</p>
<p>物理地址 = 段地址 * 16 + 偏移地址</p>
<img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221009211420365.png" alt="image-20221009211420365" style="zoom:50%;" />
<p>即地址左移四位，每次左移一位，对应的 16 进制和 10 进制就 * 2，因为地址是二进制</p>
<p>扩展：一个 x 进制左移一位就 * x</p>
<p>段地址长度可以自己指定，一个段的最大长度为 64kb，起始地址一定为 16 的倍数</p>
<p>一个物理地址可以有很多种段地址和偏移地址的组合</p>
<p>2000:1F60 数据在 21F60 中</p>
<p>段寄存器 CS，DS，SS，ES</p>
<p>CS：代码地址</p>
<p>DS：数据地址</p>
<p>SS：堆栈地址</p>
<p>IP：指令指针寄存器</p>
<p>修改 CS IP 中内容使用</p>
<p>jmp 段地址：偏移地址</p>
<p>jmp ax   // 仅修改 IP 内容，参数为合法寄存器，类似于 mov IP，AX</p>
<p>8086cpu 工作过程</p>
<p>1.CS:IP 指向内存单元读取执行，读取执行进入指令缓冲器</p>
<p>2.IP 指向下一条指令</p>
<p>3. 执行指令，重复到 1</p>
<p>初始 CS=2000H，IP=0000H</p>
<img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221010210638345.png" alt="image-20221010210638345" style="zoom:50%;" />
<p>mov ax 6622</p>
<p>jmp 1000:3</p>
<p>mov ax,0000</p>
<p>mov bx,ax</p>
<p>jmp bx</p>
<p>mov ax,0123</p>
<p>mov ax,0000</p>
<p>… 死循环</p>
<p>代码段</p>
<p>将 &lt;=64kb 的一组代码，起始地址为 16 倍数的内存单元作为一个代码段</p>
<p>通过 CS：IP 指向代码段首地址来执行代码段</p>
<p>DEBUG</p>
<p>用 Debug 的 R 命令查看、改变 CPU 寄存器的内容；</p>
<p>用 Debug 的 D 命令查看内存中的内容；</p>
<p>用 Debug 的 E 命令改写内存中的内容；</p>
<p>用 Debug 的 U 命令将内存中的机器指令翻译成汇编指令；</p>
<p>用 Debug 的 T 命令执行一条机器指令；</p>
<p>用 Debug 的 A 命令以汇编指令的格式在内存中写入一条机器指令。</p>
<p><img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221010213213522.png" alt="image-20221010213213522"></p>
<p><img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221010213504618.png" alt="image-20221010213504618"></p>
<p><img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221010213716733.png" alt="image-20221010213716733"></p>
<p><img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221010213841925.png" alt="image-20221010213841925"></p>
<p><img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221010214052414.png" alt="image-20221010214052414"></p>
<p>fff0:0 ff 可以查看 rom 时间</p>
<p>b810:0 可以修改显存</p>
<img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221011204621998.png" alt="image-20221011204621998" style="zoom:50%;" />
<p>1 地址字单元存放的字型数据时 124EH</p>
<p>可以将 N 和 N+1 两个单元看成一个字单元</p>
<h2 id="寄存器内存"><a class="markdownIt-Anchor" href="#寄存器内存">#</a> 寄存器（内存）</h2>
<p>MOV al,[0]  // 将偏移地址为 0 的内存单元送到 AL 寄存器中</p>
<p>不能把立即数直接送入段寄存器 ，需要经过通用寄存器中转</p>
<p>数据 -》通用寄存器 -》段寄存器</p>
<p>将数据从寄存器送入内存单元</p>
<p>mov bx,1000H</p>
<p>mov ds,bx</p>
<p>mov [0],al</p>
<img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221011210109223.png" alt="image-20221011210109223" style="zoom:50%;" />
<img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221011210150336.png" alt="image-20221011210150336" style="zoom:50%;" />
<p>-e 1000:0 23 11 22 66</p>
<p>1122 8833 8833</p>
<img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221012084245812.png" alt="image-20221012084245812" style="zoom:50%;" />
<p>2c34</p>
<p>1B12   -d 1000:0</p>
<p>0000</p>
<p>mov 指令</p>
<blockquote>
<p>mov 寄存器，数据</p>
<p>mov 寄存器，寄存器</p>
<p>mov 寄存器，内存单元   mov ax,[0]</p>
<p>mov 内存单元，客存器   mov [0],ax</p>
<p>mov 段寄存器，寄存器</p>
<p>mov 寄存器，段寄存器</p>
</blockquote>
<p>add，sub</p>
<blockquote>
<p>add 寄存器，数据</p>
<p>add 寄存器，寄存器</p>
<p>add 寄存器，内存单元</p>
<p>add 内存单元，寄存器</p>
<p>sub 寄存器，数据</p>
<p>sub 寄存器，寄存器</p>
<p>sub 寄存器，内存单元</p>
<p>sub 内存单元，寄存器</p>
</blockquote>
<p>add,sub 不能使用段寄存器为参数</p>
<p>数据段：长度为 N 的地址连续，起始地址为 16 倍数的内存单元定义为存储数据的内存空间</p>
<p>将 123B0-123BA 的前三个单元的字节型数据累加</p>
<img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221012212730685.png" alt="image-20221012212730685" style="zoom:50%;" />
<p>累加字型数据</p>
<img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221012213223456.png" alt="image-20221012213223456" style="zoom:50%;" />
<p>[address] 表示一个偏移地址为 address 的内存单元</p>
<p><img data-src="../AppData/Roaming/Typora/typora-user-images/image-20221012214721228.png" alt="image-20221012214721228"></p>
<p><img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221012214843733.png" alt="image-20221012214843733"></p>
<p><img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221012215020183.png" alt="image-20221012215020183"></p>
<p>即 [0] 073F 和 073F [0] 会将 073f 当做偏移地址，验证：</p>
<p><img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221012215201456.png" alt="image-20221012215201456"></p>
<p><img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221012215301128.png" alt="image-20221012215301128"></p>
<h4 id="栈"><a class="markdownIt-Anchor" href="#栈">#</a> 栈</h4>
<p>8086 提供的入栈和出栈 push,pop</p>
<p>push ax 将寄存器 ax 中的数据送入栈中</p>
<p>pop ax 从栈顶取出数据送入 ax</p>
<p>通过段寄存器 SS 存放栈顶的段地址，sp 存放栈顶偏移地址，任意时刻，SS:SP 指向栈顶元素</p>
<p>push ax sp=sp-2,SS:SP 指向新栈顶，放入数据</p>
<img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221013193051835.png" alt="image-20221013193051835" style="zoom:50%;" />
<img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221013193356305.png" alt="image-20221013193356305" style="zoom:50%;" />
<blockquote>
<p>任意时刻・SS:SP 指向栈顶元素。当栈为空的时候，栈中没有元素，也就不存在栈项元素<br>
所 SS:SP 只能指向栈的最底部单元下面的单元，该单元的偏移地址为栈最底部的字单元的偏移地址 + 2<br>
 栈最底部字单元的地址为 1000:000E，所以栈空时 SP=0010H</p>
</blockquote>
<p>pop ax  将数据送入 ax 中，SP=SP+2，数据仍在内存中，下一次 push 或其他写入数据的操作时会覆盖</p>
<img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221013194330665.png" alt="image-20221013194330665" style="zoom:50%;" />
<p>push 和 pop 可以操作段寄存器，通用寄存器，内存单元</p>
<p>push ax</p>
<p>push ds</p>
<p>push [0]</p>
<h4 id="栈顶越界"><a class="markdownIt-Anchor" href="#栈顶越界">#</a> 栈顶越界</h4>
<p>栈满 push，栈空 pop 产生越界</p>
<p>栈满 push 会导致溢出覆盖栈外的数据</p>
<p>栈空 pop 会将别的数据放入寄存器中产生溢出</p>
<p>8086CPU 中没有检测的机制，需要自己注意…</p>
<h4 id="练习"><a class="markdownIt-Anchor" href="#练习">#</a> 练习</h4>
<p>将 10000H~1000FH 这段空间当作栈，初始状态是空的，将 AX,BX,DS 中的数据入栈</p>
<p>mov ax,1000</p>
<p>mov ss,ax</p>
<p>mov sp,0010</p>
<p>push ax</p>
<p>push bx</p>
<p>push ds</p>
<p>(1）将 10000H~1000FH 这段空间当作栈，初始状态是空的；</p>
<p>(2）设置 AX=001AH，BX=001BH;</p>
<p>(3）将 AX，BX 中的数据入栈</p>
<p>(4）然后将 AX，BX 清零；</p>
<p>(5）从栈中恢复 AX，BX 原来的内容。</p>
<p>mov ax,1000</p>
<p>mov ss,ax</p>
<p>mov sp,0010</p>
<p>mov ax,001A</p>
<p>mov bx,001B</p>
<p>push ax</p>
<p>push bx</p>
<p>mov ax,0   // 使用 sub ax,ax 只使用两个字节，mov ax,0 机器码需要三个字节，也可以使用 xor ax,ax</p>
<p>mov bx,0</p>
<p>pop bx</p>
<p>pop ax</p>
<p>(1)   将 10000H~1000FH 这段空间当栈，初始状态是空的；</p>
<p>(2）设置 AX=002AH ，BX=002BH;</p>
<p>(3）利用栈交换 AX 和 BX 中的数据。</p>
<p>mov ax,1000</p>
<p>mov ss,ax</p>
<p>mov sp,0010</p>
<p>mov ax,002A</p>
<p>mov bx,002B</p>
<p>push ax</p>
<p>push bx</p>
<p>pop ax</p>
<p>pop bx</p>
<p>我们如果要在 10000H 处写入字型数据 2266H, 可以用以下的代码完成︰</p>
<p>mov ax,1000H</p>
<p>mov ds,ax</p>
<p>mov ax,2266H</p>
<p>mov [0],ax</p>
<p>补在 10000H 处写入字型数据 2266H</p>
<p>mov ax,1000</p>
<p>mov ss,ax</p>
<p>mov sp,2   //push 之前先 - 2，在放输入，2-2=0</p>
<p>mov ax,2266</p>
<p>push ax</p>
<p>要求，不能用 mov 内存单元，寄存器这类指令</p>
<p>push，pop 实质上是一种内存传送指令，push，pop 访问的内存单元的地址是由 ss:sp 指出的</p>
<p>pop，pop 栈操作只修改 sp，sp 最大变化范围为 0-FFFF</p>
<p>如果我们将 10000H~1FFFFH 这段空间当作栈段，初始状态是空的，比时 SS=1000H，SP=0</p>
<p>栈顶变化范围为 0-FFFFH，栈空 sp=0，一直压栈，栈满后 sp=0，再次压栈，栈顶将环绕，覆盖原来内容</p>
<p>对于代码段，数据段，栈段，cpu 通过 CS DS SS 区分</p>
<p>CS:IP</p>
<p>SS:SP</p>
<p>DS:[0]</p>
<h2 id="程序编写"><a class="markdownIt-Anchor" href="#程序编写">#</a> 程序编写</h2>
<p>1. 编写汇编程序，后缀为.asm</p>
<p>2. 编译 masm.exe 连接 link.exe</p>
<p>3. 执行可执行文件，有程序和数据两部分，操作系统加可执行文件中的机器码和数据加载入内存，进行初始化</p>
<p>源程序</p>
<img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221015201813041.png" alt="image-20221015201813041" style="zoom:50%;" />
<p>汇编指令上图中 mov，add，int 等</p>
<p>伪指令上图中 assume codesg，没有对应的机器码，不被 cpu 执行，被编译器执行</p>
<p>定义一个段</p>
<p>segment 和 ends 是一对成对的伪指令，定义一个段 segment 开始，ends 结束</p>
<p>格式:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">段名 segment </span><br><span class="line">段名 ends</span><br></pre></td></tr></table></figure>
<p>一个汇编程序由多个段组成</p>
<p>ends 是汇编程序结束标记</p>
<p>assume 假设寄存器和段关联，CS:codesg，假设代码段的名称为 codesg</p>
<p>将源程序文件中内容称为源程序，编译后称为程序，程序放在可执行文件中 PE</p>
<img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221015203100625.png" alt="image-20221015203100625" style="zoom:50%;" />
<p>标号 一个标号指代一个地址，codesg</p>
<p>编程运算 2^3</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">assume cs:abc</span><br><span class="line">abc segent</span><br><span class="line">mov ax,2</span><br><span class="line">add ax,ax</span><br><span class="line">add ax,ax</span><br><span class="line">abc ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>DOS 是一个单任务操作系统，一个程序结束后，将 CPU 控制权交还给使他运行的程序，称为返回</p>
<p>返回 程序段</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov ax,4c00H</span><br><span class="line">int 21H</span><br></pre></td></tr></table></figure>
<img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221015204512894.png" alt="image-20221015204512894" style="zoom:50%;" />
<p>masm.exe 1.asm</p>
<p>link 1.obj</p>
<p>可以在命令后加上；简化编译和连接</p>
<p>连接：源程序很大时将他分为多个源程序编译，成文目标文件后在连接到一起。将库文件和程序的目标文件连接在一起才可以生成可执行文件</p>
<p>在 DOS 中运行 1.exe 时，DOS 的 command 将 1.exe 加载进入内存，command 设置 CPU 的 cs:IP 指向程序的第一条指令，从而得以使程序运行。</p>
<p>程序运行结束后，返回到 command 中，cpu 继续执行 command</p>
<img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221016204217510.png" alt="image-20221016204217510" style="zoom:67%;" />
<p>Debug 将程序加载进入内存，当不放弃对 cpu 控制，使用中断实现</p>
<p>有入口的程序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">    codesg segment</span><br><span class="line">    start:	mov ax,0123H</span><br><span class="line">    		add bx,0456H</span><br><span class="line">    		add ax,bx</span><br><span class="line">    		add ax,ax</span><br><span class="line">			</span><br><span class="line">			mov ax,4c00H</span><br><span class="line">			int 21H</span><br><span class="line">    		</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>debug 将程序 exe 加载入内存后 cx，存放程序长度</p>
<p>程序加载后，ds 中放着程序所在内存区的段地址，这个内存区的偏移地址为 0，这个内存区的前 256 个字节存放的是 psp，dos 用来和程序进行通信，从 256 字节以后存放的是程序</p>
<p>psp 的段地址 SA，偏移地址为 0，表示为 SA+10:0</p>
<img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221016211036041.png" alt="image-20221016211036041" style="zoom:50%;" />
<p>指定到 int 21 时用 p 执行，此时程序 terminated</p>
<p>使用 q 结束 debug，回到 command 中，因为 debug 由 command 加载</p>
<h2 id="bxloop"><a class="markdownIt-Anchor" href="#bxloop">#</a> [bx]&amp;loop</h2>
<p>bx:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">    codesg segment</span><br><span class="line">    start:	mov ax,2000</span><br><span class="line">    		mov ds,ax</span><br><span class="line">    		mov al,[0]</span><br><span class="line">    		mov bl,[1]</span><br><span class="line">    		mov cl,[2]</span><br><span class="line">    		mov dl,[3]</span><br><span class="line">			</span><br><span class="line">			mov ax,4c00H</span><br><span class="line">			int 21H</span><br><span class="line">    		</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>实际来说，CPU 并不认编译器的 [0] 这种东西，他会认成 0</p>
<p>但 debug 中 [0] 可以正常作为偏移地址</p>
<p>[bx] 表示一个内存单元，偏移地址在 bx 中</p>
<p>mov bx,0   // 将 0 给 bx</p>
<p>mov ax,[bx]   // 此时 bx 是偏移地址</p>
<p>段地址 SA，偏移地址 EA  SA：EA</p>
<p>() 的含义</p>
<p>ax 中的内容为 0010，那么 (ax)=0010</p>
<p>2000:1000 处的内容为 0010，(21000H)=0010</p>
<p>mov ax,[2] (ax)=((dx)*16+2)</p>
<p>idata 含义：</p>
<p>idata 表示常量</p>
<p>mov ax,[idata] 代表 Mov ax,[0]  Mov ax,[2]  Mov ax,[3]  d = 等</p>
<p>inc bx    //bx++</p>
<img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221017094727684.png" alt="image-20221017094727684" style="zoom:67%;" />
<p>ax 00be</p>
<p>bx 1002</p>
<p>内存中 00be 00be</p>
<p>bx 1004</p>
<p>内存中 00be 00be 00be</p>
<p>内存中从左到右为从低到高</p>
<p><img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221017094440863.png" alt="image-20221017094440863"></p>
<p>内存中 00be 00be 00be be 00</p>
<p>Loop</p>
<p>loop 标号</p>
<p>执行 loop 时 CPU 操作</p>
<p>1.(cx)=(cx)-1</p>
<p>2. 判断 cx 中的值，不为 0 跳至标号处执行，为 0 向下执行</p>
<p>即一般 cx 中存放循环次数</p>
<p>使用 loop 计算 2^2</p>
<p>mov ax,2</p>
<p>add ax,ax</p>
<p>计算 2^12</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:	mov ax,2</span><br><span class="line">		mov cx,11</span><br><span class="line">s: 		add ax,ax</span><br><span class="line">		loop s</span><br><span class="line">	</span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line">	</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>注意：debug 默认 16 进制，masm 默认十进制</p>
<p>loop 相当于 do … while …</p>
<p>计算 123*236 时使用 236+123 次，减少循环次数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:	mov ax,0</span><br><span class="line">		mov cx,123</span><br><span class="line">s: 		add ax,236</span><br><span class="line">		loop s</span><br><span class="line">	</span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line">	</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>汇编时数据不能以字母开头，要在前面 + 0</p>
<p>debug g 命令和 p 命令</p>
<p>将 ffff:0006 单元中的数据 * 123，结果存在 dx 中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:	mov ax,0ffffh</span><br><span class="line">		mov ds,ax</span><br><span class="line">		</span><br><span class="line">		mov bx,6</span><br><span class="line">		mov ax,[bx]</span><br><span class="line">		</span><br><span class="line">		mov dx,0</span><br><span class="line">		</span><br><span class="line">		mov cx,123</span><br><span class="line">s:		add dx,ax</span><br><span class="line">		loop s</span><br><span class="line">	</span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line">	</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>g 0014   // 直接执行到 IP 为 0014 的位置</p>
<p>p 直接执行到循环结束，如果不是 21H 的位置输入</p>
<p>在程序中</p>
<p>mov al, ds:[0]    // == mov bx,0  mov al,[bx], == mov al,[0]</p>
<p>累加 [0]-[b] 的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:	mov ax,0ffffh</span><br><span class="line">		mov ds,ax</span><br><span class="line">		mov bx,0</span><br><span class="line">		</span><br><span class="line">		mov dx,0</span><br><span class="line">		</span><br><span class="line">		mov cx,12</span><br><span class="line">s:		mov al,ds:[cs]</span><br><span class="line">		mov ah,0</span><br><span class="line">		add dx,ax</span><br><span class="line">		inc bx</span><br><span class="line">		loop s</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line">	</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>段前缀</p>
<p>mov ax,cs:[0]    //cs 为段前缀</p>
<p>一般类似或 0:200-0:2ff 不会有数据和指令，是一段安全的空间</p>
<p>将内存 ffff:0<sub>ffff:b 段元中的数据拷贝到 0:200</sub>0:20b 单元中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start:	mov ax,0ffffh</span><br><span class="line">		mov ds,ax  ;ds中是内存ffff:0中的数据</span><br><span class="line">		</span><br><span class="line">		mov ax,0020h</span><br><span class="line">		mov es,ax  ;es是内存20:0中的数据</span><br><span class="line">		</span><br><span class="line">		mov bx,0   ;bx中为内存偏移值</span><br><span class="line">		mov cx,12  ;为循环判断条件</span><br><span class="line">		</span><br><span class="line">s:		mov dl,ds:[bx]</span><br><span class="line">		mov es:[bx],dl</span><br><span class="line">		inc bx</span><br><span class="line">		loop s</span><br><span class="line">		</span><br><span class="line">	</span><br><span class="line">        mov ax,4c00h</span><br><span class="line">        int 21h</span><br><span class="line">	</span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<h2 id="多个段的程序"><a class="markdownIt-Anchor" href="#多个段的程序">#</a> 多个段的程序</h2>
<p>我们是不能自己随便决定哪段空间可以使用的，应该让系统来为我们分配。<strong>我们可以在程序中</strong>，定义我们希望处理的数据，这些数据就会被编译、连接程序作为程序的一部分写到可执行文件中。当可执行文件中的程序被加载入内存时，这些数据也同时被加载入内存中。与此同时，我们要处理的数据也就自然而然地获得了存储空间。</p>
<p>dw define word 定义字型数据，在代码段中定义数据，此时代码 的起始位置是数据之后</p>
<p>db 定义字节型数据</p>
<p>数据之间用，分隔</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">		dw 0123h,0234h,0123h,0234h,0123h,0234h,0123h,0234h</span><br><span class="line">start:	mov ax,0ffffh</span><br><span class="line">		mov ds,ax  </span><br></pre></td></tr></table></figure>
<p>标号 start 定义代码段的开始，区分数据和代码</p>
<p>-u 13f8:0</p>
<p>-u 13f8:10</p>
<p>读取结果不一样，如果数据被读成了代码，会导致下面真正的代码读取错误，因此在 debug 加载后，我们需要将 IP 设置为代码段中数据段的结束，比如上面的代码，我们需要将 IP 定义为 10 (10 进制的 16)</p>
<p>end start 可以告诉编译器程序的入口，即标号的地方。我们若要 CPU 从何处开始执行程序，只要在源程序中用 “end 标号” 指明就可以了。</p>
<p>代码段中使用栈</p>
<p>若数据，栈，代码所需空间查过 64kb，就不能放到一个栈中，因此应该用多个段存放数据，代码和栈</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg</span><br><span class="line">codesg segment</span><br><span class="line">	dw 0123H,0123H,0123H,0123H,0123H,0123H,0123H,0123H</span><br><span class="line">	dw 0,0,0,0,0,0,0,0  ;将上一行dw的数据入栈和出栈的空间</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">start:	mov ax,cs  ;将代码段起始位置给栈段</span><br><span class="line">		mov ss,ax</span><br><span class="line">		</span><br><span class="line">		mov sp,32  ;设置栈段的偏移地址为32(0+2*16)+1</span><br><span class="line">		</span><br><span class="line">		mov bx,0   ;bx偏移地址</span><br><span class="line">		mov cx,8   ;cx loop条件</span><br><span class="line">		</span><br><span class="line">s:		push cs:[bx] ;将cs中的数据入栈</span><br><span class="line">		add bx,2</span><br><span class="line">		loop s</span><br><span class="line">		</span><br><span class="line">		mov bx,0</span><br><span class="line">		mov cx,8</span><br><span class="line">		</span><br><span class="line">s0:		pop cs:[bx]  ;将cs中的数据出栈</span><br><span class="line">		add bx,2</span><br><span class="line">		loop s0</span><br><span class="line">		</span><br><span class="line">		mov ax,4c00H</span><br><span class="line">		int 21H</span><br><span class="line">		</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>存放数据的 data，存放 stack 栈，cs 存放代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data,ss:stack</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">	dw 0123H,0123H,0123H,0123H,0123H,0123H,0123H,0123H</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">stack segment</span><br><span class="line">	dw 0,0,0,0,0,0,0,0</span><br><span class="line">stack ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:	mov ax,stack</span><br><span class="line">		mov ss,ax</span><br><span class="line">		mov sp,16</span><br><span class="line">		</span><br><span class="line">		mov ax,data</span><br><span class="line">		mov ds,ax</span><br><span class="line">		</span><br><span class="line">		mov bx,0</span><br><span class="line">		mov cx,8</span><br><span class="line">		</span><br><span class="line">s:		push [bx] </span><br><span class="line">		add bx,2</span><br><span class="line">		loop s</span><br><span class="line">		</span><br><span class="line">		mov bx,0</span><br><span class="line">		mov cx,8</span><br><span class="line">		</span><br><span class="line">s0:		pop [bx]</span><br><span class="line">		add bx,2</span><br><span class="line">		loop s0</span><br><span class="line">		</span><br><span class="line">		mov ax,4c00H</span><br><span class="line">		int 21H</span><br><span class="line">		</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>在程序中，段名就相当于一个标号，它代表了段地址。所以指令 “mov ax,data” 的含义就是将名称为 “data” 的段的段地址送入 ax。</p>
<p>CPU 处理我们定义的段中的内容，是通过程序中的汇编指令，和汇编指令对 CS:IP,SS:SP，DS 等寄存器的设置来决定</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">assume cs:b,ds:a,ss:c</span><br><span class="line">....</span><br><span class="line">b segment</span><br><span class="line">d:	mov ax,c</span><br><span class="line">	mov ss,ax</span><br><span class="line">	mov sp,20h   ;将c当做栈空间，ss:sp指向c:20</span><br></pre></td></tr></table></figure>
<p>程序占 N 个字节，运行后，该端实际占有空间为 (段为 16 的倍数)</p>
<p>(N/16+1)*16</p>
<p>如果没有 end 后面的标号，CPU 会将第一个数据当做代码段的开始</p>
<p>程序如下，编写 code 段中的代码，将 a 段和 b 段中的数据依次相加，将结果存到 c 段中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">a segment</span><br><span class="line">	db 1,2,3,4,5,6,7,8</span><br><span class="line">a ends</span><br><span class="line"></span><br><span class="line">b segment </span><br><span class="line">	db 1,2,3,4,5,6,7,8</span><br><span class="line">b ends</span><br><span class="line"></span><br><span class="line">c segment</span><br><span class="line">	db 0,0,0,0,0,0,0,0</span><br><span class="line">c ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:	mov ax,a</span><br><span class="line">		mov ds,ax   ;ds中为数据段a中的数据</span><br><span class="line">		</span><br><span class="line">		mov ax,c</span><br><span class="line">		mov es,ax   ;es中为数据段c中的数据</span><br><span class="line">		</span><br><span class="line">		mov bx,0</span><br><span class="line">		mov cx,8</span><br><span class="line">		 </span><br><span class="line">s:		mov dx,ds:[bx]   ;循环将ds(a)中的数据给c</span><br><span class="line">		mov es:[bx],dx   </span><br><span class="line">		add bx,2</span><br><span class="line">		loop s</span><br><span class="line"></span><br><span class="line">		mov ax,b</span><br><span class="line">		mov ds,ax</span><br><span class="line"></span><br><span class="line">		mov bx,0</span><br><span class="line">		mov cx,8</span><br><span class="line">		</span><br><span class="line">s0:		mov dx,ds:[bx]</span><br><span class="line">		add es:[bx],dx</span><br><span class="line">		add bx,2</span><br><span class="line">		loop s0</span><br><span class="line">				</span><br><span class="line">		mov ax,4c00H</span><br><span class="line">		int 21H</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p><img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221019214952321.png" alt="image-20221019214952321"></p>
<h2 id="更灵活定位内存地址"><a class="markdownIt-Anchor" href="#更灵活定位内存地址">#</a> 更灵活定位内存地址</h2>
<p>and 逻辑与，按位进行与运算，通过该指令可以将操作对象响应为设为 0，只要和 0 and</p>
<p>or 逻辑或，按位进行或运算，通过该指令可以将操作对象相应位设为 0，只要和 1 or</p>
<p>通过’  ’ 括起来标识一个字符</p>
<p>db ‘unIX’  相当于 db 75H,6Eh,49H,58H   define byte</p>
<p>mov al,‘a’  相当于 mov al,61H</p>
<p>通过 将第五位二进制数和 0 与变为大写</p>
<p>[bx+idata] 表名一个内存单元，偏移地址为 idata</p>
<p>mov ax,[200+bx]</p>
<p>mov ax,[bx+200]</p>
<p>mov ax,200[bx]</p>
<p>mov ax,[bx].200</p>
<p>以上四个写法等效</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">		mov ax,datasg</span><br><span class="line">		mov ds,ax</span><br><span class="line">		mov bx,0</span><br><span class="line">		</span><br><span class="line">		mov cx,5</span><br><span class="line">s:		mov al,[bx]</span><br><span class="line">		and al,11011111b</span><br><span class="line">		mov [bx],al</span><br><span class="line">		mov al,[5+bx]</span><br><span class="line">		or al,00100000b</span><br><span class="line">		mov [5+bx],al</span><br><span class="line">		inc bx</span><br><span class="line">		loop s</span><br></pre></td></tr></table></figure>
<p>SI,DI</p>
<p>和 bx 功能相近，但不能分成两个八位寄存器使用</p>
<p>mov ax,[bx]</p>
<p>mov ax,[si]</p>
<p>mov ax,[di]</p>
<p>一般用 si 指向原始空间，di 指向目标空间</p>
<p>mov ax,[bx+si]  == mov ax,[bx][si]</p>
<p>[bx+si+idata] == mov ax,idata[bx][si]  ==  mov ax,[bx][si].200  == mov ax,[bx].200[si]</p>
<p>将 db 中的每个字母第一个变为大写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg, ds:datasg</span><br><span class="line"></span><br><span class="line">datasg segment</span><br><span class="line">	db &#x27;1.file       &#x27;</span><br><span class="line">	db &#x27;2.file       &#x27;</span><br><span class="line">	db &#x27;3.file       &#x27;</span><br><span class="line">	db &#x27;4.file       &#x27;</span><br><span class="line">	db &#x27;5.file       &#x27;</span><br><span class="line">	db &#x27;6.file       &#x27;</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">start:	mov dx,datasg</span><br><span class="line">		mov ds,dx</span><br><span class="line">		</span><br><span class="line">		mov bx,0</span><br><span class="line">		mov cx,6</span><br><span class="line">		</span><br><span class="line">s:		mov al,[bx+3]</span><br><span class="line">		and al,11011111b</span><br><span class="line">		mov [bx+3],al</span><br><span class="line">		add bx,16</span><br><span class="line">		loop s</span><br><span class="line">		</span><br><span class="line">		mov ax,4cooH</span><br><span class="line">		int 21H</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>将 datasg 的每个字母变为大写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg, ds:datasg</span><br><span class="line"></span><br><span class="line">datasg segment</span><br><span class="line">	db &#x27;add       &#x27;</span><br><span class="line">	db &#x27;asm       &#x27;</span><br><span class="line">	db &#x27;and       &#x27;</span><br><span class="line">	db &#x27;ano       &#x27;</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">start:	mov dx,datasg</span><br><span class="line">		mov ds,dx</span><br><span class="line">		</span><br><span class="line">		mov bx,0</span><br><span class="line">		mov cx,4</span><br><span class="line">		</span><br><span class="line">s0:		mov ax,cx</span><br><span class="line">		mov si,0</span><br><span class="line">		mov cx,3</span><br><span class="line">s:		mov al,[bx+si]</span><br><span class="line">        and al,11011111b</span><br><span class="line">        mov [bx+si],al</span><br><span class="line">        inc si</span><br><span class="line">        loop s</span><br><span class="line">		add bx,16</span><br><span class="line">		mov cx,ax</span><br><span class="line">		loop s0</span><br><span class="line"></span><br><span class="line">			</span><br><span class="line">		mov ax,4cooH</span><br><span class="line">		int 21H</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>这样做 cx 不会被覆盖导致死循环，进入循环前先保存起来</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg, ds:datasg</span><br><span class="line"></span><br><span class="line">datasg segment</span><br><span class="line">	db &#x27;add       &#x27;</span><br><span class="line">	db &#x27;asm       &#x27;</span><br><span class="line">	db &#x27;and       &#x27;</span><br><span class="line">	db &#x27;ano       &#x27;</span><br><span class="line">	dw 0    ;用于保存cx</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">start:	mov dx,datasg</span><br><span class="line">		mov ds,dx</span><br><span class="line">		</span><br><span class="line">		mov bx,0</span><br><span class="line">		mov cx,4</span><br><span class="line">		</span><br><span class="line">s0:		mov ds:[40H],cx</span><br><span class="line">		mov si,0</span><br><span class="line">		mov cx,3</span><br><span class="line">s:		mov al,[bx+si]</span><br><span class="line">        and al,11011111b</span><br><span class="line">        mov [bx+si],al</span><br><span class="line">        inc si</span><br><span class="line">        loop s</span><br><span class="line">		add bx,16</span><br><span class="line">		mov cx,ds:[40H]</span><br><span class="line">		loop s0</span><br><span class="line"></span><br><span class="line">			</span><br><span class="line">		mov ax,4cooH</span><br><span class="line">		int 21H</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>将 cx 放在内存中来解决寄存器不够的问题</p>
<p>更好的办法是使用栈，在调用函数前 push 到栈中，调用结束后 pop 回内存中，防止因为调用函数导致寄存器被篡改</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg, ds:datasg</span><br><span class="line"></span><br><span class="line">datasg segment</span><br><span class="line">	db &#x27;add       &#x27;</span><br><span class="line">	db &#x27;asm       &#x27;</span><br><span class="line">	db &#x27;and       &#x27;</span><br><span class="line">	db &#x27;ano       &#x27;</span><br><span class="line">	dw 0    ;用于保存cx</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">stacksg segment</span><br><span class="line">	dw 0,0,0,0,0,0,0,0</span><br><span class="line">stacksg ends</span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">start:	mov ax,stacksg</span><br><span class="line">		mov ss,ax</span><br><span class="line">		mov sp,16</span><br><span class="line">		mov ax,datasg</span><br><span class="line">		mov ds,ax</span><br><span class="line">		</span><br><span class="line">		mov bx,0</span><br><span class="line">		mov cx,4</span><br><span class="line">		</span><br><span class="line">s0:		push cx</span><br><span class="line">		mov si,0</span><br><span class="line">		mov cx,3</span><br><span class="line">s:		mov al,[bx+si]</span><br><span class="line">        and al,11011111b</span><br><span class="line">        mov [bx+si],al</span><br><span class="line">        inc si</span><br><span class="line">        loop s</span><br><span class="line">		add bx,16</span><br><span class="line">		pop cx</span><br><span class="line">		loop s0</span><br><span class="line"></span><br><span class="line">			</span><br><span class="line">		mov ax,4cooH</span><br><span class="line">		int 21H</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>将 datasg 段中每个单词的前四个字改为大写字</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">assume cs:codesg,ds:datasg,ss:stacksg</span><br><span class="line"></span><br><span class="line">datasg segment</span><br><span class="line">	db &#x27;1. display       &#x27;</span><br><span class="line">	db &#x27;2. display       &#x27;</span><br><span class="line">	db &#x27;3. display       &#x27;</span><br><span class="line">	db &#x27;4. display       &#x27;</span><br><span class="line">	dw 0    ;用于保存cx</span><br><span class="line">datasg ends</span><br><span class="line"></span><br><span class="line">stacksg segment</span><br><span class="line">	dw 0,0,0,0,0,0,0,0</span><br><span class="line">stacksg ends</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">codesg segment</span><br><span class="line">start:	mov ax,stacksg</span><br><span class="line">		mov ss,ax</span><br><span class="line">		mov sp,16 ;定位栈段</span><br><span class="line">		</span><br><span class="line">		mov ax,datasg</span><br><span class="line">		mov ds,ax  ;定位内存</span><br><span class="line">		</span><br><span class="line">		mov bx,0</span><br><span class="line">		mov cx,4  ;循环条件，bx偏移地址，cx循环条件，因为有四条字母，所以四次循环</span><br><span class="line">		</span><br><span class="line">s0:		push cx   ;外层循环，用户列循环，将cx入栈保证cx不受后续内层循环干扰</span><br><span class="line">		mov si,0</span><br><span class="line">		mov cx,4  ;内层循环，因为大写前四个字母，循环四次</span><br><span class="line">s:		mov al,[bx+3+si]</span><br><span class="line">        and al,11011111b</span><br><span class="line">        mov [bx+3+si],al</span><br><span class="line">        inc si</span><br><span class="line">        loop s</span><br><span class="line">		add bx,16</span><br><span class="line">		pop cx</span><br><span class="line">		loop s0</span><br><span class="line"></span><br><span class="line">			</span><br><span class="line">		mov ax,4cooH</span><br><span class="line">		int 21H</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<h2 id="数据处理的问题"><a class="markdownIt-Anchor" href="#数据处理的问题">#</a> 数据处理的问题</h2>
<p>reg 和 sreg  寄存器，段寄存器</p>
<p>只有四个寄存器 bx,bp,si,di 可以用在 [] 中进行内存单元的寻址，可以单个出现或四种组合出现</p>
<p>注意: mov ax [bp+bx]   mov ax,[si+di] 不能一起使用</p>
<p>bp 如果没有显示指定段地址，那么段地址默认在 ss 中，可以简单理解为 sp</p>
<p>mov ax,[bp]</p>
<p>mov ax,[bp+si]</p>
<p>mov ax,[bp+idata]</p>
<p>汇编语句用三个概念来表达数据的位置</p>
<p>1. 立即数</p>
<p>2. 寄存器</p>
<p>3. 段地址 (SA)，偏移地址 (EA)</p>
<p>段地址寄存器默认</p>
<p>mov ax,[0]   //==mov ax,ds:[0] , 注意，只有 0 能这么搞，其他的数字会被当成立即数处理，不会被当场偏移地址处理</p>
<p>mov ax,[bx+si]</p>
<p>mov ax,[bp]    // 段地址默认在 ss 中</p>
<p>段地址寄存器显示指出</p>
<p>mov ax,ds:[bp]</p>
<p>mov ax,cs:[bx+si+8]  // 显示指出可以随便给，默认指出就给 ss</p>
<p>寻址方式</p>
<img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221022185518717.png" alt="image-20221022185518717" style="zoom:67%;" />
<img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221022191402201.png" alt="image-20221022191402201" style="zoom:67%;" />
<blockquote>
<p>1. 将 cs：ip 通过地址加法器，算出一个 20 位的地址，通过地址总线，送到内存中，在内存中找到对应的位置</p>
<p>2. 将 1 找到的内存的数据，比如 A10E00 通过数据总线，送到指令缓冲寄存器中</p>
<p>3. 执行指令</p>
<p>4. 将所有偏移地址送到地址加法器中算出一个偏移地址，通过地址总线送到内存中</p>
<p>5. 将 4 中的数据，比如 A10E 通过数据总线，送给对应寄存器</p>
<p>6.IP 指向下一条指令</p>
</blockquote>
<p>确定要处理的数据有多长</p>
<p>1. 通过寄存器名指明数据大小 mov ax,1 这时 1 就是 16 位的，因为 ax 也是 16 位的    mov ax,ds:[0]  这时候 ds 偏移地址中数据也是八位的</p>
<p>2. 通过操作符 x ptr 指明内存单元长度，x 可以为 word 或 byte，可以理解为强制转换法</p>
<blockquote>
<p>mov word ptr ds:[0],1     // 这时 16 位的，0001H</p>
<p>inc word ptr [bx],2</p>
<p>mov byte ptr ds:[0],1  // 这时 8 位的，01H</p>
<p>double word ptr 双字</p>
</blockquote>
<p>3. 其他方法 push [1000H] 入栈，push 指令只对字进行操作 sp=sp-2</p>
<p>用 bx 定位整个结构体，用 idata 定位结构体中的某一个数据项，用 si 定位数组项中的每个元素。</p>
<p>[bx].idata</p>
<p>[bx].idata[si]</p>
<p>div</p>
<p>除数 8/16 位，被除数默认放在 ax,dx 和 ax 中</p>
<p>如果除数为 8 位，被除数需要 16 位 (ax)</p>
<p>如果除数为 16 位，被除数需要 32 位 (ax+dx),dx 是高位，ax 是低位</p>
<p>除数是 8 位的时候，商在 al 中，余数在 ah 中</p>
<p>除数是 16 位的时候，商在 ax 中，余数在 dx 中</p>
<p>div 寄存器</p>
<p>div 内存单元</p>
<p>div btye ptr ds:[0]   // <code>(al)=(ax)/((ds)*16+0)的商，(ah)=(ax)/((ds)*16+0)的余数</code></p>
<p>div word ptr es:[0]  // <code>(ax)=[(dx)*10000H+(ax)]/((ds)*16+0)的商，(dx)=[(dx)*10000H+(ax)]/((ds)*16)+0的余数</code></p>
<p>10001/100</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov dx,1</span><br><span class="line">mov ax,86a1</span><br><span class="line">mov bx,100</span><br><span class="line">div bx</span><br></pre></td></tr></table></figure>
<p>1001/100</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1001</span><br><span class="line">mob bl,100</span><br><span class="line">div bl</span><br></pre></td></tr></table></figure>
<p>dd 定义双字</p>
<p>用 div 计第 data 段中第一个数据除以第二个数据后的结果・商存放在第 3 个数据的存储单元。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data</span><br><span class="line">data segment</span><br><span class="line">	dd 100001</span><br><span class="line">	dw 100</span><br><span class="line">	dw 0</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:	mov ax,data	</span><br><span class="line">		mov ds,ax</span><br><span class="line">		mov ax,ds:[0]</span><br><span class="line">		mov dx,ds:[2]</span><br><span class="line">		</span><br><span class="line">		div word ptr ds:[4]</span><br><span class="line">		</span><br><span class="line">		mov ds:[6],ax</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		mov ax,4c00H</span><br><span class="line">		int 21H</span><br><span class="line">		</span><br><span class="line">codesg ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>dup</p>
<p>db 3 dup (0)   定义 3byte，他们值都是 0</p>
<p>db 3 dup(0,1,2)  //0,1,2,0,1,2,0,1,2</p>
<p>db 3 dup(‘abc’,‘ABC’)  //abcABCabcABCabcABC</p>
<p>db/dw/dd n dup()</p>
<h2 id="转移指令"><a class="markdownIt-Anchor" href="#转移指令">#</a> 转移指令</h2>
<p>8086 转移指令分为：</p>
<p>8086CPU 的转移行为有以下几类。</p>
<blockquote>
<p>1. 无条件转移</p>
<p>2. 条件转移指令</p>
<p>3. 循环指令</p>
<p>4. 过程</p>
<p>5. 中断</p>
</blockquote>
<ol>
<li></li>
</ol>
<p>jmp 无条件跳转</p>
<p>只修改 IP 时，称为段内转移，比如: jmp ax。</p>
<p>同时修改 CS 和 IP 时，称为段间转移，比如: jmp 1000:0。</p>
<p>由于转移指令对 IP 的修改范围不同，段内转移又分为：短转移和近转移。</p>
<p>短转移 IP 的修改范围为 - 128~127。</p>
<p>近转移 IP 的修改范围为 - 32768~32767。</p>
<p>操作符 offset</p>
<p>取得标号的偏移地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">start:	mov ax,offset start   ;mov ax,0</span><br><span class="line">s:		mov ax,offset s		  ;mov ax,3</span><br></pre></td></tr></table></figure>
<p>jmp 指令</p>
<p><code>jmp short 标号</code>   ；转移到标号处执行指令是种短转移，修改 IP 范围为 - 128-127</p>
<p>然鹅，jmp 0008 的机器码为 EB 03，0008 为需要跳转的命令地址</p>
<p>jmp 000A   EB 05</p>
<p>CPU 不需要目的地址就可以实现对 IP 的修改</p>
<p>EB 后面的数字实际是个 offset，说明目的指令离 jmp 五个字节</p>
<p><code>jmp near ptr 标号 </code>  , 用于实现段内近转移位移范围 - 32769-32767</p>
<p><code>jmp far ptr 标号</code>      // 段间转移，远转移</p>
<p>far ptr 指明了格用标号的段地址和偏移地址修改 CS 和 IP</p>
<p><img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221024210038120.png" alt="image-20221024210038120"></p>
<p>此时机器码为跳转的地址，IP 在前，CS 在后</p>
<p><code>jmp 16位寄存器</code></p>
<p>jmp ax     // 实现段内近 / 短转移，ax 中为 ip 的值</p>
<p>转移地址在内存中：</p>
<p><code>jmp word ptr 内存单元地址</code>     // 实现内存单元地址的段内转移，内存单元地址是目的地址</p>
<p>jmp word ptr ds:[0]</p>
<p>jmp word ptr [bx]</p>
<p><code>jmp dword ptr 内存单元地址</code>    // 段间跳转，跳转时 IP 是高位，CS 是低位</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,0123H</span><br><span class="line">mov [bx],ax</span><br><span class="line">mov word ptr [bx+2],0</span><br><span class="line">jmp dword ptr [bx]</span><br></pre></td></tr></table></figure>
<p>jcxz 标号；有条件跳转指令</p>
<p>IP 修改范围 - 128-127</p>
<p>如果 cx=0，转移到标号处</p>
<p>cx=0 时，IP 位移</p>
<p>cx!=0 向下执行</p>
<p>loop 标号</p>
<p>转移范围 - 128-127，短转移</p>
<p>cx=0 向下执行，cx！=0 转移到标号处</p>
<h2 id="call和ret"><a class="markdownIt-Anchor" href="#call和ret">#</a> call 和 ret</h2>
<p>call 和 ret 都是转移指令，他们都修改 IP，或者同时修改 CS:IP</p>
<p>ret 用栈中数据修改 IP 实现近转移</p>
<p>IP = SS*16 + SP</p>
<p>SP = SP + 2</p>
<p>pop ip</p>
<p>retf 修改 CS:IP 实现远转移</p>
<p>IP = SS*16 + SP</p>
<p>SP = SP + 2</p>
<p>CS = ss*16 + SP</p>
<p>(SP) = (SP) + 2</p>
<p>pop ip</p>
<p>pop cs</p>
<p>call</p>
<p>将 IP 或 CSIP 入栈，转移 (jmp)</p>
<p>call 不能实现短转移</p>
<p>call 标号   将当前 IP 压栈，转移到标号</p>
<p>sp = sp -2</p>
<p>ss*16 + sp = IP</p>
<p>IP = IP + 位移 (16 位)</p>
<p>相当于: push ip     +  jmp near ptr 标号</p>
<p>call 只是将当前位置保存到栈了，其余和 jmp 一样</p>
<p>call 16 位寄存器</p>
<p>push IP</p>
<p>jmp bx</p>
<p>转移地址在内存中 call</p>
<p>call word ptr 内存地址</p>
<p>push IP   jmp word ptr 偏移地址</p>
<p>call dword ptr 内存地址</p>
<p>push cs   push IP   jmp dword ptr 内存单元地址</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mov sp,10h</span><br><span class="line">mov ax,0123h</span><br><span class="line">mov ds:[0],ax</span><br><span class="line">mov word ptr ds:[2],0</span><br><span class="line">call dword ptr ds:[0]</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">此时ds中低位为0123(IP)，高位为0000(CS)</span><br><span class="line">call结束后,cs=0,ip=0123,sp=0ch</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">start: 	mov ax,1</span><br><span class="line">		mov cx,3</span><br><span class="line">		call s</span><br><span class="line">		mov bx,ax  ;bx=8</span><br><span class="line">		mov ax,4c00h</span><br><span class="line">		int 21h</span><br><span class="line">s:		add ax,ax</span><br><span class="line">		loop s</span><br><span class="line">		ret</span><br><span class="line">code ends</span><br><span class="line">end start    ;实现2^n</span><br></pre></td></tr></table></figure>
<p><img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221028213345088.png" alt="image-20221028213345088"></p>
<p>某种意义上来说，call 是调用，ret 是返回 (return)</p>
<p>call 和 ret 要对应</p>
<p>mul 指令</p>
<p>相乘的两个数要么都是 8 要么都是 16</p>
<p>8 位：AL 中或内存中</p>
<p>16 位：AX 中或内存中</p>
<p>结果：</p>
<p>8 位：ax 中</p>
<p>16 位：dx（高位），ax（低位）</p>
<p>mul 寄存器</p>
<p>mul 内存单元</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mul byte ptr ds:[0]</span><br><span class="line">ax = al * (ds:[0])</span><br><span class="line"></span><br><span class="line">mul word ptr [bx+si+8]</span><br><span class="line">ax=ax*([bx+si+8]) 低16位</span><br><span class="line">dx=ax*([bx+si+8]) 高16位</span><br></pre></td></tr></table></figure>
<p>100*10</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al,100</span><br><span class="line">mov b1,10</span><br><span class="line">mul bl</span><br></pre></td></tr></table></figure>
<p>即需要将任意一个乘数放在 ax 或 al 中，另一个乘数放在空闲的通用寄存器中</p>
<p>计算 n 的三次方</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cube:	mov ax,bx</span><br><span class="line">		mul bx</span><br><span class="line">		mul bx</span><br><span class="line">		ret</span><br></pre></td></tr></table></figure>
<p>dw 的三次方放入 dw 中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,cs:data,ss:stack</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">	dw 1,2,3,4,5,6,7,8</span><br><span class="line">	dw 0,0,0,0,0,0,0,0</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:	mov ax,data</span><br><span class="line">		mov ds,ax</span><br><span class="line">		</span><br><span class="line">		mov cx,8</span><br><span class="line">		mov si,0</span><br><span class="line">s:		mov bx,[si]  ;bx作为cube的参数</span><br><span class="line">		call cube</span><br><span class="line">		mov [si+32],ax</span><br><span class="line">		add ax,2</span><br><span class="line">		loop s</span><br><span class="line">		</span><br><span class="line">		mov ax,4c00H</span><br><span class="line">		int 21H</span><br><span class="line">		</span><br><span class="line">cube:	mov ax,bx	</span><br><span class="line">		mul bx</span><br><span class="line">		mul bx</span><br><span class="line">		ret</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>对于批量数据的传递，我们将它存在内存中，然后把首地址放在寄存器中</p>
<p>判断是否以 0 结束，不是就转为大写</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">capital:mov cl:[si]</span><br><span class="line">        mov ch,0</span><br><span class="line">        jcxz ok</span><br><span class="line">        and byte ptr[si],11011111b</span><br><span class="line">        inc si</span><br><span class="line">        jmp short capital</span><br></pre></td></tr></table></figure>
<h2 id="标志寄存器"><a class="markdownIt-Anchor" href="#标志寄存器">#</a> 标志寄存器</h2>
<p>8086CPU 的标志客存器有 16 位，其中存储的信息通常被称为程序状态字 (PSW) 。</p>
<p>标志寄存器结构：</p>
<img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221030202144281.png" alt="image-20221030202144281" style="zoom:67%;" />
<img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221030205228119.png" alt="image-20221030205228119" style="zoom:67%;" />
<img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221030205356183.png" alt="image-20221030205356183" style="zoom:67%;" />
<p>ZF</p>
<p>零标志位，执行指令后如果结果为 0，zf=1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ax,1</span><br><span class="line">sub ax,1 </span><br><span class="line">此时ZF=1</span><br></pre></td></tr></table></figure>
<p>运算指令，大多数会影响 ZF 寄存器</p>
<p>PF</p>
<p>奇偶标志位，指令执行后，如果 1 的个数为偶数，PF=1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al,1</span><br><span class="line">add al,10</span><br><span class="line">;00001011   PF=0  因为3个1</span><br></pre></td></tr></table></figure>
<p>SF</p>
<p>符号标志位，执行指令后，结果为负，SF=1</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov al,10000001</span><br><span class="line">add al,1</span><br><span class="line">;可以当做无符号，130，有符号，-126</span><br></pre></td></tr></table></figure>
<p>CF</p>
<p>进位标志位，无符号运算标志位可能产生结果</p>
<p>CF=NC 无进位，CF=CY 有进位，只记录上一条指令的变化</p>
<p>not carry carry</p>
<p>进位是更高位</p>
<p>OF</p>
<p>溢出标志位，有符号运算可能产生结果</p>
<p>OF=OV 溢出  OF=NV 无溢出</p>
<p>溢出是侵犯了符号位</p>
<p><strong>当成有符号就看 OF 和 SF，当成无符号就看 CF</strong></p>
<p>ADC</p>
<p>带进位加法指令，利用了 CF 上进位值</p>
<p>adc ax,bx   ;ax = ax + bx + cf</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov ax,2</span><br><span class="line">mov bx,1</span><br><span class="line">sub bx,ax</span><br><span class="line">adc ax,1</span><br><span class="line">;ax=4 ax+1+cf=2+1+1=4</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov al,98h</span><br><span class="line">add al,al</span><br><span class="line">adc al,3</span><br><span class="line">;ax+3+cf = 30+3+1=34</span><br></pre></td></tr></table></figure>
<p>加法分为两步</p>
<p>1. 低位相加</p>
<p>2. 高位相加，在加上低位相加产生的进位值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">add ax,bx</span><br><span class="line">===</span><br><span class="line">add al,bl</span><br><span class="line">adc ah,bh</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>就是那种 1EF000H+201000H</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:	mov ax,01EFH  ;high</span><br><span class="line">		mov bx,0F00H  ;low </span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">		mov cx,1000H  ;low</span><br><span class="line">		mov dx,0201H  ;high</span><br><span class="line">		</span><br><span class="line">		add bx,cx</span><br><span class="line">		adc ax,dx</span><br><span class="line">		</span><br><span class="line">cube:	mov ax,bx	</span><br><span class="line">		mul bx</span><br><span class="line">		mul bx</span><br><span class="line">		ret</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>或者只用两个寄存器</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mov ax,001EH</span><br><span class="line">mov bx,0F000H</span><br><span class="line">add bx,1000H</span><br><span class="line">adc ax,0020H</span><br></pre></td></tr></table></figure>
<p>inc 和 loop 不影响 CF 的值，因此不能替换为 add ax,2</p>
<p>sbb</p>
<p>带进位减法指令</p>
<p>sbb ax,bx</p>
<p>ax = ax - bx - cf</p>
<p>cmp</p>
<p>功能类似于减法指令，但不保存结果，只对标志寄存器产生影响</p>
<p>cmp ax,ax</p>
<p>ax-ax ，不保存结果，只影响 flag，ZF=1,PF=1,SF=1,CF=0,OF=0</p>
<p>cmp ax,bx</p>
<img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221031205029865.png" alt="image-20221031205029865" style="zoom:67%;" />
<p>cmp ax,ax</p>
<img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221031205427616.png" alt="image-20221031205427616" style="zoom:67%;" />
<p>cmp ah,bh 比较有符号数时，需要比较 SF 和 OF</p>
<p>sf=1,of=0,ah&lt;bh</p>
<p>SF=1,OF=1,ah&gt;bh</p>
<p>SF=0,of=1,ah&lt;bh</p>
<p>sf=0,of=0,ah&gt;=bh</p>
<p>据无符号数的比较结果进行转移的条件转移指令，它们检测 ZF,CF 的值；</p>
<p>和根据有符号数的比较结果进行转移的条件转移指令，它们检测 SF,OF ,ZF 的值・</p>
<p>以下都是无符号指令比较时</p>
<img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221031210918994.png" alt="image-20221031210918994" style="zoom:67%;" />
<p>equal</p>
<p>not equal</p>
<p>below</p>
<p>not below</p>
<p>above</p>
<p>not above</p>
<p>ah=bh,ah=ah+ah,ah=ah+bh</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:	mov ah,45h</span><br><span class="line">		mov bh 48h</span><br><span class="line">		</span><br><span class="line">		cmp ah,bh</span><br><span class="line">		je s</span><br><span class="line">		add ah,ah</span><br><span class="line">		jmp short ok</span><br><span class="line">s:		add ah,ah</span><br><span class="line">ok: 	ret</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>cmp 和 je 等可以单独出现</p>
<p>data 中是否小于 8，结果保存在 ax 中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code,ds:data</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">	db 1,2,3,4,5,6,7,8</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:	mov dx,data</span><br><span class="line">		mov ds,dx</span><br><span class="line">		mov ax,0</span><br><span class="line">		mov bx,0</span><br><span class="line">		mov cx,0</span><br><span class="line">		</span><br><span class="line">s0:		cmp byte ptr [bx],8</span><br><span class="line">		jnb s</span><br><span class="line">		inc ax</span><br><span class="line">		</span><br><span class="line">		</span><br><span class="line">s:		inc bx</span><br><span class="line">		loop s0</span><br><span class="line">		</span><br><span class="line">		mov ax,4c00h</span><br><span class="line">		int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>DF</p>
<p>方向标志位，串处理指令中，控制 si，di 增减</p>
<p>DF=0，si,di 递增</p>
<p>DF=1，si,di 递减</p>
<p>movsb</p>
<p>以字节为单位传送</p>
<p>1. <code>es*16 + di = ds*16+di</code></p>
<p>2. 如果 df=0，si,di++</p>
<p>如果 df=1，si,di–</p>
<p>movsw</p>
<p>和 movsb 一样，但 si 和 di 是以 2 递增或递减</p>
<p>rep movsb</p>
<p>rep movsw</p>
<p>根据 cx 的值，重复后面的串传送指令</p>
<p>循环实现 cx 个字符的传送，从 ds 送到 es</p>
<p>cld：将 DF=0</p>
<p>std：将 DF=1</p>
<p>将 data 段的第一个字符串送到后面的空间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">data segment</span><br><span class="line">	db &#x27;welcome to masm!&#x27;</span><br><span class="line">	db 16 dup (0)</span><br><span class="line">data ends</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:	mov dx,data</span><br><span class="line">		mov ds,dx</span><br><span class="line">		mov es,dx</span><br><span class="line">		</span><br><span class="line">		mov si,0</span><br><span class="line">		mov di,16</span><br><span class="line">		</span><br><span class="line">		mov cx,16</span><br><span class="line">		</span><br><span class="line">		cld</span><br><span class="line">		</span><br><span class="line">		rep movsb</span><br><span class="line"></span><br><span class="line">		mov ax,4c00h</span><br><span class="line">		int 21h</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br></pre></td></tr></table></figure>
<p>pushf</p>
<p>将标志寄存器压栈</p>
<p>popf 从栈中弹出数据，送入标志寄存器</p>
<p>比如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">push ax</span><br><span class="line">popf</span><br><span class="line"></span><br><span class="line">那么此时ax中就是标志寄存器中的值</span><br></pre></td></tr></table></figure>
<p>如果学破解，到这边就可以跑路了</p>
<hr>
<hr>
<hr>
<h2 id="中断"><a class="markdownIt-Anchor" href="#中断">#</a> 中断</h2>
<p>中断分为硬件中断和软件中断</p>
<p>硬件中断分为外部中断和内部中断</p>
<p>内部中断是不可屏蔽的中断</p>
<p>外部中断时可屏蔽的中断</p>
<p>中断向量表</p>
<p>CPU 用八位类型码通过中断向量表找到中断程序的入口地址</p>
<p>中断向量表可以裂解为一个索引</p>
<p>其中存放着 256 个中断源所对应的中断处理 程序入口</p>
<p>8086 中，中断向量表在 0000:0000 - 0000:03FF 1024 个字节</p>
<p>中断过程</p>
<p>1. 取得中断类型码 N</p>
<p>2.pushf</p>
<p>3.TF=0，IF=0</p>
<p>4.push cs</p>
<p>5.push ip</p>
<p>6. <code>(IP) = (N*4) , (CS) = (N*4+2)</code>    N*x 指的是在中断向量表中找 CS 和 IP</p>
<p>中断处理步骤</p>
<p>1. 保存用到的寄存器</p>
<p>2. 处理中断</p>
<p>3. 恢复用到的寄存器</p>
<p>4. 用 iret 指令返回</p>
<p>iret – pop ip  pop cs  popf</p>
<p>中断寄存器入栈标志，CS，IP。iret 正好和他相反</p>
<p>除法溢出，产生中断类型为 0</p>
<p>我们是可以改变中断后处理的过程的</p>
<p>改变 0 号中断处理程序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line"></span><br><span class="line">code segment</span><br><span class="line">start:	</span><br><span class="line">		mov ax, cs</span><br><span class="line">		mov ds, ax</span><br><span class="line">		mov si, offset do0		;设置ds:si指向源地址</span><br><span class="line">		mov ax, 0</span><br><span class="line">		mov es, ax</span><br><span class="line">		mov di, 200h			;设置es:di指向目的地址</span><br><span class="line">		mov cx, offset do0end - offset do0		;设置cx为传输长度</span><br><span class="line">		cld				        ;设置传输方向为正</span><br><span class="line">		rep movsb</span><br><span class="line">		</span><br><span class="line">		mov ax, 0               ;设置中断向量表</span><br><span class="line">		mov es, ax</span><br><span class="line">		mov word ptr es:[0*4], 200h</span><br><span class="line">		mov word ptr es:[0*4+2], 0</span><br><span class="line"></span><br><span class="line">      	mov ax,4c00h</span><br><span class="line">      	int 21h</span><br><span class="line"></span><br><span class="line">do0:	jmp short do0start</span><br><span class="line">      	db &quot;Welcome to Fishc.com!&quot;</span><br><span class="line"></span><br><span class="line">do0start:</span><br><span class="line">      	mov ax, cs</span><br><span class="line">      	mov ds, ax</span><br><span class="line">      	mov si, 202h			;设置ds:si指向字符串</span><br><span class="line"></span><br><span class="line">      	mov ax, 0b800h</span><br><span class="line">      	mov es, ax</span><br><span class="line">		mov di, 12*160+36*2		;设置es:di指向显存空间的中间位置</span><br><span class="line"></span><br><span class="line">        mov cx, 21				;设置cx为字符串长度</span><br><span class="line">	s:	mov al, [si]</span><br><span class="line">      	mov es:[di], al</span><br><span class="line">      	inc si</span><br><span class="line">      	add di, 1</span><br><span class="line">		mov al, 02h             ;设置颜色</span><br><span class="line">		mov es:[di], al        </span><br><span class="line">		add di, 1</span><br><span class="line">      	loop s</span><br><span class="line"></span><br><span class="line">      	mov ax, 4c00h</span><br><span class="line">      	int 21h</span><br><span class="line">do0end:	nop</span><br><span class="line"></span><br><span class="line">code ends</span><br><span class="line">end start</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>单步中断</p>
<p>CPU 在执行完一条指令之后，如果检到标志寄存器的 TF 位为 1，则产生单步中断，引发中断过程。</p>
<p>但不中断类型码为 1</p>
<p>中断过程：</p>
<p>取得中断类型码 1</p>
<p>TF=0 ,IF=0</p>
<p>CS,IP 入栈</p>
<p><code>IP=(1*4)  CS=(1*4+2)</code></p>
<p>TF=1, 执行程一条指令后执行单步中断</p>
<p>使用 t 命令是，debug 将 tf=1，执行完一条指令引发单步中断，显示寄存器，等待输入</p>
<p>也有情况，即使发生中断，也不响应</p>
<p>设置完 ss 后，即使中断，cpu 也不响应，因为 ss:sp 需要连续完成，不然 sp 指向的不是正确的栈顶</p>
<p>我们利用这个特性，将 ss 和 sp 的设置指令连续存放</p>
<p>mov ax,1000h</p>
<p>mov ss,ax</p>
<p>mov sp,0</p>
<p>mov ax,10</p>
<p>如果 ax=10 放在 sp 和 ss 中间，该指令不会被执行</p>

      <div class="tags">
          <a href="/tags/%E6%B1%87%E7%BC%96/" rel="tag"><i class="ic i-tag"></i> 汇编</a>
      </div>
  </div>

   <footer>

    <div class="meta">
  <span class="item">
    <span class="icon">
      <i class="ic i-calendar-check"></i>
    </span>
    <span class="text">Edited on</span>
    <time title="Modified: 2022-11-02 22:35:04" itemprop="dateModified" datetime="2022-11-02T22:35:04+08:00">2022-11-02</time>
  </span>
</div>

      
<div class="reward">
  <button><i class="ic i-heartbeat"></i> Donate</button>
  <p>Give me a cup of [coffee]~(￣▽￣)~*</p>
  <div id="qr">
      
      <div>
        <img data-src="/images/wechatpay.png" alt="John Doe WeChat Pay">
        <p>WeChat Pay</p>
      </div>
      
      <div>
        <img data-src="/images/alipay.png" alt="John Doe Alipay">
        <p>Alipay</p>
      </div>
      
      <div>
        <img data-src="/images/paypal.png" alt="John Doe PayPal">
        <p>PayPal</p>
      </div>
  </div>
</div>

      

<div id="copyright">
<ul>
  <li class="author">
    <strong>Post author:  </strong>John Doe <i class="ic i-at"><em>@</em></i>Hexo
  </li>
  <li class="link">
    <strong>Post link: </strong>
    <a href="http://example.com/2022/11/01/%E6%B1%87%E7%BC%96/" title="汇编">http://example.com/2022/11/01/汇编/</a>
  </li>
  <li class="license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> unless stating additionally.
  </li>
</ul>
</div>

  </footer>

</article>

  </div>
  

<div class="post-nav">
    <div class="item left">
      

  <a href="/2022/10/30/%E5%8F%91%E7%8E%B0%E5%B0%8F%E5%8F%AF%E7%88%B1%EF%BC%81/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva2.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipexoj0moj20zk0m8kgu.jpg" title="about me">
  <span class="type">Previous Post</span>
  <span class="category"><i class="ic i-flag"></i> </span>
  <h3>about me</h3>
  </a>

    </div>
    <div class="item right">
    </div>
</div>

  
  <div class="wrap" id="comments"></div>


        </div>
        <div id="sidebar">
          

<div class="inner">

  <div class="panels">
    <div class="inner">
      <div class="contents panel pjax" data-title="Contents">
          <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B1%87%E7%BC%96"><span class="toc-number">1.</span> <span class="toc-text"> 汇编</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8cpu"><span class="toc-number">1.1.</span> <span class="toc-text"> 寄存器（CPU）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E5%86%85%E5%AD%98"><span class="toc-number">1.2.</span> <span class="toc-text"> 寄存器（内存）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88"><span class="toc-number">1.2.0.1.</span> <span class="toc-text"> 栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E9%A1%B6%E8%B6%8A%E7%95%8C"><span class="toc-number">1.2.0.2.</span> <span class="toc-text"> 栈顶越界</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0"><span class="toc-number">1.2.0.3.</span> <span class="toc-text"> 练习</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E7%BC%96%E5%86%99"><span class="toc-number">1.3.</span> <span class="toc-text"> 程序编写</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bxloop"><span class="toc-number">1.4.</span> <span class="toc-text"> [bx]&amp;loop</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E4%B8%AA%E6%AE%B5%E7%9A%84%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.5.</span> <span class="toc-text"> 多个段的程序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9B%B4%E7%81%B5%E6%B4%BB%E5%AE%9A%E4%BD%8D%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80"><span class="toc-number">1.6.</span> <span class="toc-text"> 更灵活定位内存地址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%A4%84%E7%90%86%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.7.</span> <span class="toc-text"> 数据处理的问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AC%E7%A7%BB%E6%8C%87%E4%BB%A4"><span class="toc-number">1.8.</span> <span class="toc-text"> 转移指令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#call%E5%92%8Cret"><span class="toc-number">1.9.</span> <span class="toc-text"> call 和 ret</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E5%BF%97%E5%AF%84%E5%AD%98%E5%99%A8"><span class="toc-number">1.10.</span> <span class="toc-text"> 标志寄存器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD"><span class="toc-number">1.11.</span> <span class="toc-text"> 中断</span></a></li></ol></li></ol>
      </div>
      <div class="related panel pjax" data-title="Related">
        <ul>
          <li class="active"><a href="/2022/11/01/%E6%B1%87%E7%BC%96/" rel="bookmark" title="汇编">汇编</a></li>
        </ul>
      </div>
      <div class="overview panel" data-title="Overview">
        <div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="image" itemprop="image" alt="John Doe"
      data-src="/images/avatar.jpg">
  <p class="name" itemprop="name">John Doe</p>
  <div class="description" itemprop="description"></div>
</div>

<nav class="state">
    <div class="item posts">
      <a href="/archives/">
        <span class="count">10</span>
        <span class="name">posts</span>
      </a>
    </div>
    <div class="item categories">
      <a href="/categories/">
        <span class="count">3</span>
        <span class="name">categories</span>
      </a>
    </div>
    <div class="item tags">
      <a href="/tags/">
        <span class="count">4</span>
        <span class="name">tags</span>
      </a>
    </div>
</nav>

<div class="social">
</div>

<ul class="menu">
  
    
  <li class="item">
    <a href="/" rel="section"><i class="ic i-home"></i>Home</a>
  </li>


</ul>

      </div>
    </div>
  </div>

  <ul id="quick">
    <li class="prev pjax">
    </li>
    <li class="up"><i class="ic i-arrow-up"></i></li>
    <li class="down"><i class="ic i-arrow-down"></i></li>
    <li class="next pjax">
    </li>
    <li class="percent"></li>
  </ul>
</div>


        </div>
        <div class="dimmer"></div>
      </div>
    </main>
    <footer id="footer">
      <div class="inner">
        <div class="widgets">
          
<div class="rpost pjax">
  <h2>Random Posts</h2>
  <ul>
      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/web%E5%AE%89%E5%85%A8/" title="In web安全">web安全</a>
</div>

    <span><a href="/2022/03/16/SQL%E6%B3%A8%E5%85%A5/" title="SQL injection">SQL injection</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E9%80%86%E5%90%91/" title="In 逆向">逆向</a>
</div>

    <span><a href="/2022/11/01/%E6%B1%87%E7%BC%96/" title="汇编">汇编</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/web%E5%AE%89%E5%85%A8/" title="In web安全">web安全</a>
</div>

    <span><a href="/2022/04/16/Upload/" title="File upload">File upload</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/2022/10/30/%E5%8F%91%E7%8E%B0%E5%B0%8F%E5%8F%AF%E7%88%B1%EF%BC%81/" title="about me">about me</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/web%E5%AE%89%E5%85%A8/" title="In web安全">web安全</a>
</div>

    <span><a href="/2022/05/27/CSRF/" title="CSRF">CSRF</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E7%A7%8B%E6%8B%9B/" title="In 秋招">秋招</a>
</div>

    <span><a href="/2022/10/27/%E7%A7%8B%E6%8B%9B%E6%80%BB%E7%BB%93/" title="秋招总结">秋招总结</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E7%A7%8B%E6%8B%9B/" title="In 秋招">秋招</a>
</div>

    <span><a href="/2022/10/28/%E7%A7%8B%E6%8B%9B%E9%9D%A2%E8%AF%95%E9%A2%98/" title="秋招面试题">秋招面试题</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/web%E5%AE%89%E5%85%A8/" title="In web安全">web安全</a>
</div>

    <span><a href="/2022/05/17/include/" title="file include">file include</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/web%E5%AE%89%E5%85%A8/" title="In web安全">web安全</a>
</div>

    <span><a href="/2022/02/17/XSS/" title="XSS">XSS</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/2022/10/16/hello-world/" title="Hello World">Hello World</a></span>
  </li>

  </ul>
</div>
<div>
  <h2>Recent Comments</h2>
  <ul class="leancloud-recent-comment"></ul>
</div>

        </div>
        <div class="status">
  <div class="copyright">
    
    &copy; 2010 – 
    <span itemprop="copyrightYear">2022</span>
    <span class="with-love">
      <i class="ic i-sakura rotate"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">John Doe @ Yume Shoka</span>
  </div>
  <div class="powered-by">
    Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span>
  </div>
</div>

      </div>
    </footer>
  </div>
<script data-config type="text/javascript">
  var LOCAL = {
    path: '2022/11/01/汇编/',
    favicon: {
      show: "（●´3｀●）Goooood",
      hide: "(´Д｀)Booooom"
    },
    search : {
      placeholder: "Search for Posts",
      empty: "We didn't find any results for the search: ${query}",
      stats: "${hits} results found in ${time} ms"
    },
    valine: true,fancybox: true,
    copyright: 'Copied to clipboard successfully! <br> All articles in this blog are licensed under <i class="ic i-creative-commons"></i>BY-NC-SA.',
    ignores : [
      function(uri) {
        return uri.includes('#');
      },
      function(uri) {
        return new RegExp(LOCAL.path+"$").test(uri);
      }
    ]
  };
</script>

<script src="https://cdn.polyfill.io/v2/polyfill.js"></script>

<script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script>

<script src="/js/app.js?v=0.2.5"></script>




</body>
</html>
