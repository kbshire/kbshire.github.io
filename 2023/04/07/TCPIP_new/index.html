



<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#FFF">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">


<link rel="alternate" type="application/rss+xml" title="Hexo" href="http://example.com/rss.xml" />
<link rel="alternate" type="application/atom+xml" title="Hexo" href="http://example.com/atom.xml" />
<link rel="alternate" type="application/json" title="Hexo" href="http://example.com/feed.json" />

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">

<link rel="stylesheet" href="/css/app.css?v=0.2.5">

  

<link rel="canonical" href="http://example.com/2023/04/07/TCPIP_new/">



  <title>
TCP/IP |
Yume Shoka = Hexo</title>
<meta name="generator" content="Hexo 5.4.2"></head>
<body itemscope itemtype="http://schema.org/WebPage">
  <div id="loading">
    <div class="cat">
      <div class="body"></div>
      <div class="head">
        <div class="face"></div>
      </div>
      <div class="foot">
        <div class="tummy-end"></div>
        <div class="bottom"></div>
        <div class="legs left"></div>
        <div class="legs right"></div>
      </div>
      <div class="paw">
        <div class="hands left"></div>
        <div class="hands right"></div>
      </div>
    </div>
  </div>
  <div id="container">
    <header id="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="inner">
        <div id="brand">
          <div class="pjax">
          
  <h1 itemprop="name headline">TCP/IP
  </h1>
  
<div class="meta">
  <span class="item" title="Created: 2023-04-07 13:38:45">
    <span class="icon">
      <i class="ic i-calendar"></i>
    </span>
    <span class="text">Posted on</span>
    <time itemprop="dateCreated datePublished" datetime="2023-04-07T13:38:45+08:00">2023-04-07</time>
  </span>
</div>


          </div>
        </div>
        <nav id="nav">
  <div class="inner">
    <div class="toggle">
      <div class="lines" aria-label="Toggle navigation bar">
        <span class="line"></span>
        <span class="line"></span>
        <span class="line"></span>
      </div>
    </div>
    <ul class="menu">
      <li class="item title"><a href="/" rel="start">Yume Shoka</a></li>
    </ul>
    <ul class="right">
      <li class="item theme">
        <i class="ic i-sun"></i>
      </li>
      <li class="item search">
        <i class="ic i-search"></i>
      </li>
    </ul>
  </div>
</nav>

      </div>
      <div id="imgs" class="pjax">
        <ul>
          <li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/13818173de445fa048acb5e72b8e650e.jpg"></li>
          <li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/a05ebdd3b7f197e626fa1253c6521ef5.jpg"></li>
          <li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/662d37b8a580b466da309ec795b7ae55.jpg"></li>
          <li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/2a42af8906eaa0a898ee31569cbd2661.jpg"></li>
          <li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/4c0b0c164bd2511ebcbfec05cd2a7b58.jpg"></li>
          <li class="item" data-background-image="https://img.timelessq.com/images/2022/07/26/545e6f6f8db4a66e412bf2c5213d3d10.jpg"></li>
        </ul>
      </div>
    </header>
    <div id="waves">
      <svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto">
        <defs>
          <path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z" />
        </defs>
        <g class="parallax">
          <use xlink:href="#gentle-wave" x="48" y="0" />
          <use xlink:href="#gentle-wave" x="48" y="3" />
          <use xlink:href="#gentle-wave" x="48" y="5" />
          <use xlink:href="#gentle-wave" x="48" y="7" />
        </g>
      </svg>
    </div>
    <main>
      <div class="inner">
        <div id="main" class="pjax">
          
  <div class="article wrap">
    
<div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList">
<i class="ic i-home"></i>
<span><a href="/">Home</a></span>
</div>

    <article itemscope itemtype="http://schema.org/Article" class="post block" lang="en">
  <link itemprop="mainEntityOfPage" href="http://example.com/2023/04/07/TCPIP_new/">

  <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="image" content="/images/avatar.jpg">
    <meta itemprop="name" content="John Doe">
    <meta itemprop="description" content=", ">
  </span>

  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="Hexo">
  </span>

  <div class="body md" itemprop="articleBody">
    

    <h1 id="tcpip"><a class="markdownIt-Anchor" href="#tcpip">#</a> TCP/IP</h1>
<h2 id="tcp-协议报文格式"><a class="markdownIt-Anchor" href="#tcp-协议报文格式">#</a> TCP 协议报文格式</h2>
<img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/20210308122904344.png" alt="在这里插入图片描述" style="zoom:50%;" /> 
<blockquote>
<p><strong>SPORT</strong></p>
<p><strong>DPORT</strong></p>
<p><strong>Seq Num:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">序号（Sequence Number）的语义与SYN控制标志（Control Bits）的值有关。根据控制标志（Control Bits）中的SYN是否为1，序号（Sequence</span><br><span class="line">Number）表达不同的含义：</span><br><span class="line"></span><br><span class="line">（1）当SYN = 1时，当前为连接建立阶段，此时的序号为初始序号ISN((Initial Sequence Number)，通过算法来随机生成序号；</span><br><span class="line"></span><br><span class="line">（2）当SYN = 0时在数据传输正式开始时，第一个报文的序号为 ISN + 1，后面的报文的序号，为前一个报文的SN值+TCP报文的净荷字节数(不包含TCP头)。比如，如果发送端发送的一个TCP帧的净荷为12byte，序号为5，则发送端接着发送的下一个数据包的时候，序号的值应该设置为5+12=17。</span><br><span class="line"></span><br><span class="line">在数据传输过程中，TCP协议通过序号（Sequence Number）对上层提供有序的数据流。发送端可以用序号来跟踪发送的数据量；接收端可以用序号识别出重复接收到的TCP包，从而丢弃重复包；对于乱序的数据包，接收端也可以依靠序号对其进行排序。</span><br></pre></td></tr></table></figure>
<p><img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20230413100525066.png" alt="image-20230413100525066"></p>
<p><strong>Ack Num</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">确认序号（Acknowledgment Number）标识了报文接收端期望接收的字节序列。如果设置了ACK控制位，确认序号的值表示一个准备接收的包的序列码，注意，它所指向的是准备接收的包，也就是下一个期望接收的包的序列码。</span><br></pre></td></tr></table></figure>
<img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/20210308123045409.png" alt="在这里插入图片描述" style="zoom: 67%;" /> 
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">只有控制标志的ACK标志为1时，数据帧中的确认序号ACK</span><br><span class="line">Number才有效。TCP协议规定，连接建立后，所有发送的报文的ACK必须为1，也就是建立连接后，所有报文的确认序号有效。如果是SYN类型的报文，其ACK标志为0，故没有确认序号。</span><br></pre></td></tr></table></figure>
<p><strong>header length</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">该字段占用4位，用来表示TCP报文首部的长度，单位是4bit位。其值所表示的并不是字节数，而是头部的所含有的32bit的数目（或者倍数），或者4个字节的倍数，所以TCP头部最多可以有60字节（4*15=60）。没有任何选项字段的TCP头部长度为20字节，所以其头部长度为5，可以通过20/4=5计算得到。</span><br></pre></td></tr></table></figure>
<p><strong>reverse</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">头部长度后面预留的字段长度为6位，作为保留字段，暂时没有什么用处。</span><br></pre></td></tr></table></figure>
<p><strong>control flags</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">控制标志（Control Bits）共6个bit位，具体的标志位为：URG、ACK、PSH、RST、SYN、FIN。</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>标志位</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>URG</td>
<td>占 1 位，表示紧急指针字段有效。URG 位指示报文段里的上层实体（数据）标记为 “紧急” 数据。当 URG=1 时，其后的紧急指针指示紧急数据在当前数据段中的位置 (相对于当前序列号的字节偏移量)，TCP 接收方必须通知上层实体。</td>
</tr>
<tr>
<td>ACK</td>
<td>占 1 位，置位 ACK=1 表示确认号字段有效；TCP 协议规定，<strong>接建立后所有发送的报文的 ACK 必须为 1</strong>；当 ACK=0 时，表示该数据段不包含确认信息。当 ACK=1 时，表示该报文段包括一个对已被成功接收报文段的确认序号 Acknowledgment Number，该序号同时也是下一个报文的预期序号。</td>
</tr>
<tr>
<td>PSH</td>
<td>占 1 位，表示当前报文需要请求推（push）操作；当 PSH=1 时，接收方在收到数据后立即将数据交给上层，而不是直到整个缓冲区满。</td>
</tr>
<tr>
<td>RST</td>
<td>占 1 位，置位 RST=1 表示复位 TCP 连接；用于重置一个已经混乱的连接，也可用于拒绝一个无效的数据段或者拒绝一个连接请求。如果数据段被设置了 RST 位，说明报文发送方有问题发生。</td>
</tr>
<tr>
<td>SYN</td>
<td>占 1 位，在连接建立时用来同步序号。当 SYN=1 而 ACK=0 时，表明这是一个连接请求报文。对方若同意建立连接，则应在响应报文中使 SYN=1 和 ACK=1。 综合一下，SYN 置 1 就表示这是一个连接请求或连接接受报文。</td>
</tr>
<tr>
<td>FIN</td>
<td>占 1 位，用于在释放 TCP 连接时，标识发送方比特流结束，用来释放一个连接。当 FIN = 1 时，表明此报文的发送方的数据已经发送完毕，并要求释放连接。</td>
</tr>
</tbody>
</table>
<p><strong>窗口大小</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">长度为16位，共2个字节。此字段用来进行流量控制。流量控制的单位为字节数，这个值是本端期望一次接收的字节数。</span><br></pre></td></tr></table></figure>
<p><strong>Checksum</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">长度为16位，共2个字节。对整个TCP报文段，即TCP头部和TCP数据进行校验和计算，接收端用于对收到的数据包进行验证。</span><br></pre></td></tr></table></figure>
<blockquote>
<p>首先，把伪首部、TCP 报头、TCP 数据分为 16 位的字，如果总长度为奇数个字节，则在最后增添一个位都为 0 的字节。把 TCP 报头中的校验和字段置为 0</p>
<p>其次，用反码相加法累加所有的 16 位字（进位也要累加）。</p>
<p>最后，对计算结果取反，作为 TCP 的校验和。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">short</span> </span><br><span class="line"><span class="title function_">checksum</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> * addr, <span class="type">int</span> count)</span></span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">计算所有数据的16bit对之和</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">    <span class="keyword">while</span>( count &gt; <span class="number">1</span>  )  &#123;</span><br><span class="line">        <span class="comment">/*  This is the inner loop */</span></span><br><span class="line">        sum += *(<span class="type">unsigned</span> <span class="type">short</span>*)addr++;</span><br><span class="line"></span><br><span class="line">        count -= <span class="number">2</span></span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果数据长度为奇数，在该字节之后补一个字节(0),</span></span><br><span class="line"><span class="comment">   然后将其转换为16bit整数，加到上面计算的校验和</span></span><br><span class="line"><span class="comment">　　中。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">if</span>( count &gt; <span class="number">0</span> ) &#123; </span><br><span class="line">        <span class="type">char</span> left_over[<span class="number">2</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        left_over[<span class="number">0</span>] = *addr;</span><br><span class="line">        sum += * (<span class="type">unsigned</span> <span class="type">short</span>*) left_over;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line"><span class="comment">/*  将32bit数据压缩成16bit数据，即将进位加大校验和</span></span><br><span class="line"><span class="comment">　　的低字节上，直到没有进位为止。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">    <span class="keyword">while</span> (sum&gt;&gt;<span class="number">16</span>)</span><br><span class="line">        sum = (sum &amp; <span class="number">0xffff</span>) + (sum &gt;&gt; <span class="number">16</span>);</span><br><span class="line">　　</span><br><span class="line">  　<span class="comment">/*返回校验和的反码*/</span></span><br><span class="line">   <span class="keyword">return</span> ~sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>紧急指针</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">长度为16位，2个字节。它是一个偏移量，和SN序号值相加表示紧急数据最后一个字节的序号。</span><br></pre></td></tr></table></figure>
<p><strong>Option&amp;pedding</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">可选项和填充部分的长度为4n字节（n是整数），该部分是根据需要而增加的选项。如果不足4n字节，要加填充位，使得选项长度为32位（4字节）的整数倍，具体的做法是在这个字段中加入额外的零，以确保TCP头是32位（4字节）的整数倍。</span><br><span class="line"></span><br><span class="line">最常见的选项字段是MSS（Maximum Segment Size最长报文大小），每个连接方通常都在通信的第一个报文段（SYN标志为1的那个段）中指明这个选项字段，表示当前连接方所能接受的最大报文段的长度。</span><br></pre></td></tr></table></figure>
<p>由于可选项和填充部分不是必须的，所以 TCP 报文首部最小长度为 20 个字节。</p>
<p><strong>data</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数据部分是可选的。在一个连接建立和一个连接终止时，双方交换的报文段仅有TCP首部。如果一方没有数据要发送，也使用没有任何数据的首部来确认收到的数据，比如在处理超时的过程中，也会发送不带任何数据的报文段。</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="tcp-可靠性"><a class="markdownIt-Anchor" href="#tcp-可靠性">#</a> TCP 可靠性</h2>
<blockquote>
<p>（1）应用数据分割成 TCP 认为最适合发送的数据块。这部分是通过 MSS（最大数据包长度）选项来控制的，通常这种机制也被称为一种协商机制，MSS 规定了 TCP 传往另一端的最大数据块的长度。值得注意的是，<strong>MSS 只能出现在 SYN 报文段中</strong>，若一方不接收来自另一方的 MSS 值，则 MSS 就定为 536 字节。一般来讲，MSS 值还是越大越好，这样可以提高网络的利用率。</p>
<p>（2）重传机制。设置定时器，等待确认包，如果定时器超时还没有收到确认包，则报文重传。</p>
<p>（3）对首部和数据进行校验。</p>
<p>（4）接收端对收到的数据进行排序，然后交给应用层。</p>
<p>（5）接收端丢弃重复的数据。</p>
<p>（6）TCP 还提供流量控制，主要是通过滑动窗口来实现流量控制。</p>
</blockquote>
<h2 id="tcp-三次握手"><a class="markdownIt-Anchor" href="#tcp-三次握手">#</a> TCP 三次握手</h2>
<blockquote>
<p>当服务端调用操作系统的 bind () 函数和 listen () 函数后，服务端就会处于 LISTENING 状态。</p>
<img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/20210308122934847.png" alt="在这里插入图片描述" style="zoom:67%;" /> 
<blockquote>
<p>（1）第一次握手：Client 进入 SYN_SENT 状态，发送一个 SYN 帧来主动打开传输通道，该帧的 SYN 标志位被设置为 1，同时会带上 Client 分配好的 SN 序列号，该 SN 是根据时间产生的一个随机值。除此之外，SYN 帧还会带一个 MSS（最大报文段长度）可选项的值，表示客户端发送出去的最大数据块的长度。</p>
<p>​	这个报文段并不包括确认号，也没有定义窗口大小。<strong>只有当一个报文段中包含了确认时，定义窗口大小才有意义</strong>。这个报文段还可以包含一些选项。SYN 报文段是一个控制报文段，它不包含任何数据，但是它消耗了一个序号。</p>
<p>​	当数据传送开始时，序号就应该加 1。也就是说，SYN 报文段并不包含真正的数据，但是它要消耗一个序号。</p>
<p>（2）第二次握手：Server 端在收到 SYN 帧之后，会进入 SYN_RCVD 状态，同时返回 SYN+ACK 帧给 Client，主要目的在于通知 Client，Server 端已经收到 SYN 消息，现在需要进行确认。Server 端发出的 SYN+ACK 帧的 ACK 标志位被设置为 1，其确认序号 AN（Acknowledgment<br>
Number）值被设置为 Client 的 SN+1；SYN+ACK 帧的 SYN 标志位被设置为 1，SN 值为 Server 端生成的 SN 序号；SYN+ACK 帧的 MSS（最大报文段长度）表示的是 Server 端的最大数据块长度。</p>
<p>​	因为这个报文段包含了确认，所以他还需要定义接收窗口大小 ——rwnd。</p>
<p>​	SYN+ACK 报文段若携带数据，则消耗一个序号，否则不消耗。</p>
<p>（3）第三次握手：Client 在收到 Server 的第二次握手 SYN+ACK 确认帧之后，首先将自己的状态会从 SYN_SENT 变成 ESTABLISHED，表示自己方向的连接通道已经建立成功，Client 可以发送数据给 Server 端了。然后，Client 发 ACK 帧给 Server 端，该 ACK 帧的 ACK 标志位被设置为 1，其确认序号 AN（Acknowledgment Number）值被设置为 Server 端的 SN 序列号 + 1。</p>
<p>（4）Server 端在收到 Client 的 ACK 帧之后，会从 SYN_RCVD 状态会进入 ESTABLISHED 状态，至此，Server 方向的通道连接建立成功，Server 可以发送数据给 Client，TCP 的全双工连接建立完成。</p>
</blockquote>
</blockquote>
<h2 id="tcp四次挥手"><a class="markdownIt-Anchor" href="#tcp四次挥手">#</a> TCP 四次挥手</h2>
<blockquote>
<p>TCP 连接开始断开（或者拆接）的过程，在这个过程中连接的每个端的都能独立地、主动的发起，断开的过程</p>
<img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/20210308122951816.png" alt="在这里插入图片描述" style="zoom:67%;" /> 
<blockquote>
<p>（1）第一次挥手：主动断开方（可以是客户端，也可以是服务器端），向对方发送一个 FIN 结束请求报文，此报文的 FIN 位被设置为 1，并且正确设置 Sequence Number（序列号）和 Acknowledgment Number（确认号）。发送完成后，主动断开方进入 FIN_WAIT_1 状态，这表示主动断开方没有业务数据要发送给对方，准备关闭 SOCKET 连接了。</p>
<p>（2）第二次挥手：正常情况下，在收到了主动断开方发送的 FIN 断开请求报文后，被动断开方会发送一个 ACK 响应报文，报文 Acknowledgment Number（确认号）值为断开请求报文的 Sequence Number（序列号）加 1，该 ACK 确认报文的含义是：“我同意你的连接断开请求”。之后，被动断开方就进入了 CLOSE-WAIT（关闭等待）状态，TCP 协议服务会通知高层的应用进程，对方向本地方向的连接已经关闭，** 对方已经没有数据要发送了，若本地还要发送数据给对方，对方依然会接受。** 被动断开方的 CLOSE-WAIT（关闭等待）还要持续一段时间，也就是整个 CLOSE-WAIT 状态持续的时间。</p>
<p>主动断开方在收到了 ACK 报文后，由 FIN_WAIT_1 转换成 FIN_WAIT_2 状态。</p>
<p>（3）第三次挥手：在发送完成 ACK 报文后，被动断开方还可以继续完成业务数据的发送，待剩余数据发送完成后，或者 CLOSE-WAIT（关闭等待）截止后，被动断开方会向主动断开方发送一个 FIN+ACK 结束响应报文，<strong>表示被动断开方的数据都发送完了</strong>，然后，被动断开方进入 LAST_ACK 状态。</p>
<p>（4）第四次挥手：主动断开方收在到 FIN+ACK 断开响应报文后，还需要进行最后的确认，向被动断开方发送一个 ACK 确认报文，然后，自己就进入 TIME_WAIT 状态，等待超时后最终关闭连接。处于 TIME_WAIT 状态的主动断开方，在等待完成 2MSL 的时间后，如果期间没有收到其他报文，则证明对方已正常关闭，主动断开方的连接最终关闭。</p>
<p>被动断开方在收到主动断开方的最后的 ACK 报文以后，最终关闭了连接，自己啥也不管了。</p>
</blockquote>
<p>处于 TIME_WAIT 状态的主动断开方，在等待完成 2MSL 的时间后，才真正关闭连接通道</p>
<p>2MSL 翻译过来就是两倍的 MSL。MSL 全称为 Maximum Segment Lifetime，指的是<strong>一个 TCP 报文片段在网络中最大的存活时间</strong>，具体来说，2MSL 对应于一次消息的来回（一个发送和一个回复）所需的最大时间。如果直到 2MSL，主动断开方都没有再一次收到对方的报文（如 FIN 报文），则可以推断 ACK 已经被对方成功接收，此时，主动断开方将最终结束自己的 TCP 连接。所以，TCP 的 TIME_WAIT 状态也称为 2MSL 等待状态。</p>
</blockquote>
<h2 id="脑溢血环节"><a class="markdownIt-Anchor" href="#脑溢血环节">#</a> 脑溢血环节</h2>
<blockquote>
<p><strong>为什么关闭连接的需要四次挥手，而建立连接却只要三次握手呢？</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">关闭连接时，被动断开方在收到对方的FIN结束请求报文时，很可能业务数据没有发送完成，并不能立即关闭连接，被动方只能先回复一个ACK响应报文，告诉主动断开方：“你发的FIN报文我收到了，只有等到我所有的业务报文都发送完了，我才能真正的结束，在结束之前，我会发你FIN+ACK报文的，你先等着”。所以，被动断开方的确认报文，需要拆开成为两步，故总体就需要四步挥手。</span><br><span class="line"></span><br><span class="line">而在建立连接场景中，Server端的应答可以稍微简单一些。当Server端收到Client端的SYN连接请求报文后，其中ACK报文表示对请求报文的应答，SYN报文用来表示服务端的连接也已经同步开启了，而ACK报文和SYN报文之间，不会有其他报文需要发送，故而可以合二为一，可以直接发送一个SYN+ACK报文。所以，在建立连接时，只需要三次握手即可。</span><br><span class="line"></span><br><span class="line">简单的说，断开连接时可能还有数据报文的交互，不能直接断开，要等数据发送完再说。建立时没有其他的数据报文，可以把两个合二为一发送</span><br></pre></td></tr></table></figure>
<p><strong>为什么连接建立的时候是三次握手，可以改成两次握手吗？</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">三次握手完成两个重要的功能：一是双方都做好发送数据的准备工作，而且双方都知道对方已准备好；二是双方完成初始SN序列号的协商，双方的SN序列号在握手过程中被发送和确认。三是确定客户端和服务端的MSS</span><br><span class="line"></span><br><span class="line">如果把三次握手改成两次握手，可能发生死锁。两次握手的话，缺失了Client的二次确认ACK帧，假想的TCP建立的连接时二次挥手，可以如下图所示：</span><br></pre></td></tr></table></figure>
<img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/20210308123012842.png" alt="在这里插入图片描述" style="zoom:67%;" /> 
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在假想的TCP建立的连接时二次握手过程中，Client发送Server发送一个SYN请求帧，Server收到后发送了确认应答SYN+ACK帧。按照两次握手的协定，Server认为连接已经成功地建立了，可以开始发送数据帧。这个过程中，如果确认应答SYN+ACK帧在传输中被丢失，Client没有收到，Client将不知道Server是否已准备好，也不知道Server的SN序列号，Client认为连接还未建立成功，将忽略Server发来的任何数据分组，会一直等待Server的SYN+ACK确认应答帧。而Server在发出的数据帧后，一直没有收到对应的ACK确认后就会产生超时，重复发送同样的数据帧。这样就形成了死锁。</span><br></pre></td></tr></table></figure>
<p><strong>为什么主动断开方在 TIME-WAIT 状态必须等待 2MSL 的时间？</strong></p>
<blockquote>
<p>原因之一：主动断开方等待 2MSL 的时间，<strong>是为了确保两端都能最终关闭</strong>。假设网络是不可靠的，被动断开方发送 FIN+ACK 报文后，其主动方的 ACK 响应报文有可能丢失，这时候的被动断开方处于 LAST-ACK 状态的，由于收不到 ACK 确认被动方一直不能正常的进入 CLOSED 状态。在这种场景下，<strong>被动断开方会超时重传 FIN+ACK 断开响应报文</strong>，如果主动断开方在 2MSL 时间内，收到这个重传的 FIN+ACK 报文，<strong>会重传一次 ACK 报文，后再一次重新启动 2MSL 计时等待</strong>，这样，就能确保被动断开方能收到 ACK 报文，从而能确保被动方顺利进入到 CLOSED 状态。只有这样，双方都能够确保关闭。反过来说，如果主动断开方在发送完 ACK 响应报文后，不是进入 TIME_WAIT 状态去等待 2MSL 时间，而是立即释放连接，则将无法收到被动方重传的 FIN+ACK 报文，所以不会再发送一次 ACK 确认报文，此时处于 LAST-ACK 状态的被动断开方，无法正常进入到 CLOSED 状态。</p>
<p>原因之二：防止 “旧连接的已失效的数据报文” 出现在新连接中。主动断开方在发送完最后一个 ACK 报文后，再经过 2MSL，才能最终关闭和释放端口，这就意味着，相同端口的新 TCP 新连接，需要在 2MSL 的时间之后，才能够正常的建立。2MSL 这段时间内，旧连接所产生的所有数据报文，都已经从网络中消失了，从而，确保了下一个新的连接中不会出现这种旧连接请求报文。</p>
</blockquote>
<p><strong>如果已经建立了连接，但是 Client 端突然出现故障了怎么办？</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TCP还设有一个保活计时器，Client端如果出现故障，Server端不能一直等下去，这样会浪费系统资源。每收到一次Client客户端的数据帧后，Server端都的保活计时器会复位。计时器的超时时间通常是设置为2小时，若2小时还没有收到Client端的任何数据帧，Server端就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，Server端就认为Client端出了故障，接着就关闭连接。如果觉得保活计时器的两个多小时的间隔太长，可以自行调整TCP连接的保活参数。</span><br></pre></td></tr></table></figure>
<p><strong>源端连续接收到三个相同 ack 怎么办</strong></p>
<p>连续收到三个 ack 咋办当 TCP 源端收到 3 个相同的 ACK 确认时，即认为有数据包丢失，则源端重传丢失的数据包，而不必等待 RTO (Retransmission Timeout) 超时。</p>
<p><strong>七个包中某个包丢了该怎么办呐</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">0x00 TCP第一次握手SYN包丢包</span><br><span class="line">重传第一个包，重传次数由/proc/sys/net/ipv4/tcp_syn_retries决定，每次重传的时间翻倍上涨的，直至达到tcp_syn_retries决定，不在重传，开始摆烂</span><br><span class="line">1 2 4 8 16 32 酱紫翻倍的</span><br><span class="line"></span><br><span class="line">0x01 TCP第二次握手SYN包丢包</span><br><span class="line">客户端无法收到synack包，会重传syn。</span><br><span class="line">服务端收到客户的SYN包后，就会回SYN、ACK包，但是客户端一直没有回ACK，服务端在超时后，重传了 </span><br><span class="line">SYN、ACK 包，接着一会，客户端超时重传的SYN包又抵达了服务端，服务端收到后，超时定时器就重新</span><br><span class="line">计时，然后回SYN、ACK包，所以相当于服务端的超时定时器只触发了一次，又被重置了；</span><br><span class="line">当第二次握手的SYN、ACK丢包时，客户端会超时重发SYN包，服务端也会超时重传SYN、ACK包。同时客户端重传次数由tcp_syn_retries决定</span><br><span class="line"></span><br><span class="line">0x02</span><br><span class="line">TCP第三次握手SYN包丢包</span><br><span class="line">如果第三次握手的ACK，服务端无法收到，则服务端就会短暂处于SYN_RECV状态，并且依次等待3秒、6秒、12秒后重新发送SYN+ACK包，而客户端会处于 ESTABLISHED 状态。由于服务端一直收不到TCP第三次握手的ACK，则会一直重传SYN、ACK包，直到重传次数超过tcp_synack_retries,直至重传次数超过tcp_synack_retries</span><br><span class="line"></span><br><span class="line">0x03</span><br><span class="line">// 第一次握手重传次数限制</span><br><span class="line">cat /proc/sys/net/ipv4/tcp_syn_retries</span><br><span class="line"></span><br><span class="line">// 第二次握手重传次数限制</span><br><span class="line">cat /proc/sys/net/ipv4/tcp_synack_retries</span><br><span class="line"></span><br><span class="line">// 数据包最大重传次数限制</span><br><span class="line">cat /proc/sys/net/ipv4/tcp_retries2</span><br><span class="line"></span><br><span class="line">参考链接：https://juejin.cn/post/6844904181795389454</span><br><span class="line">师傅在文章里还有详细截图，看不懂我写的可以去看他写的~</span><br><span class="line"></span><br><span class="line">0x04 TCP第一次挥手FIN包丢包</span><br><span class="line">client发的FIN包丢了，对于client，因为没收对应的ACK包，应当一直重传(像普通包一样)，直至到达上限次数，直接关闭连接；对于server，它应该无任何感知；</span><br><span class="line"> </span><br><span class="line">0x05 TCP第二次挥手ACK包丢包</span><br><span class="line">server回client的ACK包丢了，对于client，将执行（1），对于server将像丢普通的ack一样，再次收到FIN后，再发一个ACK包；</span><br><span class="line"></span><br><span class="line">0x06 TCP第三次挥手FIN包丢包</span><br><span class="line">如果client收到ACK后，server直接跑路。client将永远停留在这个状态（半打开状态，就像client关闭了输出一样）。linux有tcp_fin_timeout这个参数，设置一个超时时间 cat /proc/sys/net/ipv4/tcp_fin_timeout 查看，默认60s。</span><br><span class="line">server发的FIN包丢了，对于server，像丢普通的包一样，重传。若此时client早已跑路且与其他人建立的连接，client应会不认识这个FIN包，直接回个RST包给server。如若client没跑路，且没收到server的FIN包，如（3）描述；</span><br><span class="line"></span><br><span class="line">0x07 TCP第三次挥手ACK包丢包</span><br><span class="line">防止回复的ACK包丢失（丢失后，server因为没收FIN的ACK，所以会再发一个FIN），将等待2MSL(最大报文存活时间)</span><br><span class="line"></span><br><span class="line">syn = 1丢了 计时器超时后重传第一个包(syn=1)</span><br><span class="line">syn = 1, ack = 1丢了 重传第一个(syn=1)和第二个包(syn=1,ack=1)</span><br><span class="line">ack = 1丢了 等待3秒、6秒、12秒后重新发送第二个(syn=1,ack=1)包</span><br><span class="line">客户端fin = 1丢了 重传第一个包(fin=1)</span><br><span class="line">服务端ack = 1丢了 重传第一个(fin=1)和第二个包(ack=1)</span><br><span class="line">服务端fin = 1丢了 服务端重传第三个包(fin=1),client行为分类讨论，如果已经和别人建立了连接，那么回RST，如果没跑路，那么client将永远停留在这个状态(fin-wait)</span><br><span class="line">客户端ack = 1丢了 服务端重传第三个包(fin=1),客户端等待Time-wait，即2MSL</span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="backlog"><a class="markdownIt-Anchor" href="#backlog">#</a> backlog</h2>
<blockquote>
<p>backlog 的值即为未连接队列和已连接队列的和</p>
<ul>
<li>
<p>未完成连接队列 (so_q0len)</p>
<p>一个 SYN 已经到达，但三次握手还没有完成的连接中的数量</p>
</li>
<li>
<p>已完成连接队列 (so_q1len)</p>
<p>三次握手已完成，内核正等待进程执行 accept 的调用中的数量</p>
</li>
</ul>
<p>简单理解，在 TCP 进行三次握手时，Liunx 会为其维护两个队列：</p>
<ul>
<li>半连接队列，也叫未完成连接队列，简称为 syn 队列</li>
<li>全连接队列，也叫已完成连接队列，简称为 accept 队列</li>
</ul>
<p>而 backlog 参数， 指定了内核为此套接口排队的最大连接个数。</p>
<p>在 C 语言中，通过下面的方式，在开始新连接监听的时候，设置 backlog</p>
<blockquote>
<p>int listen(int fd,int backlog);</p>
</blockquote>
<h3 id="tcp半连接队列和全连接队列"><a class="markdownIt-Anchor" href="#tcp半连接队列和全连接队列">#</a> TCP 半连接队列和全连接队列</h3>
<p>TCP 面向连接：客户端和服务端之间通过创建相应的数据结构，来维护双方的状态，并通过这样的数据结构来保持面向连接的特性。</p>
<p><img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20230408114044025.png" alt="image-20230408114044025"></p>
<p>服务端收到客户端发起的 SYN 请求后，<strong>内核会把该连接存储到半连接队列</strong>，并向客户端响应 SYN+ACK，</p>
<p>接着客户端会返回 ACK，</p>
<p>服务端收到第三次握手的 ACK 后，<strong>内核会把连接从半连接队列移除，然后创建新的完全的 socket 连接，并将其添加到 accept 队列，等待进程调用 accept 函数时把连接取出来。</strong></p>
<p>第一次握手时，服务端先创建一个轻量版本的 request_sock，</p>
<p>第三次握手时，才会创建 sock，这样可以减少资源的消耗。</p>
<p>三次握手后，将新 sock 插入 accept_queue 全连接队列，等待 accept。</p>
<p><img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20230408115139597.png" alt="image-20230408115139597"></p>
<h3 id="为什么要存在半连接队列"><a class="markdownIt-Anchor" href="#为什么要存在半连接队列">#</a> 为什么要存在半连接队列</h3>
<blockquote>
<p>因为根据 TCP 协议的特点，会存在半连接这样的网络攻击存在，叫做 syn 攻击</p>
<blockquote>
<p>即不停的发 SYN 包，而从不回应 SYN_ACK。</p>
</blockquote>
<p>如果发一个 SYN 包就让 Kernel 建立一个消耗极大的 sock，那么很容易就内存耗尽。</p>
<p>我们只需要一直对服务端发送 syn 包，但是不回 ack 回应包，</p>
<p>这样就会使得服务端有大量请求处于 syn_recv 状态，这就是所谓的 syn flood 洪泛，syn 攻击，DDos 攻击</p>
<p><strong>半连接队列，是解决 syn flood 洪泛的 一个关键措施。</strong></p>
<p>所以内核在三次握手成功之前，只分配一个占用内存极小的 request_sock，以防止这种攻击的现象，</p>
<p>再配合 syn_cookie 机制，尽量抵御这种半连接攻击的风险。</p>
</blockquote>
<p>1./proc/sys/net/ipv4/tcp_max_syn_backlog  # 1024</p>
<p>2./proc/sys/net/core/somaxconn # 1024</p>
<p>listen 的 backlog 参数最大不能超过 somaxconn。它用于限制 tcp 的全连接队列和半连接队列的长度。</p>
<p>全连接队列的最大值是 min (somaxconn, backlog)；</p>
<blockquote>
<p>tcp_max_syn_backlog 在系统配置中设置，用于检查 syn 半连接队列健康情况，</p>
<p>当服务端接收到一定数量的 syn 包，要检查新旧包是否有冲突，如有冲突就丢弃新包，这样就要避免洪水攻击。</p>
</blockquote>
<p>当 tcp_max_syn_backlog&gt; min (somaxconn, backlog) 时， 半连接队列最大值 max_qlen_log = min (somaxconn, backlog) * 2;<br>
 当 tcp_max_syn_backlog&lt;min (somaxconn, backlog) 时， 半连接队列最大值 max_qlen_log = tcp_max_syn_backlog * 2;</p>
<h3 id="全队列溢出"><a class="markdownIt-Anchor" href="#全队列溢出">#</a> 全队列溢出</h3>
<p>当服务端的全连接队列过小时，容易发生全连接队列溢出。</p>
<p>发生全连接队列溢出，后续的请求就会别丢弃。</p>
<p>Linux 有个参数，可以指定 TCP 全连接队列满了，会使用什么策略来回应客户端</p>
<ul>
<li>可以丢弃客户端的 ack 报文，当然， 只是 liunx 的默认行为，</li>
<li>可以向客户端发送 RST 报文，终止连接，告诉客户端连接失败</li>
</ul>
<p>tcp_abort_on_overflow 共有两个值分别是 0 和 1</p>
<ul>
<li>0：如果全连接队列满了，那么服务端丢弃 ack 报文</li>
<li>1：如果全连接队列满了，那么服务端会向客户端发送 RST 报文，终止这个握手连接</li>
</ul>
<p>如果设置 tcp_abort_on_overflow 为 0 的话，此时服务端全连接队列满了，客户端发送过来的 ack 报文，服务端丢弃。</p>
<p>而此时客户端还会继续重传，如果此时服务端的全连接队列有空闲，那么就会接受重传的 ack 包，这样就能直接建立连接了。</p>
<p>而设置 tcp_abort_on_overflow 为 1 的话，还需要重新连接</p>
</blockquote>
<h2 id="防御tcp-syn攻击"><a class="markdownIt-Anchor" href="#防御tcp-syn攻击">#</a> 防御 TCP syn 攻击</h2>
<p>1.tcp_syncookies</p>
<p><strong>syncookies 在接收到客户端的 syn 报文时，计算出一个 cookies 值，放到 syn+ack 报文中发出。</strong></p>
<p>cookies 值通过调用 secure_tcp_syn_cookie 函数，根据报文中的源 / 目的 IP 地址，TCP 源 / 目的端口号，TCP 序号和 MSS 索引值，计算出来</p>
<p>当客户端返回 ack 报文时，取出该值验证，成功则建立连接</p>
<p>开启 tcp_syncookies ， 服务端根本不创建 request_sock 对象，也不建立 sock 连接</p>
<p>如果启用了 syncookies，服务端将客户端 SYN 报文中的一些信息保存在了序号中，就不需要保留此连接的 request_sock 结构了，</p>
<p>在发送完 SYN+ACK 报文之后，将已经申请的资源释放，降低 DDos 攻击时的资源消耗</p>
<p>2. 增大半连接队列</p>
<p>由于全连接队列里面保存的是占用内存很大的普通 sock，所以 Kernel 给其加了一个最大长度的限制。</p>
<p>这个限制为下面三者中的最小值</p>
<p>1.listen 系统调用中传进去的 backlog</p>
<p>2./proc/sys/net/ipv4/tcp_max_syn_backlog</p>
<p>3./proc/sys/net/core/somaxconn</p>
<p>即 min (backlog, tcp_ma_syn_backlog, somaxcon)</p>
<p>所以不能只增大 tcp_max_syn_backlog, 还需要一同增大 somaconn 和 backlog，也就是增大全连接队列</p>
<p>3. 减少 ack+syn 报文重传次数</p>
<p>因为我们在收到 syn 攻击时，服务端会重传 syn+ack 报文到最大次数，才会断开连接。</p>
<p>针对 syn 攻击的场景，我们可以减少 ack+syn 报文的重传次数，使处于 syn_recv 状态的它们更快断开连接</p>
<p>/proc/sys/net/ipv4/tcp_synack_retries</p>
<p>4. 半连接队列</p>
<h2 id="udp报文结构"><a class="markdownIt-Anchor" href="#udp报文结构">#</a> UDP 报文结构</h2>
<p><img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20230410105639615.png" alt="image-20230410105639615"></p>
<p>源端口：这个字段占据 UDP 报文头的前 16 位，通常包含发送数据报的应用程序所使用的 UDP 端口。接收端的应用程序利用这个字段的值作为发送响应的目的地址。这个字段是可选的，所以发送端的应用程序不一定会把自己的端口号写入该字段中。如果不写入端口号，则把这个字段设置为 0。这样，接收端的应用程序就不能发送响应了。</p>
<p>目的端口：接收端计算机上 UDP 软件使用的端口，占据 16 位。</p>
<p>Length 占用 2 个字节，标识 UDP 头的长度，包括首部长度和数据长度。可以有 65535 字节那么长。但是一般网络在传送的时候，一次一般传送不了那么长的协议（涉及到 MTU 的问题），就只好对数据分片。</p>
<p>Checksum : 校验和，包含 UDP 头和数据部分。这是一个可选的选项，并不是所有的系统都对 UDP 数据包加以检验和数据 (相对 TCP 协议的必须来说)，但是 RFC 中标准要求，发送端应该计算检验和。UDP 的首部，数据部分，伪首部都会参与检验和的计算，各字段是按照 16 比特为单位进行计算的，因此数据部分是要保证是 16 比特的倍数，不够用 0 填充。</p>
<blockquote>
<p>将 UDP 伪头部、UDP 头部和数据部分全部用 16 进制数表示。<br>
将第一个 16 进制数与第二个 16 进制数相加，得到一个 32 位的数，如果 32 位数的高 16 位大于 0，需要将高 16 位与低 16 位再相加，得到一个 32 位的数，直到高 16 位为 0，得到这一次相加的结果。<br>
将上一步得到的 16 位数与第三个数 16 进制的数相加，重复第二步，直到累加完所有的 16 进制数，并且得到的结果为 16 进制数。<br>
将累加最后得到的 16 进制数取反，得到校验和。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> <span class="title function_">check_sum</span><span class="params">(<span class="type">unsigned</span> <span class="type">short</span> *data, <span class="type">int</span> num)</span>&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> sum = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; num; i++)&#123;</span><br><span class="line">		sum += *data++;	<span class="comment">//将2个16进制数相加</span></span><br><span class="line">		sum = (sum&gt;&gt;<span class="number">16</span>) + (sum&amp;<span class="number">0xffff</span>); <span class="comment">//取相加结果的低16位与高16位相加</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ~sum;	<span class="comment">//对最后的结果取反</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="伪首部"><a class="markdownIt-Anchor" href="#伪首部">#</a> 伪首部</h3>
<p>1. 长度为 12B</p>
<p>2. 伪首部不是 UDP 的真正首部，只在计算校验和时用到</p>
<p>3. 伪首部既不向下传送也不向上递交，只是为了计算校验和</p>
<p><img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/v2-86bb22904619c1bd318996b26b7825c2_720w.webp" alt="img"></p>
<p>发送方或接收方根据 IP 报文首部获得 8 字节的源地址 + 目的地址、2 字节的 0 字段 + UDP 协议字段、2 字节的数据长度，得到 12 字节伪首部，临时添加在首部前面。</p>
<p>发送方将计算完毕的校验和填入首部的校验和字段后，去除伪首部发送 UDP 报文。</p>
<h2 id="udp-适用场景"><a class="markdownIt-Anchor" href="#udp-适用场景">#</a> UDP 适用场景</h2>
<blockquote>
<p>UDP 协议一般作为流媒体应用、语音交流、视频会议所使用的传输层协议，还有许多基于互联网的电话服务使用的 VOIP（基于 IP 的语音）也是基于 UDP 运行的，实时视频和音频流协议旨在处理偶尔丢失的数据包，因此，如果重新传输丢失的数据包，则只会发生质量略有下降，而不是出现较大的延迟。</p>
<p>我们大家都知道的 DNS 协议底层也使用了 UDP 协议，这些应用或协议之所以选择 UDP 主要是因为以下这几点</p>
<p>速度快，采用 UDP 协议时，只要应用进程将数据传给 UDP，UDP 就会将此数据打包进 UDP 报文段并立刻传递给网络层，然而 TCP 有拥塞控制的功能，它会在发送前判断互联网的拥堵情况，如果互联网极度阻塞，那么就会抑制 TCP 的发送方。使用 UDP 的目的就是希望实时性。</p>
<p>无须建立连接，TCP 在数据传输之前需要经过三次握手的操作，而 UDP 则无须任何准备即可进行数据传输。因此 UDP 没有建立连接的时延。</p>
<p>无连接状态，TCP 需要在端系统中维护连接状态，连接状态包括接收和发送缓存、拥塞控制参数以及序号和确认号的参数，在 UDP 中没有这些参数，也没有发送缓存和接受缓存。因此，某些专门用于某种特定应用的服务器当应用程序运行在 UDP 上，一般能支持更多的活跃用户</p>
<p>分组首部开销小，每个 TCP 报文段都有 20 字节的首部开销，而 UDP 仅仅只有 8 字节的开销。</p>
</blockquote>
<h2 id="udp-flood"><a class="markdownIt-Anchor" href="#udp-flood">#</a> UDP flood</h2>
<p>UDP 洪水是一种拒绝服务攻击，攻击者将大量用户数据报协议 (UDP) 数据包发送到目标服务器，旨在让该设备的处理和响应能力无力承担。由于 UDP 洪水攻击，保护目标服务器的防火墙也可能不堪重负，导致对正常流量拒绝服务。</p>
<p>UDP 洪水的工作原理主要是利用服务器响应发送到其端口之一的 UDP 数据包时所采取的步骤。在正常情况下，服务器在特定端口上收到 UDP 数据包时，将通过以下两个步骤进行响应：</p>
<p>服务器首先检查是否有任何当前侦听指定端口请求的程序正在运行。</p>
<p>如果该端口上没有程序正在接收数据包，则服务器将以 ICMP (ping) 数据包作为响应，以告知发送方目标不可达。</p>
<p>由于目标服务器利用资源来检查并响应每个接收到的 UDP 数据包，当收到大量 UDP 数据包时，目标资源会很快耗尽，从而导致对正常流量拒绝服务。</p>
<h2 id="udp和tcp区别"><a class="markdownIt-Anchor" href="#udp和tcp区别">#</a> UDP 和 TCP 区别</h2>
<blockquote>
<ol>
<li>TCP<strong> 面向连接</strong>；UDP 是无连接的，即发送数据之前不需要建立连接。</li>
<li>TCP 提供<strong>可靠的服务</strong>；UDP 不保证可靠交付。</li>
<li>TCP<strong> 面向字节流</strong>，把数据看成一连串无结构的字节流；UDP 是面向报文的。</li>
<li>TCP 有<strong>拥塞控制</strong>；UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如实时视频会议等）。</li>
<li>每一条 TCP 连接只能是<strong>点到点</strong>的；UDP 支持一对一、一对多、多对一和多对多的通信方式。</li>
<li>TCP 首部开销 20 字节；UDP 的首部开销小，只有 8 个字节。</li>
</ol>
</blockquote>
<h2 id="ip-报文结构"><a class="markdownIt-Anchor" href="#ip-报文结构">#</a> IP 报文结构</h2>
<p><img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20230410111611678.png" alt="image-20230410111611678"></p>
<blockquote>
<p>版本（version）：4 bits，表示 IP 的版本，分为 IPV4 和 IPV6</p>
<p>报头长度（header length）：4 bits，标识 IP 报头的长度（不包括数据部分），单位是 32bits (也就是 4 字节）。由于 4 位二进制的最大值为 15，所以 IP 报头最大就是 15 x 4 = 60 字节。IP 报文的最小长度就是 20 字节。</p>
<p>差分服务字段（different services field): 8bits, 标识数据包的优先级，主要用于 QOS 服务中。</p>
<p>总长度（total length) :16 bits 标识 IP 报文的总长度（包括数据部分），单位是 1 byte。报头的长度和数据部分的长度之和。</p>
<p>所以一个 IP 报文的最大长度是 65535 字节。</p>
<p>标识符（identifier）：16 bits，数据包的一个 ID 编号，用于标识数据包，特别是用于数据包分片技术中。通常每发送一个报文，它的值加一。当 IP 报文长度超过传输网络的 MTU（最大传输单元）时必须分片，这个标识字段的值被复制到所有数据分片的标识字段中，使得这些分片在达到最终目的地时可以依照标识字段的内容重新组成原先的数据。</p>
<p>标志位 1（reserve bit)：1 bit, 保留位</p>
<p>标志位 2（dont fragment): 1 bit，不可分片位（DF)，如果置 1，则代表此数据位不可分片</p>
<p>标志位 3（more fragment): 1 bit ，更多分片位（MF)</p>
<p>如果数据包被分片，则除了最后一个分片报文的 MF 位是 0 外，其他分片报文的 MF 位是 1。</p>
<p>分段偏移（fragment offset）：13 bit，单位是 byte，标识分片报文相对于原始报文起始位置的偏移量</p>
<p>生存时间（time to live): 8 bit , 初始数据包会设置一个特定的 TTL 值，在传输过程中，每经过一次路由，TTL 就会减 1，所以 TTL 代表了数据包被路由的次数，网络中一般称为跳数。</p>
<p>TTL 一旦减到 0，则网络设备会丢弃此数据包。</p>
<p>协议号（protocol）：8bit，标识了网络层之上使用了何种网络协议。其中 TCP = 6,UDP = 17</p>
<p>报头检验和（header checksum）：16 bit, 针对 IP 报头的纠错字段，只校验 IP 报头</p>
<p>源 IP 地址（source address）：32bit，数据包发送方 IP 地址</p>
<p>目的 IP 地址（destination address) : 32bit，数据包接收方 IP 地址。</p>
<p>可选项 &amp; 填充项：（option &amp; padding）：0-40 字节，一些可选项，主要用于测试，不足 32bit 则用 0 补充。</p>
</blockquote>
<h2 id="分片"><a class="markdownIt-Anchor" href="#分片">#</a> 分片</h2>
<h3 id="mss"><a class="markdownIt-Anchor" href="#mss">#</a> MSS</h3>
<ul>
<li>在建立 TCP 连接的同时，也可以确定发送数据包的单位，我们也可以称其为 “最大消息长度”（MSS）。最理想的情况是，最大消息长度正好是 IP 中不会被分片处理的最大数据长度。</li>
<li>TCP 在传送大量数据时，是以 MSS 的大小将数据进行分割发送。进行重发时也是以 MSS 为单位。</li>
<li>MSS 在三次握手的时候，在两端主机之间被计算得出。两端的主机在发出建立连接的请求时，会在 TCP 首部中写入 MSS 选项，告诉对方自己的接口能够适应的 MSS 的大小。然后会在两者之间选择一个较小的值投入使用。</li>
</ul>
<p><strong>Frame</strong> = Ethernet Header + IP Header + TCP Header + TCP Segment Data</p>
<p>（1）Ethernet Header = <strong>14</strong> Byte = Dst Physical Address（6 Byte）+ Src Physical Address（6 Byte）+ Type（2 Byte），以太网帧头以下称之为<strong>数据帧</strong>。</p>
<p>（2）IP Header = <strong>20</strong> Byte（without options field），数据在 IP 层称为<strong> Datagram</strong>，分片称为<strong> Fragment</strong>。</p>
<p>（3）TCP Header = <strong>20</strong> Byte（without options field），数据在 TCP 层称为<strong> Stream</strong>，分段称为<strong> Segment</strong>（UDP 中称为<strong> Message</strong>）。</p>
<p>（4）54 个字节后为 TCP 数据负载部分（Data Portion），即应用层用户数据。</p>
<p>Ethernet Header 以下的 IP 数据报最大传输单位为<strong> MTU</strong>（Maximum Transmission Unit，Effect of short board），对于大多数使用以太网的局域网来说，MTU=1500。</p>
<p>TCP 数据包每次能够传输的最大数据分段为<strong> MSS</strong>，为了达到最佳的传输效能，在建立 TCP 连接时双方协商 MSS 值，双方提供的 MSS 值的最小值为这次连接的最大 MSS 值。MSS 往往基于 MTU 计算出来，通常 MSS=MTU-sizeof (IP Header)-sizeof (TCP Header)=1500-20-20=1460。</p>
<p>这样，数据经过本地 TCP 层分段后，交给本地 IP 层，在本地 IP 层就不需要分片了。但是在下一跳路由（Next Hop）的邻居路由器上可能发生 IP 分片！因为路由器的网卡的 MTU 可能小于需要转发的 IP 数据报的大小。这时候，在路由器上可能发生两种情况：</p>
<p>（1）. 如果源发送端设置了这个 IP 数据包可以分片（May Fragment，DF=0），路由器将 IP 数据报分片后转发。</p>
<p>（2）. 如果源发送端设置了这个 IP 数据报不可以分片（Don’t Fragment，DF=1），路由器将 IP 数据报丢弃，并发送 ICMP 分片错误消息给源发送端。</p>
<h2 id="粘包和半包"><a class="markdownIt-Anchor" href="#粘包和半包">#</a> 粘包和半包</h2>
<p>在网络通信中，当发送方连续发送多个小数据包时，接收方可能会将它们合并成一个大的数据包，这就是粘包问题；而当发送方发送的数据包长度大于接收方的缓冲区长度时，接收方无法完整接收数据包，导致数据的接收不完整，这就是半包问题。</p>
<p><code>粘包</code> 就是多个数据混淆在一起了，而且多个数据包之间没有明确的分隔，导致无法对这些数据包进行正确的读取。<br>
 <code>半包</code> 就是一个大的数据包被拆分成了多个数据包发送，读取的时候没有把多个包合成一个原本的大包，导致读取的数据不完整。<br>
这种问题产生的原因可能有多种因素，从应用层到链路层中都有可能引起这个问题。</p>
<h3 id="滑动窗口"><a class="markdownIt-Anchor" href="#滑动窗口">#</a> 滑动窗口</h3>
<blockquote>
<p>TCP 协议是一种可靠性传输协议，所以在传输数据的时候必须要等到对方的应答之后才能发送下一条数据，这种显然效率不高。</p>
<p>TCP 协议为了解决这个传输效率的问题，引入了滑动窗口。滑动窗口就是在发送方和接收方都有一个缓冲区，这个缓冲区就是 &quot;窗口&quot;，假设发送方的窗口大小是  <code>0~100KB</code> , 那么发送数据的时候前 100KB 的数据不需要等到对方 ACK 应答即可全部发送。</p>
<p>如果发送的过程中收到了对方返回某个数据包的 ACK，那么这个窗口会对应的向后滑动。比如刚开始的窗口大小是 <code>0~100KB</code> ，收到前 20KB 数据包的 ACK 之后，这个窗口就会滑动到 <code>20~120KB</code>  的位置，以此类推。这里还有一个小问题，如果发送方一直未接收到前 20KB 的 ACK 消息，那么在发送完 <code>0~100KB</code>  的数据之后，窗口就会卡在那里，这就是经典的 <code>队头阻塞问题</code></p>
<h3 id="窗口变化"><a class="markdownIt-Anchor" href="#窗口变化">#</a> 窗口变化</h3>
<p>发送窗口的位置由窗口前沿和后沿的位置共同确定。发送窗口后沿的变化情况有两种，即不动 (没有收到新的确认) 和前移 (收到了新的确认)。发送窗口后沿不可能向后移动，因为不能撤销已收到的确认</p>
<p>发送窗口前沿通常是不断向前移动，但也有可能不动。这对应于两种情况：</p>
<ul>
<li>一是没有收到新的确认，对应通知的窗口大小也不变</li>
<li>二是收到了新的窗口但对方通知的窗口缩小了，使得发送窗口前沿正好不动</li>
</ul>
<p>发送窗口前沿也有可能 <code>向后收缩</code> 。这发生在对方通知的窗口缩小了。但 TCP 的标准 <code>强烈不赞成这样做</code> 。因为很可能发送方在收到这个通知以前已经发生了窗口中的许多数据，现在又要收缩窗口，不让发送这些数据，这样就会产生一些错误</p>
<p>要描述一个发送窗口的状态需要三个指针：P1，P2，P3。指针都指向字节的序号。这三个指针指向的几个部分的意义如下：</p>
<ul>
<li>
<p>小于 P1 的是已发送并已收到确认的部分，而大于 P3 的是不允许发送的部分</p>
</li>
<li>
<p>P3 - P1 = A 的发送窗口</p>
</li>
<li>
<p>P2 - P1 已发送但尚未收到确认的字节数</p>
</li>
<li>
<p>P3 - P2 允许发送但当前尚未发送的字节数 (又称为 <code>可用窗口</code> 或 <code>有效窗口</code> )</p>
<p><img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20230410115940261.png" alt="image-20230410115940261"></p>
</li>
</ul>
</blockquote>
<h3 id="nagle算法"><a class="markdownIt-Anchor" href="#nagle算法">#</a> Nagle 算法</h3>
<p>有这么一种情况，每次发送的数据包都非常小，比如只有 1 个字节，但是 TCP 的报文头默认有 40 个字节，数据 + 报文头一共是 41 字节。如果这种较小的数据包经常出现，会造成过多的网络资源浪费。比如有 1W 个这样的数据包，那么总数据量中有 400MB 都是报文头，只有 10MB 是真正的数据。</p>
<p>所以 TCP 中引入了一种叫做 <code>Nagle</code>  的算法，如若连续几次发送的数据都很小， <code>TCP</code>  会根据这个算法把多个数据合并成一个包发出，从而优化传输效率，避免网络资源浪费。</p>
<h3 id="应用层的接收缓冲区和发送缓冲区"><a class="markdownIt-Anchor" href="#应用层的接收缓冲区和发送缓冲区">#</a> 应用层的接收缓冲区和发送缓冲区</h3>
<p>对于操作系统的 IO 函数而言，网络数据不管是发送或者接收，都不会去逐个读取，而是会先把接收 / 发送的数据放入到一个缓冲区中，然后批量进行操作。当然，发送和接收各自会对应有一个缓冲区。</p>
<p>假设现在要发送 <code>1234567</code>  这组数据，操作系统的 IO 函数会挨个将他们写入到发送缓冲区。接收方也是这样，会将他们挨个从接收缓冲区中读取出来。</p>
<h3 id="产生原因"><a class="markdownIt-Anchor" href="#产生原因">#</a> 产生原因</h3>
<blockquote>
<p>搞清楚上面几个概念之后，我们再来分析一下为什么会产生粘包或者半包的问题<br>
粘包：发送 <code>ABCD、EFGHIJK</code>  两个数据包，被接收成 <code>ABCDEFGHIJK</code>  一个数据包，多个包粘在一起。</p>
<ul>
<li>应用层：接收方的接收缓冲区太大，导致读取多个数据包一起输出。</li>
<li>TCP 滑动窗口：接收方窗口较大，导致发送方发出的多个数据包处理不及时造成粘包</li>
<li>Nagle 算法：由于发送方的单个数据包体积太小，导致多个包合并成一个包发送</li>
</ul>
<p>半包：发送 <code>ABCDEFG</code>  一个数据包，被接收成 <code>ABC、DEFG</code>  两个数据包，一个包被拆成了多个。</p>
<ul>
<li>应用层：接收方缓冲区太小，无法存放发送发的单个数据包，因此拆开读取。</li>
<li>滑动窗口：接收方的窗口太小，无法一次性放下完整的数据包，只能读取其中的一部分。</li>
<li>MSS 限制：发送方的单个包大小超出了 MSS 限制，被拆分成了多个包</li>
</ul>
</blockquote>
<h3 id="解决方案"><a class="markdownIt-Anchor" href="#解决方案">#</a> 解决方案</h3>
<blockquote>
<p>1. 短链接</p>
<p>所谓短连接就是一次性把数据发完，然后就断开连接。客户端断开连接之后，服务端会接收到一个 - 1 的状态码，可以以这个 - 1 作为每个数据包的边界。</p>
<ol start="2">
<li>定长帧解码器</li>
</ol>
<p>定长帧其实就是固定每次数据包的大小，比如固定每个包的大小为 8 个字节，那么发送方每次最多发送 8 个字节的数据，不够的自动补齐，然后接收方在接收的时候，每次也只接收 8 个字节大小的数据，这样就可以有效避免粘包半包问题。</p>
</blockquote>
<h2 id="拥塞控制"><a class="markdownIt-Anchor" href="#拥塞控制">#</a> 拥塞控制</h2>
<p>防止过多的数据注入到网络中。 几种拥塞控制方法：慢开始 (slow-start)、拥塞避免 ( congestion avoidance )、快重传 ( fast retransmit ) 和快恢复 ( fast recovery )。</p>
<p><img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20230410133240400.png" alt="image-20230410133240400"></p>
<blockquote>
<p><strong>慢开始</strong></p>
<p>把拥塞窗口 cwnd 设置为一个最大报文段 MSS 的数值。而在每收到一个对新的报文段的确认后，把拥塞窗口增加至多一个 MSS 的数值。每经过一个传输轮次，拥塞窗口 cwnd 就加倍。 为了防止拥塞窗口 cwnd 增长过大引起网络拥塞，还需要设置一个慢开始门限 ssthresh 状态变量。</p>
<p>当 cwnd &lt; ssthresh 时，使用慢开始算法。</p>
<p>当 cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。</p>
<p>当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞控制避免算法。</p>
<p><strong>拥塞避免</strong></p>
<p>让拥塞窗口 cwnd 缓慢地增大，每经过一个往返时间 RTT 就把发送方的拥塞窗口 cwnd 加 1，而不是加倍。这样拥塞窗口 cwnd 按线性规律缓慢增长。</p>
<p>无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限 ssthresh 设置为出现拥塞时的发送 方窗口值的一半（但不能小于 2）。然后把拥塞窗口 cwnd 重新设置为 1，执行慢开始算法。这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生 拥塞的路由器有足够时间把队列中积压的分组处理完毕。</p>
<p><strong>快重传</strong></p>
<p>有时个别报文段会在网络中丢失，但实际上网络并未发生拥塞。如果发送方迟迟收不到确认，就会产生超时，就会误认为网络发生了拥塞。这就导致发送方错误地启动慢开始，把拥塞窗口 cwnd 又设置为 1，因而降低了传输效率。</p>
<p>快重传算法可以避免这个问题。快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认，使发送方及早知道有报文段没有到达对方。</p>
<p><strong>发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段</strong>，而不必继续等待重传计时器到期。由于发送方尽早重传未被确认的报文段，因此采用快重传后可以使整个网络吞吐量提高约 20%。</p>
<p><strong>快恢复</strong></p>
<p>当发送方连续收到三个重复确认，就会把慢开始门限 ssthresh 减半，接着把 cwnd 值设置为慢开始门限 ssthresh 减半后的数值，然后开始执行拥塞避免算法，使拥塞窗口缓慢地线性增大。</p>
<p>在采用快恢复算法时，慢开始算法只是在 TCP 连接建立时和网络出现超时时才使用。 采用这样的拥塞控制方法使得 TCP 的性能有明显的改进。</p>
</blockquote>
<h2 id="超时重传"><a class="markdownIt-Anchor" href="#超时重传">#</a> 超时重传</h2>
<blockquote>
<p>TCP 为了实现可靠传输，实现了重传机制。最基本的重传机制，就是<strong>超时重传</strong>，即在发送数据报文时，设定一个定时器，每间隔一段时间，没有收到对方的 ACK 确认应答报文，就会重发该报文。</p>
<p>我们先来看下什么叫<strong> RTT（Round-Trip Time，往返时间）</strong>。</p>
<p>RTT 就是，一个数据包从发出去到回来的时间，即<strong>数据包的一次往返时间</strong>。超时重传时间，就是 Retransmission Timeout ，简称<strong> RTO</strong>。</p>
<ul>
<li>如果 RTO 比较小，那很可能数据都没有丢失，就重发了，这会导致网络阻塞，会导致更多的超时出现。</li>
<li>如果 RTO 比较大，时间太长还是没有重发，那效果就不好了。</li>
</ul>
<p>一般情况下，RTO 略大于 RTT，效果是最好的。</p>
<p>RTO 计算公式:<strong>Jacobson / Karels 算法</strong></p>
<blockquote>
<p><strong>1. 先计算 SRTT（计算平滑的 RTT）</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SRTT = (1 - α) * SRTT + α * RTT  //求 SRTT 的加权平均</span><br></pre></td></tr></table></figure>
<p><strong>2. 再计算 RTTVAR (round-trip time variation)</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RTTVAR = (1 - β) * RTTVAR + β * (|RTT - SRTT|) //计算 SRTT 与真实值的差距</span><br></pre></td></tr></table></figure>
<p><strong>3. 最终的 RTO</strong></p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RTO = µ * SRTT + ∂ * RTTVAR  =  SRTT + 4·RTTVAR  </span><br></pre></td></tr></table></figure>
<p>其中， <code>α = 0.125，β = 0.25， μ = 1，∂ = 4</code> ，这些参数都是大量结果得出的最优参数。</p>
</blockquote>
<p>超时重传缺点</p>
<blockquote>
<ul>
<li>当一个报文段丢失时，会等待一定的超时周期然后才重传分组，增加了端到端的时延。</li>
<li>当一个报文段丢失时，在其等待超时的过程中，可能会出现这种情况：其后的报文段已经被接收端接收但却迟迟得不到确认，发送端会认为也丢失了，从而引起不必要的重传，既浪费资源也浪费时间。</li>
<li>TCP 有个策略，就是超时时间间隔会加倍。超时重传需要<strong>等待很长时间</strong>。因此，还可以使用<strong>快速重传</strong>机制。</li>
</ul>
</blockquote>
<p>快重传</p>
<blockquote>
<p><img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/v2-f24801fb963518c9ca1eec2b421a305e_720w.webp" alt="img"></p>
<ul>
<li>第一份 Seq=1 先送到了，于是就 Ack 回 2；</li>
<li>第二份 Seq=2 也送到了，假设也正常，于是 ACK 回 3；</li>
<li>第三份 Seq=3 由于网络等其他原因，没送到；</li>
<li>第四份 Seq=4 也送到了，但是因为 Seq3 没收到。所以 ACK 回 3；</li>
<li>后面的 Seq=4,5 的也送到了，但是 ACK 还是回复 3，因为 Seq=3 没收到。</li>
<li>发送端连着收到三个重复冗余 ACK=3 的确认（实际上是 4 个，但是前面一个是正常的 ACK，后面三个才是重复冗余的），便知道哪个报文段在传输过程中丢失了，于是在定时器过期之前，重传该报文段。</li>
<li>最后，接收到收到了 Seq3，此时因为 Seq=4，5，6 都收到了，于是 ACK 回 7</li>
</ul>
</blockquote>
<p>但<strong>快速重传</strong>还可能会有个问题：ACK 只向发送端告知最大的有序报文段，到底是哪个报文丢失了呢？<strong>并不确定</strong></p>
<p>是重传 Seq3 呢？还是重传 Seq3、Seq4、Seq5、Seq6 呢？因为发送端并不清楚这三个连续的 ACK3 是谁传回来的</p>
<p><strong>带选择确认的重传（SACK）</strong></p>
<p><strong>SACK 机制</strong>就是，在快速重传的基础上，接收端返回最近收到的报文段的序列号范围，这样发送端就知道接收端哪些数据包没收到，酱紫就很清楚该重传哪些数据包啦。SACK 标记是加在 TCP 头部<strong>选项</strong>字段里面的。</p>
<p><img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/v2-9ceac05b4042f2b55deee28981ed803b_720w.webp" alt="img"></p>
<p>发送端收到了三次同样的 ACK=30 的确认报文，于是就会触发快速重发机制，通过 SACK 信息发现只有 <code>30~39</code>  这段数据丢失，于是重发时就只选择了这个 <code>30~39</code>  的 TCP 报文段进行重发。</p>
</blockquote>
<h2 id="ack"><a class="markdownIt-Anchor" href="#ack">#</a> ACK</h2>
<h3 id="dup-ack"><a class="markdownIt-Anchor" href="#dup-ack">#</a> dup ack</h3>
<p><img data-src="https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20230717135315667.png" alt="image-20230717135315667"></p>
<p>[TCP dup ack XXX#X] 表示第几次重新请求某一个包，</p>
<p>XXX 表示第几个包（不是 Seq），X 表示第几次请求。</p>
<p><strong>丢包</strong>或者<strong>乱序</strong>的情况下，会出现该标志。</p>
<p>server 收到了 3 和 8 号包，但是没有收到中间的 4/5/6/7，那么 server 就会 ack 3，如果 client 还是继续发 8/9 号包，那么 server 会继续发 dup ack 3#1 ; dup ack 3#2 来向客户端说明只收到了 3 号包，不要着急发后面的大包，把 4/5/6/7 给我发过来</p>
<h3 id="keep-alive-ack"><a class="markdownIt-Anchor" href="#keep-alive-ack">#</a> keep-alive ack</h3>
<p>在 TCP 中有一个 Keep-alive 的机制可以检测死连接，原理很简单，TCP 会在空闲了一定时间后发送数据给对方：</p>
<p>1. 如果主机可达，对方就会响应 ACK 应答，就认为是存活的。</p>
<p>2. 如果可达，但应用程序退出，对方就发 RST 应答，发送 TCP 撤消连接。</p>
<p>3. 如果可达，但应用程序崩溃，对方就发 FIN 消息。</p>
<p>4. 如果对方主机不响应 ack, rst，继续发送直到超时，就撤消连接。这个时间就是默认的二个小时。</p>
<h3 id="tcp-retransmission"><a class="markdownIt-Anchor" href="#tcp-retransmission">#</a> tcp retransmission</h3>
<p>超时重传，如果一个包的丢了，又<strong>没有后续包</strong>可以在接收方触发 [Dup Ack]，或者 **[Dup Ack] 也丢失 ** 的情况下，TCP 会触发超时重传机制。</p>
<h3 id="tcp-spurious-retransmission"><a class="markdownIt-Anchor" href="#tcp-spurious-retransmission">#</a> tcp spurious retransmission</h3>
<h3 id="tcp-fast-retransmission"><a class="markdownIt-Anchor" href="#tcp-fast-retransmission">#</a> tcp fast retransmission</h3>
<p>一般快速重传算法在收到<strong>三次冗余的 Ack</strong>，即三次 [TCP dup ack XXX#X] 后，<strong>发送端</strong>进行快速重传。<br>
为什么是三次呢？因为<strong>两次 duplicated ACK</strong> 肯定是<strong>乱序</strong>造成的，<strong>丢包</strong>肯定会造成<strong>三次 duplicated ACK</strong>。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vY3JhenltYWtlcmNpcmNsZS9wLzE2NTEyMDE1Lmh0bWwjYXV0b2lkLWgyLTAtMC0w">TCP 半连接队列和全连接队列（史上最全） - 疯狂创客圈 - 博客园 (cnblogs.com)</span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vY3JhenltYWtlcmNpcmNsZS9wLzE0NDk5MjExLmh0bWw=">TCP/IP 协议 （图解 + 秒懂 + 史上最全） - 疯狂创客圈 - 博客园 (cnblogs.com)</span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vamluZ3poaXNoZW4vcC81Mzk5MDQ4Lmh0bWw=">MSS 与 MTU 的关系 - 静之深 - 博客园 (cnblogs.com)</span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zNTcwODA4NTU=">UDP 协议详解 - 知乎 (zhihu.com)</span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC82MjAwNTY5MjA=">TCP 协议中的粘包和半包问题 - 知乎 (zhihu.com)</span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xNDczNzA2NTM=">太厉害了，终于有人能把 TCP/IP 协议讲的明明白白了 - 知乎 (zhihu.com)</span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zNjI4MjY0NzA=">TCP/IP/ICMP 报文格式 - 知乎 (zhihu.com)</span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC82MTkzMDIwOTE=">这可能是最全面的 TCP 面试八股文了 - 知乎 (zhihu.com)</span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC82NDE1NTcwNQ==">TCP 协议详解 - 知乎 (zhihu.com)</span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zODg3MDQwMjM=">面试必备！TCP 协议经典十五连问！ - 知乎 (zhihu.com)</span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0V0aGVyaWNfc291bC9hcnRpY2xlL2RldGFpbHMvMTI2Nzg2NTMx">(63 条消息) IP 报文的结构 - CSDN 博客</span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDA4MTM4NC9hcnRpY2xlL2RldGFpbHMvMTI2NjExMzQ3">(63 条消息) TCP/IP 协议专栏 —— 分片报文详解 —— 网络入门和工程维护必看_牛牛来了的博客 - CSDN 博客</span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9jbG91ZC50ZW5jZW50LmNvbS9kZXZlbG9wZXIvYXJ0aWNsZS8xNzIxODAw">linux ss 命令详解 - 腾讯云开发者社区 - 腾讯云 (tencent.com)</span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3luY2h5b25nL2FydGljbGUvZGV0YWlscy8xMDkxMTAwMjg=">(95 条消息) TCP 报文（ tcp dup ack 、TCP Retransmission）_ynchyong 的博客 - CSDN 博客</span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzE1NDM3NjI5L2FydGljbGUvZGV0YWlscy8xMTY1NjU2NzM=">(95 条消息) TCP DUP ACK 抓包分析_造夢先森的博客 - CSDN 博客</span></p>
<p><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC82MjY5NjA1ODk=">（TCP keepalive）心跳包机制设计详解 - 知乎 (zhihu.com)</span></p>

  </div>

   <footer>

    <div class="meta">
  <span class="item">
    <span class="icon">
      <i class="ic i-calendar-check"></i>
    </span>
    <span class="text">Edited on</span>
    <time title="Modified: 2023-07-17 14:17:58" itemprop="dateModified" datetime="2023-07-17T14:17:58+08:00">2023-07-17</time>
  </span>
</div>

      
<div class="reward">
  <button><i class="ic i-heartbeat"></i> Donate</button>
  <p>Give me a cup of [coffee]~(￣▽￣)~*</p>
  <div id="qr">
      
      <div>
        <img data-src="/images/wechatpay.png" alt="John Doe WeChat Pay">
        <p>WeChat Pay</p>
      </div>
      
      <div>
        <img data-src="/images/alipay.png" alt="John Doe Alipay">
        <p>Alipay</p>
      </div>
      
      <div>
        <img data-src="/images/paypal.png" alt="John Doe PayPal">
        <p>PayPal</p>
      </div>
  </div>
</div>

      

<div id="copyright">
<ul>
  <li class="author">
    <strong>Post author:  </strong>John Doe <i class="ic i-at"><em>@</em></i>Hexo
  </li>
  <li class="link">
    <strong>Post link: </strong>
    <a href="http://example.com/2023/04/07/TCPIP_new/" title="TCP&#x2F;IP">http://example.com/2023/04/07/TCPIP_new/</a>
  </li>
  <li class="license">
    <strong>Copyright Notice:  </strong>All articles in this blog are licensed under <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> unless stating additionally.
  </li>
</ul>
</div>

  </footer>

</article>

  </div>
  

<div class="post-nav">
    <div class="item left">
      

  <a href="/2023/04/05/Docker/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;img.timelessq.com&#x2F;images&#x2F;2022&#x2F;07&#x2F;26&#x2F;1adb61c48863ce35a391d69c0a64f274.jpg" title="docker">
  <span class="type">Previous Post</span>
  <span class="category"><i class="ic i-flag"></i> </span>
  <h3>docker</h3>
  </a>

    </div>
    <div class="item right">
      

  <a href="/2023/04/15/Nginx_new/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;img.timelessq.com&#x2F;images&#x2F;2022&#x2F;07&#x2F;26&#x2F;50d682207f8e6513884d523e2e0895f7.jpg" title="Nginx">
  <span class="type">Next Post</span>
  <span class="category"><i class="ic i-flag"></i> </span>
  <h3>Nginx</h3>
  </a>

    </div>
</div>

  
  <div class="wrap" id="comments"></div>


        </div>
        <div id="sidebar">
          

<div class="inner">

  <div class="panels">
    <div class="inner">
      <div class="contents panel pjax" data-title="Contents">
          <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#tcpip"><span class="toc-number">1.</span> <span class="toc-text"> TCP&#x2F;IP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#tcp-%E5%8D%8F%E8%AE%AE%E6%8A%A5%E6%96%87%E6%A0%BC%E5%BC%8F"><span class="toc-number">1.1.</span> <span class="toc-text"> TCP 协议报文格式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tcp-%E5%8F%AF%E9%9D%A0%E6%80%A7"><span class="toc-number">1.2.</span> <span class="toc-text"> TCP 可靠性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tcp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">1.3.</span> <span class="toc-text"> TCP 三次握手</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tcp%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">1.4.</span> <span class="toc-text"> TCP 四次挥手</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%84%91%E6%BA%A2%E8%A1%80%E7%8E%AF%E8%8A%82"><span class="toc-number">1.5.</span> <span class="toc-text"> 脑溢血环节</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#backlog"><span class="toc-number">1.6.</span> <span class="toc-text"> backlog</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#tcp%E5%8D%8A%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97%E5%92%8C%E5%85%A8%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97"><span class="toc-number">1.6.1.</span> <span class="toc-text"> TCP 半连接队列和全连接队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%AD%98%E5%9C%A8%E5%8D%8A%E8%BF%9E%E6%8E%A5%E9%98%9F%E5%88%97"><span class="toc-number">1.6.2.</span> <span class="toc-text"> 为什么要存在半连接队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E9%98%9F%E5%88%97%E6%BA%A2%E5%87%BA"><span class="toc-number">1.6.3.</span> <span class="toc-text"> 全队列溢出</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B2%E5%BE%A1tcp-syn%E6%94%BB%E5%87%BB"><span class="toc-number">1.7.</span> <span class="toc-text"> 防御 TCP syn 攻击</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#udp%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84"><span class="toc-number">1.8.</span> <span class="toc-text"> UDP 报文结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%AA%E9%A6%96%E9%83%A8"><span class="toc-number">1.8.1.</span> <span class="toc-text"> 伪首部</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#udp-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.9.</span> <span class="toc-text"> UDP 适用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#udp-flood"><span class="toc-number">1.10.</span> <span class="toc-text"> UDP flood</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#udp%E5%92%8Ctcp%E5%8C%BA%E5%88%AB"><span class="toc-number">1.11.</span> <span class="toc-text"> UDP 和 TCP 区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ip-%E6%8A%A5%E6%96%87%E7%BB%93%E6%9E%84"><span class="toc-number">1.12.</span> <span class="toc-text"> IP 报文结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E7%89%87"><span class="toc-number">1.13.</span> <span class="toc-text"> 分片</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#mss"><span class="toc-number">1.13.1.</span> <span class="toc-text"> MSS</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B2%98%E5%8C%85%E5%92%8C%E5%8D%8A%E5%8C%85"><span class="toc-number">1.14.</span> <span class="toc-text"> 粘包和半包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-number">1.14.1.</span> <span class="toc-text"> 滑动窗口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AA%97%E5%8F%A3%E5%8F%98%E5%8C%96"><span class="toc-number">1.14.2.</span> <span class="toc-text"> 窗口变化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nagle%E7%AE%97%E6%B3%95"><span class="toc-number">1.14.3.</span> <span class="toc-text"> Nagle 算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82%E7%9A%84%E6%8E%A5%E6%94%B6%E7%BC%93%E5%86%B2%E5%8C%BA%E5%92%8C%E5%8F%91%E9%80%81%E7%BC%93%E5%86%B2%E5%8C%BA"><span class="toc-number">1.14.4.</span> <span class="toc-text"> 应用层的接收缓冲区和发送缓冲区</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A7%E7%94%9F%E5%8E%9F%E5%9B%A0"><span class="toc-number">1.14.5.</span> <span class="toc-text"> 产生原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">1.14.6.</span> <span class="toc-text"> 解决方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6"><span class="toc-number">1.15.</span> <span class="toc-text"> 拥塞控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0"><span class="toc-number">1.16.</span> <span class="toc-text"> 超时重传</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ack"><span class="toc-number">1.17.</span> <span class="toc-text"> ACK</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#dup-ack"><span class="toc-number">1.17.1.</span> <span class="toc-text"> dup ack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#keep-alive-ack"><span class="toc-number">1.17.2.</span> <span class="toc-text"> keep-alive ack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tcp-retransmission"><span class="toc-number">1.17.3.</span> <span class="toc-text"> tcp retransmission</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tcp-spurious-retransmission"><span class="toc-number">1.17.4.</span> <span class="toc-text"> tcp spurious retransmission</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#tcp-fast-retransmission"><span class="toc-number">1.17.5.</span> <span class="toc-text"> tcp fast retransmission</span></a></li></ol></li></ol></li></ol>
      </div>
      <div class="related panel pjax" data-title="Related">
      </div>
      <div class="overview panel" data-title="Overview">
        <div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <img class="image" itemprop="image" alt="John Doe"
      data-src="/images/avatar.jpg">
  <p class="name" itemprop="name">John Doe</p>
  <div class="description" itemprop="description"></div>
</div>

<nav class="state">
    <div class="item posts">
      <a href="/archives/">
        <span class="count">40</span>
        <span class="name">posts</span>
      </a>
    </div>
    <div class="item categories">
      <a href="/categories/">
        <span class="count">4</span>
        <span class="name">categories</span>
      </a>
    </div>
    <div class="item tags">
      <a href="/tags/">
        <span class="count">4</span>
        <span class="name">tags</span>
      </a>
    </div>
</nav>

<div class="social">
</div>

<ul class="menu">
  
    
  <li class="item">
    <a href="/" rel="section"><i class="ic i-home"></i>Home</a>
  </li>


</ul>

      </div>
    </div>
  </div>

  <ul id="quick">
    <li class="prev pjax">
        <a href="/2023/04/05/Docker/" rel="prev" title="Previous Post"><i class="ic i-chevron-left"></i></a>
    </li>
    <li class="up"><i class="ic i-arrow-up"></i></li>
    <li class="down"><i class="ic i-arrow-down"></i></li>
    <li class="next pjax">
        <a href="/2023/04/15/Nginx_new/" rel="next" title="Next Post"><i class="ic i-chevron-right"></i></a>
    </li>
    <li class="percent"></li>
  </ul>
</div>


        </div>
        <div class="dimmer"></div>
      </div>
    </main>
    <footer id="footer">
      <div class="inner">
        <div class="widgets">
          
<div class="rpost pjax">
  <h2>Random Posts</h2>
  <ul>
      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/web%E5%AE%89%E5%85%A8/" title="In web安全">web安全</a>
</div>

    <span><a href="/2022/12/31/webshell/" title="webshell">webshell</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/2023/03/27/http/" title="http">http</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/web%E5%AE%89%E5%85%A8/" title="In web安全">web安全</a>
</div>

    <span><a href="/2022/08/16/Unserialize/" title="unserialize">unserialize</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E9%80%86%E5%90%91/" title="In 逆向">逆向</a>
</div>

    <span><a href="/2023/01/03/%E6%BB%B4%E6%B0%B4reverse/" title="水滴rev">水滴rev</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E9%80%86%E5%90%91/" title="In 逆向">逆向</a>
</div>

    <span><a href="/2022/11/11/reverse/" title="逆向">逆向</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E9%80%86%E5%90%91/" title="In 逆向">逆向</a>
</div>

    <span><a href="/2023/10/01/1234567/" title="henry windows逆向进阶">henry windows逆向进阶</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/2022/02/28/XSS/" title="XSS">XSS</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E7%A7%8B%E6%8B%9B/" title="In 秋招">秋招</a>
</div>

    <span><a href="/2022/10/27/%E7%A7%8B%E6%8B%9B%E6%80%BB%E7%BB%93/" title="秋招总结">秋招总结</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
</div>

    <span><a href="/2023/02/21/https%E5%8E%9F%E7%90%86/" title="https+TLS">https+TLS</a></span>
  </li>

      
  <li class="item">
    
<div class="breadcrumb">
<a href="/categories/%E9%80%86%E5%90%91/" title="In 逆向">逆向</a>
</div>

    <span><a href="/2022/11/01/%E6%B1%87%E7%BC%96/" title="汇编">汇编</a></span>
  </li>

  </ul>
</div>
<div>
  <h2>Recent Comments</h2>
  <ul class="leancloud-recent-comment"></ul>
</div>

        </div>
        <div class="status">
  <div class="copyright">
    
    &copy; 2010 – 
    <span itemprop="copyrightYear">2023</span>
    <span class="with-love">
      <i class="ic i-sakura rotate"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">John Doe @ Yume Shoka</span>
  </div>
  <div class="powered-by">
    Powered by <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span>
  </div>
</div>

      </div>
    </footer>
  </div>
<script data-config type="text/javascript">
  var LOCAL = {
    path: '2023/04/07/TCPIP_new/',
    favicon: {
      show: "（●´3｀●）Goooood",
      hide: "(´Д｀)Booooom"
    },
    search : {
      placeholder: "Search for Posts",
      empty: "We didn't find any results for the search: ${query}",
      stats: "${hits} results found in ${time} ms"
    },
    valine: true,fancybox: true,
    copyright: 'Copied to clipboard successfully! <br> All articles in this blog are licensed under <i class="ic i-creative-commons"></i>BY-NC-SA.',
    ignores : [
      function(uri) {
        return uri.includes('#');
      },
      function(uri) {
        return new RegExp(LOCAL.path+"$").test(uri);
      }
    ]
  };
</script>

<script src="https://cdn.polyfill.io/v2/polyfill.js"></script>

<script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script>

<script src="/js/app.js?v=0.2.5"></script>




</body>
</html>
