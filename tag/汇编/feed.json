{
    "version": "https://jsonfeed.org/version/1",
    "title": "Hexo • All posts by \"汇编\" tag",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2022/11/01/%E6%B1%87%E7%BC%96/",
            "url": "http://example.com/2022/11/01/%E6%B1%87%E7%BC%96/",
            "title": "汇编",
            "date_published": "2022-11-01T05:38:45.000Z",
            "content_html": "<h1 id=\"汇编\"><a class=\"markdownIt-Anchor\" href=\"#汇编\">#</a> 汇编</h1>\n<p>1. 汇编语言组成</p>\n<p>汇编指令 ，伪指令，其他符号</p>\n<p>2. 汇编不区分大小写</p>\n<p>3. 数据总线，控制总线，地址总线 – 外部总线</p>\n<h2 id=\"寄存器cpu\"><a class=\"markdownIt-Anchor\" href=\"#寄存器cpu\">#</a> 寄存器（CPU）</h2>\n<p>CPU 由运算器，控制器，寄存器组成，靠内部总线相连</p>\n<p>8086 有 14 个寄存器，它们的名称为 AB,BX,CX,DX，SI，DI，SP，BP，IP，CS，SS，DS，ES，PSW，都是 16 位</p>\n<p>AX,BX,CX,DX 为通用结存器，最大可以存储 2^16-1</p>\n<img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221009203327558.png\" alt=\"image-20221009203327558\" style=\"zoom:50%;\" />\n<p>每个又可以分为 H 和 L，比如 AH 和 AL，可以分开独立使用</p>\n<img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221009204003372.png\" alt=\"image-20221009204003372\" style=\"zoom:50%;\" />\n<p>1word = 2 Byte</p>\n<p>16 位 CPU 特征：1. 运算器一次最多处理 16 位 2，寄存器最大宽度为 16 位 3. 寄存器和运算器之间通路 16 位</p>\n<p>由于 cpu 内部总线是 16 位，但外部总线是 20 位</p>\n<p>8086 内部使用两个 16 位内部地址来将器变为 20 位</p>\n<img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221009211023097.png\" alt=\"image-20221009211023097\" style=\"zoom:50%;\" />\n<p>第一个地址为段地址，第二个为偏移地址 ，通过地址加法器变为 20 位</p>\n<p>物理地址 = 段地址 * 16 + 偏移地址</p>\n<img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221009211420365.png\" alt=\"image-20221009211420365\" style=\"zoom:50%;\" />\n<p>即地址左移四位，每次左移一位，对应的 16 进制和 10 进制就 * 2，因为地址是二进制</p>\n<p>扩展：一个 x 进制左移一位就 * x</p>\n<p>段地址长度可以自己指定，一个段的最大长度为 64kb，起始地址一定为 16 的倍数</p>\n<p>一个物理地址可以有很多种段地址和偏移地址的组合</p>\n<p>2000:1F60 数据在 21F60 中</p>\n<p>段寄存器 CS，DS，SS，ES</p>\n<p>CS：代码地址</p>\n<p>DS：数据地址</p>\n<p>SS：堆栈地址</p>\n<p>IP：指令指针寄存器</p>\n<p>修改 CS IP 中内容使用</p>\n<p>jmp 段地址：偏移地址</p>\n<p>jmp ax   // 仅修改 IP 内容，参数为合法寄存器，类似于 mov IP，AX</p>\n<p>8086cpu 工作过程</p>\n<p>1.CS:IP 指向内存单元读取执行，读取执行进入指令缓冲器</p>\n<p>2.IP 指向下一条指令</p>\n<p>3. 执行指令，重复到 1</p>\n<p>初始 CS=2000H，IP=0000H</p>\n<img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221010210638345.png\" alt=\"image-20221010210638345\" style=\"zoom:50%;\" />\n<p>mov ax 6622</p>\n<p>jmp 1000:3</p>\n<p>mov ax,0000</p>\n<p>mov bx,ax</p>\n<p>jmp bx</p>\n<p>mov ax,0123</p>\n<p>mov ax,0000</p>\n<p>… 死循环</p>\n<p>代码段</p>\n<p>将 &lt;=64kb 的一组代码，起始地址为 16 倍数的内存单元作为一个代码段</p>\n<p>通过 CS：IP 指向代码段首地址来执行代码段</p>\n<p>DEBUG</p>\n<p>用 Debug 的 R 命令查看、改变 CPU 寄存器的内容；</p>\n<p>用 Debug 的 D 命令查看内存中的内容；</p>\n<p>用 Debug 的 E 命令改写内存中的内容；</p>\n<p>用 Debug 的 U 命令将内存中的机器指令翻译成汇编指令；</p>\n<p>用 Debug 的 T 命令执行一条机器指令；</p>\n<p>用 Debug 的 A 命令以汇编指令的格式在内存中写入一条机器指令。</p>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221010213213522.png\" alt=\"image-20221010213213522\"></p>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221010213504618.png\" alt=\"image-20221010213504618\"></p>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221010213716733.png\" alt=\"image-20221010213716733\"></p>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221010213841925.png\" alt=\"image-20221010213841925\"></p>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221010214052414.png\" alt=\"image-20221010214052414\"></p>\n<p>fff0:0 ff 可以查看 rom 时间</p>\n<p>b810:0 可以修改显存</p>\n<img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221011204621998.png\" alt=\"image-20221011204621998\" style=\"zoom:50%;\" />\n<p>1 地址字单元存放的字型数据时 124EH</p>\n<p>可以将 N 和 N+1 两个单元看成一个字单元</p>\n<h2 id=\"寄存器内存\"><a class=\"markdownIt-Anchor\" href=\"#寄存器内存\">#</a> 寄存器（内存）</h2>\n<p>MOV al,[0]  // 将偏移地址为 0 的内存单元送到 AL 寄存器中</p>\n<p>不能把立即数直接送入段寄存器 ，需要经过通用寄存器中转</p>\n<p>数据 -》通用寄存器 -》段寄存器</p>\n<p>将数据从寄存器送入内存单元</p>\n<p>mov bx,1000H</p>\n<p>mov ds,bx</p>\n<p>mov [0],al</p>\n<img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221011210109223.png\" alt=\"image-20221011210109223\" style=\"zoom:50%;\" />\n<img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221011210150336.png\" alt=\"image-20221011210150336\" style=\"zoom:50%;\" />\n<p>-e 1000:0 23 11 22 66</p>\n<p>1122 8833 8833</p>\n<img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221012084245812.png\" alt=\"image-20221012084245812\" style=\"zoom:50%;\" />\n<p>2c34</p>\n<p>1B12   -d 1000:0</p>\n<p>0000</p>\n<p>mov 指令</p>\n<blockquote>\n<p>mov 寄存器，数据</p>\n<p>mov 寄存器，寄存器</p>\n<p>mov 寄存器，内存单元   mov ax,[0]</p>\n<p>mov 内存单元，客存器   mov [0],ax</p>\n<p>mov 段寄存器，寄存器</p>\n<p>mov 寄存器，段寄存器</p>\n</blockquote>\n<p>add，sub</p>\n<blockquote>\n<p>add 寄存器，数据</p>\n<p>add 寄存器，寄存器</p>\n<p>add 寄存器，内存单元</p>\n<p>add 内存单元，寄存器</p>\n<p>sub 寄存器，数据</p>\n<p>sub 寄存器，寄存器</p>\n<p>sub 寄存器，内存单元</p>\n<p>sub 内存单元，寄存器</p>\n</blockquote>\n<p>add,sub 不能使用段寄存器为参数</p>\n<p>数据段：长度为 N 的地址连续，起始地址为 16 倍数的内存单元定义为存储数据的内存空间</p>\n<p>将 123B0-123BA 的前三个单元的字节型数据累加</p>\n<img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221012212730685.png\" alt=\"image-20221012212730685\" style=\"zoom:50%;\" />\n<p>累加字型数据</p>\n<img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221012213223456.png\" alt=\"image-20221012213223456\" style=\"zoom:50%;\" />\n<p>[address] 表示一个偏移地址为 address 的内存单元</p>\n<p><img data-src=\"../AppData/Roaming/Typora/typora-user-images/image-20221012214721228.png\" alt=\"image-20221012214721228\"></p>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221012214843733.png\" alt=\"image-20221012214843733\"></p>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221012215020183.png\" alt=\"image-20221012215020183\"></p>\n<p>即 [0] 073F 和 073F [0] 会将 073f 当做偏移地址，验证：</p>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221012215201456.png\" alt=\"image-20221012215201456\"></p>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221012215301128.png\" alt=\"image-20221012215301128\"></p>\n<h4 id=\"栈\"><a class=\"markdownIt-Anchor\" href=\"#栈\">#</a> 栈</h4>\n<p>8086 提供的入栈和出栈 push,pop</p>\n<p>push ax 将寄存器 ax 中的数据送入栈中</p>\n<p>pop ax 从栈顶取出数据送入 ax</p>\n<p>通过段寄存器 SS 存放栈顶的段地址，sp 存放栈顶偏移地址，任意时刻，SS:SP 指向栈顶元素</p>\n<p>push ax sp=sp-2,SS:SP 指向新栈顶，放入数据</p>\n<img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221013193051835.png\" alt=\"image-20221013193051835\" style=\"zoom:50%;\" />\n<img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221013193356305.png\" alt=\"image-20221013193356305\" style=\"zoom:50%;\" />\n<blockquote>\n<p>任意时刻・SS:SP 指向栈顶元素。当栈为空的时候，栈中没有元素，也就不存在栈项元素<br>\n所 SS:SP 只能指向栈的最底部单元下面的单元，该单元的偏移地址为栈最底部的字单元的偏移地址 + 2<br>\n 栈最底部字单元的地址为 1000:000E，所以栈空时 SP=0010H</p>\n</blockquote>\n<p>pop ax  将数据送入 ax 中，SP=SP+2，数据仍在内存中，下一次 push 或其他写入数据的操作时会覆盖</p>\n<img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221013194330665.png\" alt=\"image-20221013194330665\" style=\"zoom:50%;\" />\n<p>push 和 pop 可以操作段寄存器，通用寄存器，内存单元</p>\n<p>push ax</p>\n<p>push ds</p>\n<p>push [0]</p>\n<h4 id=\"栈顶越界\"><a class=\"markdownIt-Anchor\" href=\"#栈顶越界\">#</a> 栈顶越界</h4>\n<p>栈满 push，栈空 pop 产生越界</p>\n<p>栈满 push 会导致溢出覆盖栈外的数据</p>\n<p>栈空 pop 会将别的数据放入寄存器中产生溢出</p>\n<p>8086CPU 中没有检测的机制，需要自己注意…</p>\n<h4 id=\"练习\"><a class=\"markdownIt-Anchor\" href=\"#练习\">#</a> 练习</h4>\n<p>将 10000H~1000FH 这段空间当作栈，初始状态是空的，将 AX,BX,DS 中的数据入栈</p>\n<p>mov ax,1000</p>\n<p>mov ss,ax</p>\n<p>mov sp,0010</p>\n<p>push ax</p>\n<p>push bx</p>\n<p>push ds</p>\n<p>(1）将 10000H~1000FH 这段空间当作栈，初始状态是空的；</p>\n<p>(2）设置 AX=001AH，BX=001BH;</p>\n<p>(3）将 AX，BX 中的数据入栈</p>\n<p>(4）然后将 AX，BX 清零；</p>\n<p>(5）从栈中恢复 AX，BX 原来的内容。</p>\n<p>mov ax,1000</p>\n<p>mov ss,ax</p>\n<p>mov sp,0010</p>\n<p>mov ax,001A</p>\n<p>mov bx,001B</p>\n<p>push ax</p>\n<p>push bx</p>\n<p>mov ax,0   // 使用 sub ax,ax 只使用两个字节，mov ax,0 机器码需要三个字节，也可以使用 xor ax,ax</p>\n<p>mov bx,0</p>\n<p>pop bx</p>\n<p>pop ax</p>\n<p>(1)   将 10000H~1000FH 这段空间当栈，初始状态是空的；</p>\n<p>(2）设置 AX=002AH ，BX=002BH;</p>\n<p>(3）利用栈交换 AX 和 BX 中的数据。</p>\n<p>mov ax,1000</p>\n<p>mov ss,ax</p>\n<p>mov sp,0010</p>\n<p>mov ax,002A</p>\n<p>mov bx,002B</p>\n<p>push ax</p>\n<p>push bx</p>\n<p>pop ax</p>\n<p>pop bx</p>\n<p>我们如果要在 10000H 处写入字型数据 2266H, 可以用以下的代码完成︰</p>\n<p>mov ax,1000H</p>\n<p>mov ds,ax</p>\n<p>mov ax,2266H</p>\n<p>mov [0],ax</p>\n<p>补在 10000H 处写入字型数据 2266H</p>\n<p>mov ax,1000</p>\n<p>mov ss,ax</p>\n<p>mov sp,2   //push 之前先 - 2，在放输入，2-2=0</p>\n<p>mov ax,2266</p>\n<p>push ax</p>\n<p>要求，不能用 mov 内存单元，寄存器这类指令</p>\n<p>push，pop 实质上是一种内存传送指令，push，pop 访问的内存单元的地址是由 ss:sp 指出的</p>\n<p>pop，pop 栈操作只修改 sp，sp 最大变化范围为 0-FFFF</p>\n<p>如果我们将 10000H~1FFFFH 这段空间当作栈段，初始状态是空的，比时 SS=1000H，SP=0</p>\n<p>栈顶变化范围为 0-FFFFH，栈空 sp=0，一直压栈，栈满后 sp=0，再次压栈，栈顶将环绕，覆盖原来内容</p>\n<p>对于代码段，数据段，栈段，cpu 通过 CS DS SS 区分</p>\n<p>CS:IP</p>\n<p>SS:SP</p>\n<p>DS:[0]</p>\n<h2 id=\"程序编写\"><a class=\"markdownIt-Anchor\" href=\"#程序编写\">#</a> 程序编写</h2>\n<p>1. 编写汇编程序，后缀为.asm</p>\n<p>2. 编译 masm.exe 连接 link.exe</p>\n<p>3. 执行可执行文件，有程序和数据两部分，操作系统加可执行文件中的机器码和数据加载入内存，进行初始化</p>\n<p>源程序</p>\n<img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221015201813041.png\" alt=\"image-20221015201813041\" style=\"zoom:50%;\" />\n<p>汇编指令上图中 mov，add，int 等</p>\n<p>伪指令上图中 assume codesg，没有对应的机器码，不被 cpu 执行，被编译器执行</p>\n<p>定义一个段</p>\n<p>segment 和 ends 是一对成对的伪指令，定义一个段 segment 开始，ends 结束</p>\n<p>格式:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">段名 segment </span><br><span class=\"line\">段名 ends</span><br></pre></td></tr></table></figure>\n<p>一个汇编程序由多个段组成</p>\n<p>ends 是汇编程序结束标记</p>\n<p>assume 假设寄存器和段关联，CS:codesg，假设代码段的名称为 codesg</p>\n<p>将源程序文件中内容称为源程序，编译后称为程序，程序放在可执行文件中 PE</p>\n<img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221015203100625.png\" alt=\"image-20221015203100625\" style=\"zoom:50%;\" />\n<p>标号 一个标号指代一个地址，codesg</p>\n<p>编程运算 2^3</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:abc</span><br><span class=\"line\">abc segent</span><br><span class=\"line\">mov ax,2</span><br><span class=\"line\">add ax,ax</span><br><span class=\"line\">add ax,ax</span><br><span class=\"line\">abc ends</span><br><span class=\"line\">end</span><br></pre></td></tr></table></figure>\n<p>DOS 是一个单任务操作系统，一个程序结束后，将 CPU 控制权交还给使他运行的程序，称为返回</p>\n<p>返回 程序段</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov ax,4c00H</span><br><span class=\"line\">int 21H</span><br></pre></td></tr></table></figure>\n<img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221015204512894.png\" alt=\"image-20221015204512894\" style=\"zoom:50%;\" />\n<p>masm.exe 1.asm</p>\n<p>link 1.obj</p>\n<p>可以在命令后加上；简化编译和连接</p>\n<p>连接：源程序很大时将他分为多个源程序编译，成文目标文件后在连接到一起。将库文件和程序的目标文件连接在一起才可以生成可执行文件</p>\n<p>在 DOS 中运行 1.exe 时，DOS 的 command 将 1.exe 加载进入内存，command 设置 CPU 的 cs:IP 指向程序的第一条指令，从而得以使程序运行。</p>\n<p>程序运行结束后，返回到 command 中，cpu 继续执行 command</p>\n<img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221016204217510.png\" alt=\"image-20221016204217510\" style=\"zoom:67%;\" />\n<p>Debug 将程序加载进入内存，当不放弃对 cpu 控制，使用中断实现</p>\n<p>有入口的程序</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:codesg</span><br><span class=\"line\">    codesg segment</span><br><span class=\"line\">    start:\tmov ax,0123H</span><br><span class=\"line\">    \t\tadd bx,0456H</span><br><span class=\"line\">    \t\tadd ax,bx</span><br><span class=\"line\">    \t\tadd ax,ax</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\tmov ax,4c00H</span><br><span class=\"line\">\t\t\tint 21H</span><br><span class=\"line\">    \t\t</span><br><span class=\"line\">codesg ends</span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure>\n<p>debug 将程序 exe 加载入内存后 cx，存放程序长度</p>\n<p>程序加载后，ds 中放着程序所在内存区的段地址，这个内存区的偏移地址为 0，这个内存区的前 256 个字节存放的是 psp，dos 用来和程序进行通信，从 256 字节以后存放的是程序</p>\n<p>psp 的段地址 SA，偏移地址为 0，表示为 SA+10:0</p>\n<img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221016211036041.png\" alt=\"image-20221016211036041\" style=\"zoom:50%;\" />\n<p>指定到 int 21 时用 p 执行，此时程序 terminated</p>\n<p>使用 q 结束 debug，回到 command 中，因为 debug 由 command 加载</p>\n<h2 id=\"bxloop\"><a class=\"markdownIt-Anchor\" href=\"#bxloop\">#</a> [bx]&amp;loop</h2>\n<p>bx:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:codesg</span><br><span class=\"line\">    codesg segment</span><br><span class=\"line\">    start:\tmov ax,2000</span><br><span class=\"line\">    \t\tmov ds,ax</span><br><span class=\"line\">    \t\tmov al,[0]</span><br><span class=\"line\">    \t\tmov bl,[1]</span><br><span class=\"line\">    \t\tmov cl,[2]</span><br><span class=\"line\">    \t\tmov dl,[3]</span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\t\tmov ax,4c00H</span><br><span class=\"line\">\t\t\tint 21H</span><br><span class=\"line\">    \t\t</span><br><span class=\"line\">codesg ends</span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure>\n<p>实际来说，CPU 并不认编译器的 [0] 这种东西，他会认成 0</p>\n<p>但 debug 中 [0] 可以正常作为偏移地址</p>\n<p>[bx] 表示一个内存单元，偏移地址在 bx 中</p>\n<p>mov bx,0   // 将 0 给 bx</p>\n<p>mov ax,[bx]   // 此时 bx 是偏移地址</p>\n<p>段地址 SA，偏移地址 EA  SA：EA</p>\n<p>() 的含义</p>\n<p>ax 中的内容为 0010，那么 (ax)=0010</p>\n<p>2000:1000 处的内容为 0010，(21000H)=0010</p>\n<p>mov ax,[2] (ax)=((dx)*16+2)</p>\n<p>idata 含义：</p>\n<p>idata 表示常量</p>\n<p>mov ax,[idata] 代表 Mov ax,[0]  Mov ax,[2]  Mov ax,[3]  d = 等</p>\n<p>inc bx    //bx++</p>\n<img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221017094727684.png\" alt=\"image-20221017094727684\" style=\"zoom:67%;\" />\n<p>ax 00be</p>\n<p>bx 1002</p>\n<p>内存中 00be 00be</p>\n<p>bx 1004</p>\n<p>内存中 00be 00be 00be</p>\n<p>内存中从左到右为从低到高</p>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221017094440863.png\" alt=\"image-20221017094440863\"></p>\n<p>内存中 00be 00be 00be be 00</p>\n<p>Loop</p>\n<p>loop 标号</p>\n<p>执行 loop 时 CPU 操作</p>\n<p>1.(cx)=(cx)-1</p>\n<p>2. 判断 cx 中的值，不为 0 跳至标号处执行，为 0 向下执行</p>\n<p>即一般 cx 中存放循环次数</p>\n<p>使用 loop 计算 2^2</p>\n<p>mov ax,2</p>\n<p>add ax,ax</p>\n<p>计算 2^12</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code</span><br><span class=\"line\">code segment</span><br><span class=\"line\">start:\tmov ax,2</span><br><span class=\"line\">\t\tmov cx,11</span><br><span class=\"line\">s: \t\tadd ax,ax</span><br><span class=\"line\">\t\tloop s</span><br><span class=\"line\">\t</span><br><span class=\"line\">        mov ax,4c00h</span><br><span class=\"line\">        int 21h</span><br><span class=\"line\">\t</span><br><span class=\"line\">code ends</span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure>\n<p>注意：debug 默认 16 进制，masm 默认十进制</p>\n<p>loop 相当于 do … while …</p>\n<p>计算 123*236 时使用 236+123 次，减少循环次数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code</span><br><span class=\"line\">code segment</span><br><span class=\"line\">start:\tmov ax,0</span><br><span class=\"line\">\t\tmov cx,123</span><br><span class=\"line\">s: \t\tadd ax,236</span><br><span class=\"line\">\t\tloop s</span><br><span class=\"line\">\t</span><br><span class=\"line\">        mov ax,4c00h</span><br><span class=\"line\">        int 21h</span><br><span class=\"line\">\t</span><br><span class=\"line\">code ends</span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure>\n<p>汇编时数据不能以字母开头，要在前面 + 0</p>\n<p>debug g 命令和 p 命令</p>\n<p>将 ffff:0006 单元中的数据 * 123，结果存在 dx 中</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code</span><br><span class=\"line\">code segment</span><br><span class=\"line\">start:\tmov ax,0ffffh</span><br><span class=\"line\">\t\tmov ds,ax</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tmov bx,6</span><br><span class=\"line\">\t\tmov ax,[bx]</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tmov dx,0</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tmov cx,123</span><br><span class=\"line\">s:\t\tadd dx,ax</span><br><span class=\"line\">\t\tloop s</span><br><span class=\"line\">\t</span><br><span class=\"line\">        mov ax,4c00h</span><br><span class=\"line\">        int 21h</span><br><span class=\"line\">\t</span><br><span class=\"line\">code ends</span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure>\n<p>g 0014   // 直接执行到 IP 为 0014 的位置</p>\n<p>p 直接执行到循环结束，如果不是 21H 的位置输入</p>\n<p>在程序中</p>\n<p>mov al, ds:[0]    // == mov bx,0  mov al,[bx], == mov al,[0]</p>\n<p>累加 [0]-[b] 的值</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code</span><br><span class=\"line\">code segment</span><br><span class=\"line\">start:\tmov ax,0ffffh</span><br><span class=\"line\">\t\tmov ds,ax</span><br><span class=\"line\">\t\tmov bx,0</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tmov dx,0</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tmov cx,12</span><br><span class=\"line\">s:\t\tmov al,ds:[cs]</span><br><span class=\"line\">\t\tmov ah,0</span><br><span class=\"line\">\t\tadd dx,ax</span><br><span class=\"line\">\t\tinc bx</span><br><span class=\"line\">\t\tloop s</span><br><span class=\"line\"></span><br><span class=\"line\">\t</span><br><span class=\"line\">        mov ax,4c00h</span><br><span class=\"line\">        int 21h</span><br><span class=\"line\">\t</span><br><span class=\"line\">code ends</span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure>\n<p>段前缀</p>\n<p>mov ax,cs:[0]    //cs 为段前缀</p>\n<p>一般类似或 0:200-0:2ff 不会有数据和指令，是一段安全的空间</p>\n<p>将内存 ffff:0<sub>ffff:b 段元中的数据拷贝到 0:200</sub>0:20b 单元中。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code</span><br><span class=\"line\">code segment</span><br><span class=\"line\">start:\tmov ax,0ffffh</span><br><span class=\"line\">\t\tmov ds,ax  ;ds中是内存ffff:0中的数据</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tmov ax,0020h</span><br><span class=\"line\">\t\tmov es,ax  ;es是内存20:0中的数据</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tmov bx,0   ;bx中为内存偏移值</span><br><span class=\"line\">\t\tmov cx,12  ;为循环判断条件</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">s:\t\tmov dl,ds:[bx]</span><br><span class=\"line\">\t\tmov es:[bx],dl</span><br><span class=\"line\">\t\tinc bx</span><br><span class=\"line\">\t\tloop s</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t</span><br><span class=\"line\">        mov ax,4c00h</span><br><span class=\"line\">        int 21h</span><br><span class=\"line\">\t</span><br><span class=\"line\">code ends</span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure>\n<h2 id=\"多个段的程序\"><a class=\"markdownIt-Anchor\" href=\"#多个段的程序\">#</a> 多个段的程序</h2>\n<p>我们是不能自己随便决定哪段空间可以使用的，应该让系统来为我们分配。<strong>我们可以在程序中</strong>，定义我们希望处理的数据，这些数据就会被编译、连接程序作为程序的一部分写到可执行文件中。当可执行文件中的程序被加载入内存时，这些数据也同时被加载入内存中。与此同时，我们要处理的数据也就自然而然地获得了存储空间。</p>\n<p>dw define word 定义字型数据，在代码段中定义数据，此时代码 的起始位置是数据之后</p>\n<p>db 定义字节型数据</p>\n<p>数据之间用，分隔</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code</span><br><span class=\"line\">code segment</span><br><span class=\"line\">\t\tdw 0123h,0234h,0123h,0234h,0123h,0234h,0123h,0234h</span><br><span class=\"line\">start:\tmov ax,0ffffh</span><br><span class=\"line\">\t\tmov ds,ax  </span><br></pre></td></tr></table></figure>\n<p>标号 start 定义代码段的开始，区分数据和代码</p>\n<p>-u 13f8:0</p>\n<p>-u 13f8:10</p>\n<p>读取结果不一样，如果数据被读成了代码，会导致下面真正的代码读取错误，因此在 debug 加载后，我们需要将 IP 设置为代码段中数据段的结束，比如上面的代码，我们需要将 IP 定义为 10 (10 进制的 16)</p>\n<p>end start 可以告诉编译器程序的入口，即标号的地方。我们若要 CPU 从何处开始执行程序，只要在源程序中用 “end 标号” 指明就可以了。</p>\n<p>代码段中使用栈</p>\n<p>若数据，栈，代码所需空间查过 64kb，就不能放到一个栈中，因此应该用多个段存放数据，代码和栈</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:codesg</span><br><span class=\"line\">codesg segment</span><br><span class=\"line\">\tdw 0123H,0123H,0123H,0123H,0123H,0123H,0123H,0123H</span><br><span class=\"line\">\tdw 0,0,0,0,0,0,0,0  ;将上一行dw的数据入栈和出栈的空间</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t</span><br><span class=\"line\">start:\tmov ax,cs  ;将代码段起始位置给栈段</span><br><span class=\"line\">\t\tmov ss,ax</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tmov sp,32  ;设置栈段的偏移地址为32(0+2*16)+1</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tmov bx,0   ;bx偏移地址</span><br><span class=\"line\">\t\tmov cx,8   ;cx loop条件</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">s:\t\tpush cs:[bx] ;将cs中的数据入栈</span><br><span class=\"line\">\t\tadd bx,2</span><br><span class=\"line\">\t\tloop s</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tmov bx,0</span><br><span class=\"line\">\t\tmov cx,8</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">s0:\t\tpop cs:[bx]  ;将cs中的数据出栈</span><br><span class=\"line\">\t\tadd bx,2</span><br><span class=\"line\">\t\tloop s0</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tmov ax,4c00H</span><br><span class=\"line\">\t\tint 21H</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">codesg ends</span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure>\n<p>存放数据的 data，存放 stack 栈，cs 存放代码</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code,ds:data,ss:stack</span><br><span class=\"line\"></span><br><span class=\"line\">data segment</span><br><span class=\"line\">\tdw 0123H,0123H,0123H,0123H,0123H,0123H,0123H,0123H</span><br><span class=\"line\">data ends</span><br><span class=\"line\"></span><br><span class=\"line\">stack segment</span><br><span class=\"line\">\tdw 0,0,0,0,0,0,0,0</span><br><span class=\"line\">stack ends</span><br><span class=\"line\"></span><br><span class=\"line\">code segment</span><br><span class=\"line\">start:\tmov ax,stack</span><br><span class=\"line\">\t\tmov ss,ax</span><br><span class=\"line\">\t\tmov sp,16</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tmov ax,data</span><br><span class=\"line\">\t\tmov ds,ax</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tmov bx,0</span><br><span class=\"line\">\t\tmov cx,8</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">s:\t\tpush [bx] </span><br><span class=\"line\">\t\tadd bx,2</span><br><span class=\"line\">\t\tloop s</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tmov bx,0</span><br><span class=\"line\">\t\tmov cx,8</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">s0:\t\tpop [bx]</span><br><span class=\"line\">\t\tadd bx,2</span><br><span class=\"line\">\t\tloop s0</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tmov ax,4c00H</span><br><span class=\"line\">\t\tint 21H</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">codesg ends</span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure>\n<p>在程序中，段名就相当于一个标号，它代表了段地址。所以指令 “mov ax,data” 的含义就是将名称为 “data” 的段的段地址送入 ax。</p>\n<p>CPU 处理我们定义的段中的内容，是通过程序中的汇编指令，和汇编指令对 CS:IP,SS:SP，DS 等寄存器的设置来决定</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:b,ds:a,ss:c</span><br><span class=\"line\">....</span><br><span class=\"line\">b segment</span><br><span class=\"line\">d:\tmov ax,c</span><br><span class=\"line\">\tmov ss,ax</span><br><span class=\"line\">\tmov sp,20h   ;将c当做栈空间，ss:sp指向c:20</span><br></pre></td></tr></table></figure>\n<p>程序占 N 个字节，运行后，该端实际占有空间为 (段为 16 的倍数)</p>\n<p>(N/16+1)*16</p>\n<p>如果没有 end 后面的标号，CPU 会将第一个数据当做代码段的开始</p>\n<p>程序如下，编写 code 段中的代码，将 a 段和 b 段中的数据依次相加，将结果存到 c 段中。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code</span><br><span class=\"line\"></span><br><span class=\"line\">a segment</span><br><span class=\"line\">\tdb 1,2,3,4,5,6,7,8</span><br><span class=\"line\">a ends</span><br><span class=\"line\"></span><br><span class=\"line\">b segment </span><br><span class=\"line\">\tdb 1,2,3,4,5,6,7,8</span><br><span class=\"line\">b ends</span><br><span class=\"line\"></span><br><span class=\"line\">c segment</span><br><span class=\"line\">\tdb 0,0,0,0,0,0,0,0</span><br><span class=\"line\">c ends</span><br><span class=\"line\"></span><br><span class=\"line\">code segment</span><br><span class=\"line\">start:\tmov ax,a</span><br><span class=\"line\">\t\tmov ds,ax   ;ds中为数据段a中的数据</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tmov ax,c</span><br><span class=\"line\">\t\tmov es,ax   ;es中为数据段c中的数据</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tmov bx,0</span><br><span class=\"line\">\t\tmov cx,8</span><br><span class=\"line\">\t\t </span><br><span class=\"line\">s:\t\tmov dx,ds:[bx]   ;循环将ds(a)中的数据给c</span><br><span class=\"line\">\t\tmov es:[bx],dx   </span><br><span class=\"line\">\t\tadd bx,2</span><br><span class=\"line\">\t\tloop s</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tmov ax,b</span><br><span class=\"line\">\t\tmov ds,ax</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tmov bx,0</span><br><span class=\"line\">\t\tmov cx,8</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">s0:\t\tmov dx,ds:[bx]</span><br><span class=\"line\">\t\tadd es:[bx],dx</span><br><span class=\"line\">\t\tadd bx,2</span><br><span class=\"line\">\t\tloop s0</span><br><span class=\"line\">\t\t\t\t</span><br><span class=\"line\">\t\tmov ax,4c00H</span><br><span class=\"line\">\t\tint 21H</span><br><span class=\"line\"></span><br><span class=\"line\">code ends</span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221019214952321.png\" alt=\"image-20221019214952321\"></p>\n<h2 id=\"更灵活定位内存地址\"><a class=\"markdownIt-Anchor\" href=\"#更灵活定位内存地址\">#</a> 更灵活定位内存地址</h2>\n<p>and 逻辑与，按位进行与运算，通过该指令可以将操作对象响应为设为 0，只要和 0 and</p>\n<p>or 逻辑或，按位进行或运算，通过该指令可以将操作对象相应位设为 0，只要和 1 or</p>\n<p>通过’  ’ 括起来标识一个字符</p>\n<p>db ‘unIX’  相当于 db 75H,6Eh,49H,58H   define byte</p>\n<p>mov al,‘a’  相当于 mov al,61H</p>\n<p>通过 将第五位二进制数和 0 与变为大写</p>\n<p>[bx+idata] 表名一个内存单元，偏移地址为 idata</p>\n<p>mov ax,[200+bx]</p>\n<p>mov ax,[bx+200]</p>\n<p>mov ax,200[bx]</p>\n<p>mov ax,[bx].200</p>\n<p>以上四个写法等效</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">\t\tmov ax,datasg</span><br><span class=\"line\">\t\tmov ds,ax</span><br><span class=\"line\">\t\tmov bx,0</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tmov cx,5</span><br><span class=\"line\">s:\t\tmov al,[bx]</span><br><span class=\"line\">\t\tand al,11011111b</span><br><span class=\"line\">\t\tmov [bx],al</span><br><span class=\"line\">\t\tmov al,[5+bx]</span><br><span class=\"line\">\t\tor al,00100000b</span><br><span class=\"line\">\t\tmov [5+bx],al</span><br><span class=\"line\">\t\tinc bx</span><br><span class=\"line\">\t\tloop s</span><br></pre></td></tr></table></figure>\n<p>SI,DI</p>\n<p>和 bx 功能相近，但不能分成两个八位寄存器使用</p>\n<p>mov ax,[bx]</p>\n<p>mov ax,[si]</p>\n<p>mov ax,[di]</p>\n<p>一般用 si 指向原始空间，di 指向目标空间</p>\n<p>mov ax,[bx+si]  == mov ax,[bx][si]</p>\n<p>[bx+si+idata] == mov ax,idata[bx][si]  ==  mov ax,[bx][si].200  == mov ax,[bx].200[si]</p>\n<p>将 db 中的每个字母第一个变为大写</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:codesg, ds:datasg</span><br><span class=\"line\"></span><br><span class=\"line\">datasg segment</span><br><span class=\"line\">\tdb &#x27;1.file       &#x27;</span><br><span class=\"line\">\tdb &#x27;2.file       &#x27;</span><br><span class=\"line\">\tdb &#x27;3.file       &#x27;</span><br><span class=\"line\">\tdb &#x27;4.file       &#x27;</span><br><span class=\"line\">\tdb &#x27;5.file       &#x27;</span><br><span class=\"line\">\tdb &#x27;6.file       &#x27;</span><br><span class=\"line\">datasg ends</span><br><span class=\"line\"></span><br><span class=\"line\">codesg segment</span><br><span class=\"line\">start:\tmov dx,datasg</span><br><span class=\"line\">\t\tmov ds,dx</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tmov bx,0</span><br><span class=\"line\">\t\tmov cx,6</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">s:\t\tmov al,[bx+3]</span><br><span class=\"line\">\t\tand al,11011111b</span><br><span class=\"line\">\t\tmov [bx+3],al</span><br><span class=\"line\">\t\tadd bx,16</span><br><span class=\"line\">\t\tloop s</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tmov ax,4cooH</span><br><span class=\"line\">\t\tint 21H</span><br><span class=\"line\">codesg ends</span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure>\n<p>将 datasg 的每个字母变为大写</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:codesg, ds:datasg</span><br><span class=\"line\"></span><br><span class=\"line\">datasg segment</span><br><span class=\"line\">\tdb &#x27;add       &#x27;</span><br><span class=\"line\">\tdb &#x27;asm       &#x27;</span><br><span class=\"line\">\tdb &#x27;and       &#x27;</span><br><span class=\"line\">\tdb &#x27;ano       &#x27;</span><br><span class=\"line\">datasg ends</span><br><span class=\"line\"></span><br><span class=\"line\">codesg segment</span><br><span class=\"line\">start:\tmov dx,datasg</span><br><span class=\"line\">\t\tmov ds,dx</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tmov bx,0</span><br><span class=\"line\">\t\tmov cx,4</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">s0:\t\tmov ax,cx</span><br><span class=\"line\">\t\tmov si,0</span><br><span class=\"line\">\t\tmov cx,3</span><br><span class=\"line\">s:\t\tmov al,[bx+si]</span><br><span class=\"line\">        and al,11011111b</span><br><span class=\"line\">        mov [bx+si],al</span><br><span class=\"line\">        inc si</span><br><span class=\"line\">        loop s</span><br><span class=\"line\">\t\tadd bx,16</span><br><span class=\"line\">\t\tmov cx,ax</span><br><span class=\"line\">\t\tloop s0</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\tmov ax,4cooH</span><br><span class=\"line\">\t\tint 21H</span><br><span class=\"line\">codesg ends</span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure>\n<p>这样做 cx 不会被覆盖导致死循环，进入循环前先保存起来</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:codesg, ds:datasg</span><br><span class=\"line\"></span><br><span class=\"line\">datasg segment</span><br><span class=\"line\">\tdb &#x27;add       &#x27;</span><br><span class=\"line\">\tdb &#x27;asm       &#x27;</span><br><span class=\"line\">\tdb &#x27;and       &#x27;</span><br><span class=\"line\">\tdb &#x27;ano       &#x27;</span><br><span class=\"line\">\tdw 0    ;用于保存cx</span><br><span class=\"line\">datasg ends</span><br><span class=\"line\"></span><br><span class=\"line\">codesg segment</span><br><span class=\"line\">start:\tmov dx,datasg</span><br><span class=\"line\">\t\tmov ds,dx</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tmov bx,0</span><br><span class=\"line\">\t\tmov cx,4</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">s0:\t\tmov ds:[40H],cx</span><br><span class=\"line\">\t\tmov si,0</span><br><span class=\"line\">\t\tmov cx,3</span><br><span class=\"line\">s:\t\tmov al,[bx+si]</span><br><span class=\"line\">        and al,11011111b</span><br><span class=\"line\">        mov [bx+si],al</span><br><span class=\"line\">        inc si</span><br><span class=\"line\">        loop s</span><br><span class=\"line\">\t\tadd bx,16</span><br><span class=\"line\">\t\tmov cx,ds:[40H]</span><br><span class=\"line\">\t\tloop s0</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\tmov ax,4cooH</span><br><span class=\"line\">\t\tint 21H</span><br><span class=\"line\">codesg ends</span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure>\n<p>将 cx 放在内存中来解决寄存器不够的问题</p>\n<p>更好的办法是使用栈，在调用函数前 push 到栈中，调用结束后 pop 回内存中，防止因为调用函数导致寄存器被篡改</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:codesg, ds:datasg</span><br><span class=\"line\"></span><br><span class=\"line\">datasg segment</span><br><span class=\"line\">\tdb &#x27;add       &#x27;</span><br><span class=\"line\">\tdb &#x27;asm       &#x27;</span><br><span class=\"line\">\tdb &#x27;and       &#x27;</span><br><span class=\"line\">\tdb &#x27;ano       &#x27;</span><br><span class=\"line\">\tdw 0    ;用于保存cx</span><br><span class=\"line\">datasg ends</span><br><span class=\"line\"></span><br><span class=\"line\">stacksg segment</span><br><span class=\"line\">\tdw 0,0,0,0,0,0,0,0</span><br><span class=\"line\">stacksg ends</span><br><span class=\"line\"></span><br><span class=\"line\">codesg segment</span><br><span class=\"line\">start:\tmov ax,stacksg</span><br><span class=\"line\">\t\tmov ss,ax</span><br><span class=\"line\">\t\tmov sp,16</span><br><span class=\"line\">\t\tmov ax,datasg</span><br><span class=\"line\">\t\tmov ds,ax</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tmov bx,0</span><br><span class=\"line\">\t\tmov cx,4</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">s0:\t\tpush cx</span><br><span class=\"line\">\t\tmov si,0</span><br><span class=\"line\">\t\tmov cx,3</span><br><span class=\"line\">s:\t\tmov al,[bx+si]</span><br><span class=\"line\">        and al,11011111b</span><br><span class=\"line\">        mov [bx+si],al</span><br><span class=\"line\">        inc si</span><br><span class=\"line\">        loop s</span><br><span class=\"line\">\t\tadd bx,16</span><br><span class=\"line\">\t\tpop cx</span><br><span class=\"line\">\t\tloop s0</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\tmov ax,4cooH</span><br><span class=\"line\">\t\tint 21H</span><br><span class=\"line\">codesg ends</span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure>\n<p>将 datasg 段中每个单词的前四个字改为大写字</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:codesg,ds:datasg,ss:stacksg</span><br><span class=\"line\"></span><br><span class=\"line\">datasg segment</span><br><span class=\"line\">\tdb &#x27;1. display       &#x27;</span><br><span class=\"line\">\tdb &#x27;2. display       &#x27;</span><br><span class=\"line\">\tdb &#x27;3. display       &#x27;</span><br><span class=\"line\">\tdb &#x27;4. display       &#x27;</span><br><span class=\"line\">\tdw 0    ;用于保存cx</span><br><span class=\"line\">datasg ends</span><br><span class=\"line\"></span><br><span class=\"line\">stacksg segment</span><br><span class=\"line\">\tdw 0,0,0,0,0,0,0,0</span><br><span class=\"line\">stacksg ends</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">codesg segment</span><br><span class=\"line\">start:\tmov ax,stacksg</span><br><span class=\"line\">\t\tmov ss,ax</span><br><span class=\"line\">\t\tmov sp,16 ;定位栈段</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tmov ax,datasg</span><br><span class=\"line\">\t\tmov ds,ax  ;定位内存</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tmov bx,0</span><br><span class=\"line\">\t\tmov cx,4  ;循环条件，bx偏移地址，cx循环条件，因为有四条字母，所以四次循环</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">s0:\t\tpush cx   ;外层循环，用户列循环，将cx入栈保证cx不受后续内层循环干扰</span><br><span class=\"line\">\t\tmov si,0</span><br><span class=\"line\">\t\tmov cx,4  ;内层循环，因为大写前四个字母，循环四次</span><br><span class=\"line\">s:\t\tmov al,[bx+3+si]</span><br><span class=\"line\">        and al,11011111b</span><br><span class=\"line\">        mov [bx+3+si],al</span><br><span class=\"line\">        inc si</span><br><span class=\"line\">        loop s</span><br><span class=\"line\">\t\tadd bx,16</span><br><span class=\"line\">\t\tpop cx</span><br><span class=\"line\">\t\tloop s0</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t\t</span><br><span class=\"line\">\t\tmov ax,4cooH</span><br><span class=\"line\">\t\tint 21H</span><br><span class=\"line\">codesg ends</span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure>\n<h2 id=\"数据处理的问题\"><a class=\"markdownIt-Anchor\" href=\"#数据处理的问题\">#</a> 数据处理的问题</h2>\n<p>reg 和 sreg  寄存器，段寄存器</p>\n<p>只有四个寄存器 bx,bp,si,di 可以用在 [] 中进行内存单元的寻址，可以单个出现或四种组合出现</p>\n<p>注意: mov ax [bp+bx]   mov ax,[si+di] 不能一起使用</p>\n<p>bp 如果没有显示指定段地址，那么段地址默认在 ss 中，可以简单理解为 sp</p>\n<p>mov ax,[bp]</p>\n<p>mov ax,[bp+si]</p>\n<p>mov ax,[bp+idata]</p>\n<p>汇编语句用三个概念来表达数据的位置</p>\n<p>1. 立即数</p>\n<p>2. 寄存器</p>\n<p>3. 段地址 (SA)，偏移地址 (EA)</p>\n<p>段地址寄存器默认</p>\n<p>mov ax,[0]   //==mov ax,ds:[0] , 注意，只有 0 能这么搞，其他的数字会被当成立即数处理，不会被当场偏移地址处理</p>\n<p>mov ax,[bx+si]</p>\n<p>mov ax,[bp]    // 段地址默认在 ss 中</p>\n<p>段地址寄存器显示指出</p>\n<p>mov ax,ds:[bp]</p>\n<p>mov ax,cs:[bx+si+8]  // 显示指出可以随便给，默认指出就给 ss</p>\n<p>寻址方式</p>\n<img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221022185518717.png\" alt=\"image-20221022185518717\" style=\"zoom:67%;\" />\n<img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221022191402201.png\" alt=\"image-20221022191402201\" style=\"zoom:67%;\" />\n<blockquote>\n<p>1. 将 cs：ip 通过地址加法器，算出一个 20 位的地址，通过地址总线，送到内存中，在内存中找到对应的位置</p>\n<p>2. 将 1 找到的内存的数据，比如 A10E00 通过数据总线，送到指令缓冲寄存器中</p>\n<p>3. 执行指令</p>\n<p>4. 将所有偏移地址送到地址加法器中算出一个偏移地址，通过地址总线送到内存中</p>\n<p>5. 将 4 中的数据，比如 A10E 通过数据总线，送给对应寄存器</p>\n<p>6.IP 指向下一条指令</p>\n</blockquote>\n<p>确定要处理的数据有多长</p>\n<p>1. 通过寄存器名指明数据大小 mov ax,1 这时 1 就是 16 位的，因为 ax 也是 16 位的    mov ax,ds:[0]  这时候 ds 偏移地址中数据也是八位的</p>\n<p>2. 通过操作符 x ptr 指明内存单元长度，x 可以为 word 或 byte，可以理解为强制转换法</p>\n<blockquote>\n<p>mov word ptr ds:[0],1     // 这时 16 位的，0001H</p>\n<p>inc word ptr [bx],2</p>\n<p>mov byte ptr ds:[0],1  // 这时 8 位的，01H</p>\n<p>double word ptr 双字</p>\n</blockquote>\n<p>3. 其他方法 push [1000H] 入栈，push 指令只对字进行操作 sp=sp-2</p>\n<p>用 bx 定位整个结构体，用 idata 定位结构体中的某一个数据项，用 si 定位数组项中的每个元素。</p>\n<p>[bx].idata</p>\n<p>[bx].idata[si]</p>\n<p>div</p>\n<p>除数 8/16 位，被除数默认放在 ax,dx 和 ax 中</p>\n<p>如果除数为 8 位，被除数需要 16 位 (ax)</p>\n<p>如果除数为 16 位，被除数需要 32 位 (ax+dx),dx 是高位，ax 是低位</p>\n<p>除数是 8 位的时候，商在 al 中，余数在 ah 中</p>\n<p>除数是 16 位的时候，商在 ax 中，余数在 dx 中</p>\n<p>div 寄存器</p>\n<p>div 内存单元</p>\n<p>div btye ptr ds:[0]   // <code>(al)=(ax)/((ds)*16+0)的商，(ah)=(ax)/((ds)*16+0)的余数</code></p>\n<p>div word ptr es:[0]  // <code>(ax)=[(dx)*10000H+(ax)]/((ds)*16+0)的商，(dx)=[(dx)*10000H+(ax)]/((ds)*16)+0的余数</code></p>\n<p>10001/100</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov dx,1</span><br><span class=\"line\">mov ax,86a1</span><br><span class=\"line\">mov bx,100</span><br><span class=\"line\">div bx</span><br></pre></td></tr></table></figure>\n<p>1001/100</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov ax,1001</span><br><span class=\"line\">mob bl,100</span><br><span class=\"line\">div bl</span><br></pre></td></tr></table></figure>\n<p>dd 定义双字</p>\n<p>用 div 计第 data 段中第一个数据除以第二个数据后的结果・商存放在第 3 个数据的存储单元。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code,ds:data</span><br><span class=\"line\">data segment</span><br><span class=\"line\">\tdd 100001</span><br><span class=\"line\">\tdw 100</span><br><span class=\"line\">\tdw 0</span><br><span class=\"line\">data ends</span><br><span class=\"line\"></span><br><span class=\"line\">code segment</span><br><span class=\"line\">start:\tmov ax,data\t</span><br><span class=\"line\">\t\tmov ds,ax</span><br><span class=\"line\">\t\tmov ax,ds:[0]</span><br><span class=\"line\">\t\tmov dx,ds:[2]</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tdiv word ptr ds:[4]</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tmov ds:[6],ax</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tmov ax,4c00H</span><br><span class=\"line\">\t\tint 21H</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">codesg ends</span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure>\n<p>dup</p>\n<p>db 3 dup (0)   定义 3byte，他们值都是 0</p>\n<p>db 3 dup(0,1,2)  //0,1,2,0,1,2,0,1,2</p>\n<p>db 3 dup(‘abc’,‘ABC’)  //abcABCabcABCabcABC</p>\n<p>db/dw/dd n dup()</p>\n<h2 id=\"转移指令\"><a class=\"markdownIt-Anchor\" href=\"#转移指令\">#</a> 转移指令</h2>\n<p>8086 转移指令分为：</p>\n<p>8086CPU 的转移行为有以下几类。</p>\n<blockquote>\n<p>1. 无条件转移</p>\n<p>2. 条件转移指令</p>\n<p>3. 循环指令</p>\n<p>4. 过程</p>\n<p>5. 中断</p>\n</blockquote>\n<ol>\n<li></li>\n</ol>\n<p>jmp 无条件跳转</p>\n<p>只修改 IP 时，称为段内转移，比如: jmp ax。</p>\n<p>同时修改 CS 和 IP 时，称为段间转移，比如: jmp 1000:0。</p>\n<p>由于转移指令对 IP 的修改范围不同，段内转移又分为：短转移和近转移。</p>\n<p>短转移 IP 的修改范围为 - 128~127。</p>\n<p>近转移 IP 的修改范围为 - 32768~32767。</p>\n<p>操作符 offset</p>\n<p>取得标号的偏移地址</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">start:\tmov ax,offset start   ;mov ax,0</span><br><span class=\"line\">s:\t\tmov ax,offset s\t\t  ;mov ax,3</span><br></pre></td></tr></table></figure>\n<p>jmp 指令</p>\n<p><code>jmp short 标号</code>   ；转移到标号处执行指令是种短转移，修改 IP 范围为 - 128-127</p>\n<p>然鹅，jmp 0008 的机器码为 EB 03，0008 为需要跳转的命令地址</p>\n<p>jmp 000A   EB 05</p>\n<p>CPU 不需要目的地址就可以实现对 IP 的修改</p>\n<p>EB 后面的数字实际是个 offset，说明目的指令离 jmp 五个字节</p>\n<p><code>jmp near ptr 标号 </code>  , 用于实现段内近转移位移范围 - 32769-32767</p>\n<p><code>jmp far ptr 标号</code>      // 段间转移，远转移</p>\n<p>far ptr 指明了格用标号的段地址和偏移地址修改 CS 和 IP</p>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221024210038120.png\" alt=\"image-20221024210038120\"></p>\n<p>此时机器码为跳转的地址，IP 在前，CS 在后</p>\n<p><code>jmp 16位寄存器</code></p>\n<p>jmp ax     // 实现段内近 / 短转移，ax 中为 ip 的值</p>\n<p>转移地址在内存中：</p>\n<p><code>jmp word ptr 内存单元地址</code>     // 实现内存单元地址的段内转移，内存单元地址是目的地址</p>\n<p>jmp word ptr ds:[0]</p>\n<p>jmp word ptr [bx]</p>\n<p><code>jmp dword ptr 内存单元地址</code>    // 段间跳转，跳转时 IP 是高位，CS 是低位</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov ax,0123H</span><br><span class=\"line\">mov [bx],ax</span><br><span class=\"line\">mov word ptr [bx+2],0</span><br><span class=\"line\">jmp dword ptr [bx]</span><br></pre></td></tr></table></figure>\n<p>jcxz 标号；有条件跳转指令</p>\n<p>IP 修改范围 - 128-127</p>\n<p>如果 cx=0，转移到标号处</p>\n<p>cx=0 时，IP 位移</p>\n<p>cx!=0 向下执行</p>\n<p>loop 标号</p>\n<p>转移范围 - 128-127，短转移</p>\n<p>cx=0 向下执行，cx！=0 转移到标号处</p>\n<h2 id=\"call和ret\"><a class=\"markdownIt-Anchor\" href=\"#call和ret\">#</a> call 和 ret</h2>\n<p>call 和 ret 都是转移指令，他们都修改 IP，或者同时修改 CS:IP</p>\n<p>ret 用栈中数据修改 IP 实现近转移</p>\n<p>IP = SS*16 + SP</p>\n<p>SP = SP + 2</p>\n<p>pop ip</p>\n<p>retf 修改 CS:IP 实现远转移</p>\n<p>IP = SS*16 + SP</p>\n<p>SP = SP + 2</p>\n<p>CS = ss*16 + SP</p>\n<p>(SP) = (SP) + 2</p>\n<p>pop ip</p>\n<p>pop cs</p>\n<p>call</p>\n<p>将 IP 或 CSIP 入栈，转移 (jmp)</p>\n<p>call 不能实现短转移</p>\n<p>call 标号   将当前 IP 压栈，转移到标号</p>\n<p>sp = sp -2</p>\n<p>ss*16 + sp = IP</p>\n<p>IP = IP + 位移 (16 位)</p>\n<p>相当于: push ip     +  jmp near ptr 标号</p>\n<p>call 只是将当前位置保存到栈了，其余和 jmp 一样</p>\n<p>call 16 位寄存器</p>\n<p>push IP</p>\n<p>jmp bx</p>\n<p>转移地址在内存中 call</p>\n<p>call word ptr 内存地址</p>\n<p>push IP   jmp word ptr 偏移地址</p>\n<p>call dword ptr 内存地址</p>\n<p>push cs   push IP   jmp dword ptr 内存单元地址</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov sp,10h</span><br><span class=\"line\">mov ax,0123h</span><br><span class=\"line\">mov ds:[0],ax</span><br><span class=\"line\">mov word ptr ds:[2],0</span><br><span class=\"line\">call dword ptr ds:[0]</span><br><span class=\"line\"></span><br><span class=\"line\">---</span><br><span class=\"line\">此时ds中低位为0123(IP)，高位为0000(CS)</span><br><span class=\"line\">call结束后,cs=0,ip=0123,sp=0ch</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code</span><br><span class=\"line\">code segment</span><br><span class=\"line\">start: \tmov ax,1</span><br><span class=\"line\">\t\tmov cx,3</span><br><span class=\"line\">\t\tcall s</span><br><span class=\"line\">\t\tmov bx,ax  ;bx=8</span><br><span class=\"line\">\t\tmov ax,4c00h</span><br><span class=\"line\">\t\tint 21h</span><br><span class=\"line\">s:\t\tadd ax,ax</span><br><span class=\"line\">\t\tloop s</span><br><span class=\"line\">\t\tret</span><br><span class=\"line\">code ends</span><br><span class=\"line\">end start    ;实现2^n</span><br></pre></td></tr></table></figure>\n<p><img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221028213345088.png\" alt=\"image-20221028213345088\"></p>\n<p>某种意义上来说，call 是调用，ret 是返回 (return)</p>\n<p>call 和 ret 要对应</p>\n<p>mul 指令</p>\n<p>相乘的两个数要么都是 8 要么都是 16</p>\n<p>8 位：AL 中或内存中</p>\n<p>16 位：AX 中或内存中</p>\n<p>结果：</p>\n<p>8 位：ax 中</p>\n<p>16 位：dx（高位），ax（低位）</p>\n<p>mul 寄存器</p>\n<p>mul 内存单元</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mul byte ptr ds:[0]</span><br><span class=\"line\">ax = al * (ds:[0])</span><br><span class=\"line\"></span><br><span class=\"line\">mul word ptr [bx+si+8]</span><br><span class=\"line\">ax=ax*([bx+si+8]) 低16位</span><br><span class=\"line\">dx=ax*([bx+si+8]) 高16位</span><br></pre></td></tr></table></figure>\n<p>100*10</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov al,100</span><br><span class=\"line\">mov b1,10</span><br><span class=\"line\">mul bl</span><br></pre></td></tr></table></figure>\n<p>即需要将任意一个乘数放在 ax 或 al 中，另一个乘数放在空闲的通用寄存器中</p>\n<p>计算 n 的三次方</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cube:\tmov ax,bx</span><br><span class=\"line\">\t\tmul bx</span><br><span class=\"line\">\t\tmul bx</span><br><span class=\"line\">\t\tret</span><br></pre></td></tr></table></figure>\n<p>dw 的三次方放入 dw 中</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code,cs:data,ss:stack</span><br><span class=\"line\"></span><br><span class=\"line\">data segment</span><br><span class=\"line\">\tdw 1,2,3,4,5,6,7,8</span><br><span class=\"line\">\tdw 0,0,0,0,0,0,0,0</span><br><span class=\"line\">data ends</span><br><span class=\"line\"></span><br><span class=\"line\">code segment</span><br><span class=\"line\">start:\tmov ax,data</span><br><span class=\"line\">\t\tmov ds,ax</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tmov cx,8</span><br><span class=\"line\">\t\tmov si,0</span><br><span class=\"line\">s:\t\tmov bx,[si]  ;bx作为cube的参数</span><br><span class=\"line\">\t\tcall cube</span><br><span class=\"line\">\t\tmov [si+32],ax</span><br><span class=\"line\">\t\tadd ax,2</span><br><span class=\"line\">\t\tloop s</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tmov ax,4c00H</span><br><span class=\"line\">\t\tint 21H</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">cube:\tmov ax,bx\t</span><br><span class=\"line\">\t\tmul bx</span><br><span class=\"line\">\t\tmul bx</span><br><span class=\"line\">\t\tret</span><br><span class=\"line\"></span><br><span class=\"line\">code ends</span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure>\n<p>对于批量数据的传递，我们将它存在内存中，然后把首地址放在寄存器中</p>\n<p>判断是否以 0 结束，不是就转为大写</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">capital:mov cl:[si]</span><br><span class=\"line\">        mov ch,0</span><br><span class=\"line\">        jcxz ok</span><br><span class=\"line\">        and byte ptr[si],11011111b</span><br><span class=\"line\">        inc si</span><br><span class=\"line\">        jmp short capital</span><br></pre></td></tr></table></figure>\n<h2 id=\"标志寄存器\"><a class=\"markdownIt-Anchor\" href=\"#标志寄存器\">#</a> 标志寄存器</h2>\n<p>8086CPU 的标志客存器有 16 位，其中存储的信息通常被称为程序状态字 (PSW) 。</p>\n<p>标志寄存器结构：</p>\n<img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221030202144281.png\" alt=\"image-20221030202144281\" style=\"zoom:67%;\" />\n<img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221030205228119.png\" alt=\"image-20221030205228119\" style=\"zoom:67%;\" />\n<img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221030205356183.png\" alt=\"image-20221030205356183\" style=\"zoom:67%;\" />\n<p>ZF</p>\n<p>零标志位，执行指令后如果结果为 0，zf=1</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov ax,1</span><br><span class=\"line\">sub ax,1 </span><br><span class=\"line\">此时ZF=1</span><br></pre></td></tr></table></figure>\n<p>运算指令，大多数会影响 ZF 寄存器</p>\n<p>PF</p>\n<p>奇偶标志位，指令执行后，如果 1 的个数为偶数，PF=1</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov al,1</span><br><span class=\"line\">add al,10</span><br><span class=\"line\">;00001011   PF=0  因为3个1</span><br></pre></td></tr></table></figure>\n<p>SF</p>\n<p>符号标志位，执行指令后，结果为负，SF=1</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov al,10000001</span><br><span class=\"line\">add al,1</span><br><span class=\"line\">;可以当做无符号，130，有符号，-126</span><br></pre></td></tr></table></figure>\n<p>CF</p>\n<p>进位标志位，无符号运算标志位可能产生结果</p>\n<p>CF=NC 无进位，CF=CY 有进位，只记录上一条指令的变化</p>\n<p>not carry carry</p>\n<p>进位是更高位</p>\n<p>OF</p>\n<p>溢出标志位，有符号运算可能产生结果</p>\n<p>OF=OV 溢出  OF=NV 无溢出</p>\n<p>溢出是侵犯了符号位</p>\n<p><strong>当成有符号就看 OF 和 SF，当成无符号就看 CF</strong></p>\n<p>ADC</p>\n<p>带进位加法指令，利用了 CF 上进位值</p>\n<p>adc ax,bx   ;ax = ax + bx + cf</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov ax,2</span><br><span class=\"line\">mov bx,1</span><br><span class=\"line\">sub bx,ax</span><br><span class=\"line\">adc ax,1</span><br><span class=\"line\">;ax=4 ax+1+cf=2+1+1=4</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov al,98h</span><br><span class=\"line\">add al,al</span><br><span class=\"line\">adc al,3</span><br><span class=\"line\">;ax+3+cf = 30+3+1=34</span><br></pre></td></tr></table></figure>\n<p>加法分为两步</p>\n<p>1. 低位相加</p>\n<p>2. 高位相加，在加上低位相加产生的进位值</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">add ax,bx</span><br><span class=\"line\">===</span><br><span class=\"line\">add al,bl</span><br><span class=\"line\">adc ah,bh</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>就是那种 1EF000H+201000H</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code</span><br><span class=\"line\"></span><br><span class=\"line\">code segment</span><br><span class=\"line\">start:\tmov ax,01EFH  ;high</span><br><span class=\"line\">\t\tmov bx,0F00H  ;low </span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tmov cx,1000H  ;low</span><br><span class=\"line\">\t\tmov dx,0201H  ;high</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tadd bx,cx</span><br><span class=\"line\">\t\tadc ax,dx</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">cube:\tmov ax,bx\t</span><br><span class=\"line\">\t\tmul bx</span><br><span class=\"line\">\t\tmul bx</span><br><span class=\"line\">\t\tret</span><br><span class=\"line\"></span><br><span class=\"line\">code ends</span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure>\n<p>或者只用两个寄存器</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov ax,001EH</span><br><span class=\"line\">mov bx,0F000H</span><br><span class=\"line\">add bx,1000H</span><br><span class=\"line\">adc ax,0020H</span><br></pre></td></tr></table></figure>\n<p>inc 和 loop 不影响 CF 的值，因此不能替换为 add ax,2</p>\n<p>sbb</p>\n<p>带进位减法指令</p>\n<p>sbb ax,bx</p>\n<p>ax = ax - bx - cf</p>\n<p>cmp</p>\n<p>功能类似于减法指令，但不保存结果，只对标志寄存器产生影响</p>\n<p>cmp ax,ax</p>\n<p>ax-ax ，不保存结果，只影响 flag，ZF=1,PF=1,SF=1,CF=0,OF=0</p>\n<p>cmp ax,bx</p>\n<img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221031205029865.png\" alt=\"image-20221031205029865\" style=\"zoom:67%;\" />\n<p>cmp ax,ax</p>\n<img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221031205427616.png\" alt=\"image-20221031205427616\" style=\"zoom:67%;\" />\n<p>cmp ah,bh 比较有符号数时，需要比较 SF 和 OF</p>\n<p>sf=1,of=0,ah&lt;bh</p>\n<p>SF=1,OF=1,ah&gt;bh</p>\n<p>SF=0,of=1,ah&lt;bh</p>\n<p>sf=0,of=0,ah&gt;=bh</p>\n<p>据无符号数的比较结果进行转移的条件转移指令，它们检测 ZF,CF 的值；</p>\n<p>和根据有符号数的比较结果进行转移的条件转移指令，它们检测 SF,OF ,ZF 的值・</p>\n<p>以下都是无符号指令比较时</p>\n<img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221031210918994.png\" alt=\"image-20221031210918994\" style=\"zoom:67%;\" />\n<p>equal</p>\n<p>not equal</p>\n<p>below</p>\n<p>not below</p>\n<p>above</p>\n<p>not above</p>\n<p>ah=bh,ah=ah+ah,ah=ah+bh</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code</span><br><span class=\"line\"></span><br><span class=\"line\">code segment</span><br><span class=\"line\">start:\tmov ah,45h</span><br><span class=\"line\">\t\tmov bh 48h</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tcmp ah,bh</span><br><span class=\"line\">\t\tje s</span><br><span class=\"line\">\t\tadd ah,ah</span><br><span class=\"line\">\t\tjmp short ok</span><br><span class=\"line\">s:\t\tadd ah,ah</span><br><span class=\"line\">ok: \tret</span><br><span class=\"line\"></span><br><span class=\"line\">code ends</span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure>\n<p>cmp 和 je 等可以单独出现</p>\n<p>data 中是否小于 8，结果保存在 ax 中</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code,ds:data</span><br><span class=\"line\"></span><br><span class=\"line\">data segment</span><br><span class=\"line\">\tdb 1,2,3,4,5,6,7,8</span><br><span class=\"line\">data ends</span><br><span class=\"line\"></span><br><span class=\"line\">code segment</span><br><span class=\"line\">start:\tmov dx,data</span><br><span class=\"line\">\t\tmov ds,dx</span><br><span class=\"line\">\t\tmov ax,0</span><br><span class=\"line\">\t\tmov bx,0</span><br><span class=\"line\">\t\tmov cx,0</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">s0:\t\tcmp byte ptr [bx],8</span><br><span class=\"line\">\t\tjnb s</span><br><span class=\"line\">\t\tinc ax</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">s:\t\tinc bx</span><br><span class=\"line\">\t\tloop s0</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tmov ax,4c00h</span><br><span class=\"line\">\t\tint 21h</span><br><span class=\"line\"></span><br><span class=\"line\">code ends</span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure>\n<p>DF</p>\n<p>方向标志位，串处理指令中，控制 si，di 增减</p>\n<p>DF=0，si,di 递增</p>\n<p>DF=1，si,di 递减</p>\n<p>movsb</p>\n<p>以字节为单位传送</p>\n<p>1. <code>es*16 + di = ds*16+di</code></p>\n<p>2. 如果 df=0，si,di++</p>\n<p>如果 df=1，si,di–</p>\n<p>movsw</p>\n<p>和 movsb 一样，但 si 和 di 是以 2 递增或递减</p>\n<p>rep movsb</p>\n<p>rep movsw</p>\n<p>根据 cx 的值，重复后面的串传送指令</p>\n<p>循环实现 cx 个字符的传送，从 ds 送到 es</p>\n<p>cld：将 DF=0</p>\n<p>std：将 DF=1</p>\n<p>将 data 段的第一个字符串送到后面的空间</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code</span><br><span class=\"line\"></span><br><span class=\"line\">data segment</span><br><span class=\"line\">\tdb &#x27;welcome to masm!&#x27;</span><br><span class=\"line\">\tdb 16 dup (0)</span><br><span class=\"line\">data ends</span><br><span class=\"line\"></span><br><span class=\"line\">code segment</span><br><span class=\"line\">start:\tmov dx,data</span><br><span class=\"line\">\t\tmov ds,dx</span><br><span class=\"line\">\t\tmov es,dx</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tmov si,0</span><br><span class=\"line\">\t\tmov di,16</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tmov cx,16</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tcld</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\trep movsb</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tmov ax,4c00h</span><br><span class=\"line\">\t\tint 21h</span><br><span class=\"line\"></span><br><span class=\"line\">code ends</span><br><span class=\"line\">end start</span><br></pre></td></tr></table></figure>\n<p>pushf</p>\n<p>将标志寄存器压栈</p>\n<p>popf 从栈中弹出数据，送入标志寄存器</p>\n<p>比如</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">push ax</span><br><span class=\"line\">popf</span><br><span class=\"line\"></span><br><span class=\"line\">那么此时ax中就是标志寄存器中的值</span><br></pre></td></tr></table></figure>\n<p>如果学破解，到这边就可以跑路了</p>\n<hr>\n<hr>\n<hr>\n<h2 id=\"中断\"><a class=\"markdownIt-Anchor\" href=\"#中断\">#</a> 中断</h2>\n<p>中断分为硬件中断和软件中断</p>\n<p>硬件中断分为外部中断和内部中断</p>\n<p>内部中断是不可屏蔽的中断</p>\n<p>外部中断时可屏蔽的中断</p>\n<p>中断向量表</p>\n<p>CPU 用八位类型码通过中断向量表找到中断程序的入口地址</p>\n<p>中断向量表可以裂解为一个索引</p>\n<p>其中存放着 256 个中断源所对应的中断处理 程序入口</p>\n<p>8086 中，中断向量表在 0000:0000 - 0000:03FF 1024 个字节</p>\n<p>中断过程</p>\n<p>1. 取得中断类型码 N</p>\n<p>2.pushf</p>\n<p>3.TF=0，IF=0</p>\n<p>4.push cs</p>\n<p>5.push ip</p>\n<p>6. <code>(IP) = (N*4) , (CS) = (N*4+2)</code>    N*x 指的是在中断向量表中找 CS 和 IP</p>\n<p>中断处理步骤</p>\n<p>1. 保存用到的寄存器</p>\n<p>2. 处理中断</p>\n<p>3. 恢复用到的寄存器</p>\n<p>4. 用 iret 指令返回</p>\n<p>iret – pop ip  pop cs  popf</p>\n<p>中断寄存器入栈标志，CS，IP。iret 正好和他相反</p>\n<p>除法溢出，产生中断类型为 0</p>\n<p>我们是可以改变中断后处理的过程的</p>\n<p>改变 0 号中断处理程序</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code</span><br><span class=\"line\"></span><br><span class=\"line\">code segment</span><br><span class=\"line\">start:\t</span><br><span class=\"line\">\t\tmov ax, cs</span><br><span class=\"line\">\t\tmov ds, ax</span><br><span class=\"line\">\t\tmov si, offset do0\t\t;设置ds:si指向源地址</span><br><span class=\"line\">\t\tmov ax, 0</span><br><span class=\"line\">\t\tmov es, ax</span><br><span class=\"line\">\t\tmov di, 200h\t\t\t;设置es:di指向目的地址</span><br><span class=\"line\">\t\tmov cx, offset do0end - offset do0\t\t;设置cx为传输长度</span><br><span class=\"line\">\t\tcld\t\t\t\t        ;设置传输方向为正</span><br><span class=\"line\">\t\trep movsb</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">\t\tmov ax, 0               ;设置中断向量表</span><br><span class=\"line\">\t\tmov es, ax</span><br><span class=\"line\">\t\tmov word ptr es:[0*4], 200h</span><br><span class=\"line\">\t\tmov word ptr es:[0*4+2], 0</span><br><span class=\"line\"></span><br><span class=\"line\">      \tmov ax,4c00h</span><br><span class=\"line\">      \tint 21h</span><br><span class=\"line\"></span><br><span class=\"line\">do0:\tjmp short do0start</span><br><span class=\"line\">      \tdb &quot;Welcome to Fishc.com!&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">do0start:</span><br><span class=\"line\">      \tmov ax, cs</span><br><span class=\"line\">      \tmov ds, ax</span><br><span class=\"line\">      \tmov si, 202h\t\t\t;设置ds:si指向字符串</span><br><span class=\"line\"></span><br><span class=\"line\">      \tmov ax, 0b800h</span><br><span class=\"line\">      \tmov es, ax</span><br><span class=\"line\">\t\tmov di, 12*160+36*2\t\t;设置es:di指向显存空间的中间位置</span><br><span class=\"line\"></span><br><span class=\"line\">        mov cx, 21\t\t\t\t;设置cx为字符串长度</span><br><span class=\"line\">\ts:\tmov al, [si]</span><br><span class=\"line\">      \tmov es:[di], al</span><br><span class=\"line\">      \tinc si</span><br><span class=\"line\">      \tadd di, 1</span><br><span class=\"line\">\t\tmov al, 02h             ;设置颜色</span><br><span class=\"line\">\t\tmov es:[di], al        </span><br><span class=\"line\">\t\tadd di, 1</span><br><span class=\"line\">      \tloop s</span><br><span class=\"line\"></span><br><span class=\"line\">      \tmov ax, 4c00h</span><br><span class=\"line\">      \tint 21h</span><br><span class=\"line\">do0end:\tnop</span><br><span class=\"line\"></span><br><span class=\"line\">code ends</span><br><span class=\"line\">end start</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>单步中断</p>\n<p>CPU 在执行完一条指令之后，如果检到标志寄存器的 TF 位为 1，则产生单步中断，引发中断过程。</p>\n<p>但不中断类型码为 1</p>\n<p>中断过程：</p>\n<p>取得中断类型码 1</p>\n<p>TF=0 ,IF=0</p>\n<p>CS,IP 入栈</p>\n<p><code>IP=(1*4)  CS=(1*4+2)</code></p>\n<p>TF=1, 执行程一条指令后执行单步中断</p>\n<p>使用 t 命令是，debug 将 tf=1，执行完一条指令引发单步中断，显示寄存器，等待输入</p>\n<p>也有情况，即使发生中断，也不响应</p>\n<p>设置完 ss 后，即使中断，cpu 也不响应，因为 ss:sp 需要连续完成，不然 sp 指向的不是正确的栈顶</p>\n<p>我们利用这个特性，将 ss 和 sp 的设置指令连续存放</p>\n<p>mov ax,1000h</p>\n<p>mov ss,ax</p>\n<p>mov sp,0</p>\n<p>mov ax,10</p>\n<p>如果 ax=10 放在 sp 和 ss 中间，该指令不会被执行</p>\n<h2 id=\"int\"><a class=\"markdownIt-Anchor\" href=\"#int\">#</a> int</h2>\n<p>int n  n 为中断类型码，引发中断过程</p>\n<p>1. 取得类型码 n</p>\n<p>2.IF=0,TF=0</p>\n<p>3.CS,IP 入栈</p>\n<p><code>4.IP=(n*4)  CS=(n*4+2)</code></p>\n<p>可以不做触发，通过 int 执行 0 号中断</p>\n<p>int 一般和 iret 指令配合使用</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">assume cs:code</span><br><span class=\"line\">code segment</span><br><span class=\"line\"></span><br><span class=\"line\">start:</span><br><span class=\"line\">\t\tmov ax,cs</span><br><span class=\"line\">\t\tmov ds,ax</span><br><span class=\"line\">\t\tmov si,offset capital</span><br><span class=\"line\">\t\tmov ax,0</span><br><span class=\"line\">\t\tmov es,ax</span><br><span class=\"line\">\t\tmov di,200h</span><br><span class=\"line\">\t\tmov cx,offset capitalend - offset capital</span><br><span class=\"line\">\t\tcld</span><br><span class=\"line\">\t\trep movsb</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tmov ax,0</span><br><span class=\"line\">\t\tmov es,ax</span><br><span class=\"line\">\t\tmov word ptr es:[7ch*4],200h</span><br><span class=\"line\">\t\tmov word ptr es:[7ch*4+2],0</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tmov ax,4c00h</span><br><span class=\"line\">\t\tint 21h</span><br><span class=\"line\"></span><br><span class=\"line\">capital:</span><br><span class=\"line\">\t\tpush cx</span><br><span class=\"line\">\t\tpush si</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">change: </span><br><span class=\"line\">\t\tmov cl,[si]</span><br><span class=\"line\">\t\tmov ch,0</span><br><span class=\"line\">\t\tjcxz ok</span><br><span class=\"line\">\t\tand byte ptr [si],11011111b</span><br><span class=\"line\">\t\tinc si</span><br><span class=\"line\">\t\tjmp short change</span><br><span class=\"line\">ok:\t</span><br><span class=\"line\">\t\tpop si</span><br><span class=\"line\">\t\tpop cx</span><br><span class=\"line\">\t\tiret</span><br><span class=\"line\">\t\t</span><br><span class=\"line\">capitalend:nop</span><br><span class=\"line\"></span><br><span class=\"line\">code ends</span><br><span class=\"line\"></span><br><span class=\"line\">end start</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>int 10h 是 bios 中断例程</p>\n<p>BIOS 和 DOS 中断例程用 ah 来传递子程序的编号</p>\n<p><code>(ah)=2表示调用第10h号中断例程的 2号子程序，功能为设置光标位置，可以提供光标所在的行号（80*25字符模式下:0~24 ),列号（80*25字符模式下: 0~79)，和页号作为参数。(bh)=6 , (dh)=5, (d1)=12，设置光标到第0页，第5行，第12列。</code></p>\n<p>内存地址中 B8000-BFFFFh 共 32kb，为显示缓冲区</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">;编程：在屏幕的5行12列显示3个红底高亮闪烁绿色的‘a’。</span><br><span class=\"line\"></span><br><span class=\"line\">assume cs:code</span><br><span class=\"line\">code segment</span><br><span class=\"line\">\tmov ah,2 \t;置光标</span><br><span class=\"line\">\tmov bh,0\t;第0页</span><br><span class=\"line\">\tmov dh,5\t;dh中放行号</span><br><span class=\"line\">\tmov dl,12\t;dl中放列号</span><br><span class=\"line\">\tint 10h\t</span><br><span class=\"line\">\t</span><br><span class=\"line\">\tmov ah,9\t;置光标</span><br><span class=\"line\">\tmov al,&#x27;a&#x27;\t;字符</span><br><span class=\"line\">\tmov bl,11001010b;颜色属性</span><br><span class=\"line\">\tmov bh,0\t;第0页</span><br><span class=\"line\">\tmov cx,3\t;字符重复个数</span><br><span class=\"line\">\tint 10h</span><br><span class=\"line\"></span><br><span class=\"line\">\tmov ax,4c00h</span><br><span class=\"line\">\tint 21h </span><br><span class=\"line\"></span><br><span class=\"line\">code ends</span><br><span class=\"line\">end</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>int 21H</p>\n<p>int 21h 中断例程是 DOS 提供的中断例程，其中包含了 DOS 提供给程序员在编程时调用为子程序</p>\n<p>我们从前一直使用的是 int 21 中断例程 4ch 号功能，即程序返回功能</p>\n<p>mov ah,4ch  ; 程序返回</p>\n<p>mov al,0        ; 返回值</p>\n<p>int 21h</p>\n<h2 id=\"端口\"><a class=\"markdownIt-Anchor\" href=\"#端口\">#</a> 端口</h2>\n<p>端口读写指令 in 和 out 分别用于读取和写入数据</p>\n<p>in al,60h</p>\n<p>从 60h 号端口读入一个字节</p>\n<p>在 in out 指令中，只能使用 ax 或 al 来存放从端口中读入的数据或要发送到端口中的数据</p>\n<p>in al,20h</p>\n<p>out 20h,al</p>\n<p>CMOS RAM</p>\n<p>包含一个时钟和一个有 128 位存储单元的 RAM 存储区</p>\n<p>128 个字节中，内部时钟占用 0-0dh，其余大部分单元用于保存系统配置信息</p>\n<p>BIOS 中有两个端口，为 70h 和 71h，通过这两个端口读取 CMOS RAM</p>\n<p>70h 为地址，存放 CMOS RAM 单元地址，71 为数据端口，存放选定的 CMOS RAM 读取的数据</p>\n<p>shl 和 shr</p>\n<p>逻辑移位指令</p>\n<p>shl 逻辑左移指令</p>\n<p>将一个数据向左移位，最后移除的移位写入 cf，最低位 0 补充，数据可以来自寄存器或内存单元</p>\n<p>移位位数大于 1 时，必须将移动位数放入 cl</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov al,01010001b</span><br><span class=\"line\">mov cl,3</span><br><span class=\"line\">shl al,cl    ;从al拿出来在放回al去</span><br></pre></td></tr></table></figure>\n<p>shr</p>\n<p>和 shl 相反</p>\n<p>右移 = / 2</p>\n<p>CMOS RAM 中时间信息</p>\n<p>秒 00H</p>\n<p>分 02H</p>\n<p>时 04H</p>\n<p>日 07H</p>\n<p>月 08H</p>\n<p>年 09H</p>\n<p>他们都占一个字节，以 BCD 码存放</p>\n<h2 id=\"外中断\"><a class=\"markdownIt-Anchor\" href=\"#外中断\">#</a> 外中断</h2>\n<p>CPU 通过端口和外部设备进行联系</p>\n<p>外中断源有两类</p>\n<p>1. 可屏蔽中断</p>\n<p>2. 不可屏蔽中断</p>\n<p>IF=1 响应中断过程</p>\n<p>IF=0 不响应中断过程</p>\n<p>sti 设置 IF=1</p>\n<p>cli 设置 IF=0</p>\n<p>PC 机键盘处理过程</p>\n<p>引发 9 号中断</p>\n<p>— 般将按下一个键时产生的扫描码称为通码，松开一个键产生的扫描码称为断码</p>\n<p>断码 = 通码 + 80H</p>\n<img data-src=\"https://kbshire-1308981697.cos.ap-shanghai.myqcloud.com/img/image-20221108214017480.png\" alt=\"image-20221108214017480\" style=\"zoom:50%;\" />\n",
            "tags": [
                "汇编"
            ]
        }
    ]
}